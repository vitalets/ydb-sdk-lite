/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/
"use strict";

var $protobuf = require("protobufjs/minimal");

// Common aliases
var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;

// Exported root namespace
var $root = $protobuf.roots["ydb-sdk"] || ($protobuf.roots["ydb-sdk"] = {});

$root.Ydb = (function() {

    /**
     * Namespace Ydb.
     * @exports Ydb
     * @namespace
     */
    var Ydb = {};

    Ydb.Table = (function() {

        /**
         * Namespace Table.
         * @memberof Ydb
         * @namespace
         */
        var Table = {};

        Table.V1 = (function() {

            /**
             * Namespace V1.
             * @memberof Ydb.Table
             * @namespace
             */
            var V1 = {};

            V1.TableService = (function() {

                /**
                 * Constructs a new TableService service.
                 * @memberof Ydb.Table.V1
                 * @classdesc Represents a TableService
                 * @extends $protobuf.rpc.Service
                 * @constructor
                 * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                 */
                function TableService(rpcImpl, requestDelimited, responseDelimited) {
                    $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
                }

                (TableService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = TableService;

                /**
                 * Creates new TableService service using the specified rpc implementation.
                 * @function create
                 * @memberof Ydb.Table.V1.TableService
                 * @static
                 * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                 * @returns {TableService} RPC service. Useful where requests and/or responses are streamed.
                 */
                TableService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                    return new this(rpcImpl, requestDelimited, responseDelimited);
                };

                /**
                 * Callback as used by {@link Ydb.Table.V1.TableService#createSession}.
                 * @memberof Ydb.Table.V1.TableService
                 * @typedef CreateSessionCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {Ydb.Table.CreateSessionResponse} [response] CreateSessionResponse
                 */

                /**
                 * Calls CreateSession.
                 * @function createSession
                 * @memberof Ydb.Table.V1.TableService
                 * @instance
                 * @param {Ydb.Table.ICreateSessionRequest} request CreateSessionRequest message or plain object
                 * @param {Ydb.Table.V1.TableService.CreateSessionCallback} callback Node-style callback called with the error, if any, and CreateSessionResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(TableService.prototype.createSession = function createSession(request, callback) {
                    return this.rpcCall(createSession, $root.Ydb.Table.CreateSessionRequest, $root.Ydb.Table.CreateSessionResponse, request, callback);
                }, "name", { value: "CreateSession" });

                /**
                 * Calls CreateSession.
                 * @function createSession
                 * @memberof Ydb.Table.V1.TableService
                 * @instance
                 * @param {Ydb.Table.ICreateSessionRequest} request CreateSessionRequest message or plain object
                 * @returns {Promise<Ydb.Table.CreateSessionResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link Ydb.Table.V1.TableService#deleteSession}.
                 * @memberof Ydb.Table.V1.TableService
                 * @typedef DeleteSessionCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {Ydb.Table.DeleteSessionResponse} [response] DeleteSessionResponse
                 */

                /**
                 * Calls DeleteSession.
                 * @function deleteSession
                 * @memberof Ydb.Table.V1.TableService
                 * @instance
                 * @param {Ydb.Table.IDeleteSessionRequest} request DeleteSessionRequest message or plain object
                 * @param {Ydb.Table.V1.TableService.DeleteSessionCallback} callback Node-style callback called with the error, if any, and DeleteSessionResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(TableService.prototype.deleteSession = function deleteSession(request, callback) {
                    return this.rpcCall(deleteSession, $root.Ydb.Table.DeleteSessionRequest, $root.Ydb.Table.DeleteSessionResponse, request, callback);
                }, "name", { value: "DeleteSession" });

                /**
                 * Calls DeleteSession.
                 * @function deleteSession
                 * @memberof Ydb.Table.V1.TableService
                 * @instance
                 * @param {Ydb.Table.IDeleteSessionRequest} request DeleteSessionRequest message or plain object
                 * @returns {Promise<Ydb.Table.DeleteSessionResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link Ydb.Table.V1.TableService#keepAlive}.
                 * @memberof Ydb.Table.V1.TableService
                 * @typedef KeepAliveCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {Ydb.Table.KeepAliveResponse} [response] KeepAliveResponse
                 */

                /**
                 * Calls KeepAlive.
                 * @function keepAlive
                 * @memberof Ydb.Table.V1.TableService
                 * @instance
                 * @param {Ydb.Table.IKeepAliveRequest} request KeepAliveRequest message or plain object
                 * @param {Ydb.Table.V1.TableService.KeepAliveCallback} callback Node-style callback called with the error, if any, and KeepAliveResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(TableService.prototype.keepAlive = function keepAlive(request, callback) {
                    return this.rpcCall(keepAlive, $root.Ydb.Table.KeepAliveRequest, $root.Ydb.Table.KeepAliveResponse, request, callback);
                }, "name", { value: "KeepAlive" });

                /**
                 * Calls KeepAlive.
                 * @function keepAlive
                 * @memberof Ydb.Table.V1.TableService
                 * @instance
                 * @param {Ydb.Table.IKeepAliveRequest} request KeepAliveRequest message or plain object
                 * @returns {Promise<Ydb.Table.KeepAliveResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link Ydb.Table.V1.TableService#createTable}.
                 * @memberof Ydb.Table.V1.TableService
                 * @typedef CreateTableCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {Ydb.Table.CreateTableResponse} [response] CreateTableResponse
                 */

                /**
                 * Calls CreateTable.
                 * @function createTable
                 * @memberof Ydb.Table.V1.TableService
                 * @instance
                 * @param {Ydb.Table.ICreateTableRequest} request CreateTableRequest message or plain object
                 * @param {Ydb.Table.V1.TableService.CreateTableCallback} callback Node-style callback called with the error, if any, and CreateTableResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(TableService.prototype.createTable = function createTable(request, callback) {
                    return this.rpcCall(createTable, $root.Ydb.Table.CreateTableRequest, $root.Ydb.Table.CreateTableResponse, request, callback);
                }, "name", { value: "CreateTable" });

                /**
                 * Calls CreateTable.
                 * @function createTable
                 * @memberof Ydb.Table.V1.TableService
                 * @instance
                 * @param {Ydb.Table.ICreateTableRequest} request CreateTableRequest message or plain object
                 * @returns {Promise<Ydb.Table.CreateTableResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link Ydb.Table.V1.TableService#dropTable}.
                 * @memberof Ydb.Table.V1.TableService
                 * @typedef DropTableCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {Ydb.Table.DropTableResponse} [response] DropTableResponse
                 */

                /**
                 * Calls DropTable.
                 * @function dropTable
                 * @memberof Ydb.Table.V1.TableService
                 * @instance
                 * @param {Ydb.Table.IDropTableRequest} request DropTableRequest message or plain object
                 * @param {Ydb.Table.V1.TableService.DropTableCallback} callback Node-style callback called with the error, if any, and DropTableResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(TableService.prototype.dropTable = function dropTable(request, callback) {
                    return this.rpcCall(dropTable, $root.Ydb.Table.DropTableRequest, $root.Ydb.Table.DropTableResponse, request, callback);
                }, "name", { value: "DropTable" });

                /**
                 * Calls DropTable.
                 * @function dropTable
                 * @memberof Ydb.Table.V1.TableService
                 * @instance
                 * @param {Ydb.Table.IDropTableRequest} request DropTableRequest message or plain object
                 * @returns {Promise<Ydb.Table.DropTableResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link Ydb.Table.V1.TableService#alterTable}.
                 * @memberof Ydb.Table.V1.TableService
                 * @typedef AlterTableCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {Ydb.Table.AlterTableResponse} [response] AlterTableResponse
                 */

                /**
                 * Calls AlterTable.
                 * @function alterTable
                 * @memberof Ydb.Table.V1.TableService
                 * @instance
                 * @param {Ydb.Table.IAlterTableRequest} request AlterTableRequest message or plain object
                 * @param {Ydb.Table.V1.TableService.AlterTableCallback} callback Node-style callback called with the error, if any, and AlterTableResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(TableService.prototype.alterTable = function alterTable(request, callback) {
                    return this.rpcCall(alterTable, $root.Ydb.Table.AlterTableRequest, $root.Ydb.Table.AlterTableResponse, request, callback);
                }, "name", { value: "AlterTable" });

                /**
                 * Calls AlterTable.
                 * @function alterTable
                 * @memberof Ydb.Table.V1.TableService
                 * @instance
                 * @param {Ydb.Table.IAlterTableRequest} request AlterTableRequest message or plain object
                 * @returns {Promise<Ydb.Table.AlterTableResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link Ydb.Table.V1.TableService#copyTable}.
                 * @memberof Ydb.Table.V1.TableService
                 * @typedef CopyTableCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {Ydb.Table.CopyTableResponse} [response] CopyTableResponse
                 */

                /**
                 * Calls CopyTable.
                 * @function copyTable
                 * @memberof Ydb.Table.V1.TableService
                 * @instance
                 * @param {Ydb.Table.ICopyTableRequest} request CopyTableRequest message or plain object
                 * @param {Ydb.Table.V1.TableService.CopyTableCallback} callback Node-style callback called with the error, if any, and CopyTableResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(TableService.prototype.copyTable = function copyTable(request, callback) {
                    return this.rpcCall(copyTable, $root.Ydb.Table.CopyTableRequest, $root.Ydb.Table.CopyTableResponse, request, callback);
                }, "name", { value: "CopyTable" });

                /**
                 * Calls CopyTable.
                 * @function copyTable
                 * @memberof Ydb.Table.V1.TableService
                 * @instance
                 * @param {Ydb.Table.ICopyTableRequest} request CopyTableRequest message or plain object
                 * @returns {Promise<Ydb.Table.CopyTableResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link Ydb.Table.V1.TableService#copyTables}.
                 * @memberof Ydb.Table.V1.TableService
                 * @typedef CopyTablesCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {Ydb.Table.CopyTablesResponse} [response] CopyTablesResponse
                 */

                /**
                 * Calls CopyTables.
                 * @function copyTables
                 * @memberof Ydb.Table.V1.TableService
                 * @instance
                 * @param {Ydb.Table.ICopyTablesRequest} request CopyTablesRequest message or plain object
                 * @param {Ydb.Table.V1.TableService.CopyTablesCallback} callback Node-style callback called with the error, if any, and CopyTablesResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(TableService.prototype.copyTables = function copyTables(request, callback) {
                    return this.rpcCall(copyTables, $root.Ydb.Table.CopyTablesRequest, $root.Ydb.Table.CopyTablesResponse, request, callback);
                }, "name", { value: "CopyTables" });

                /**
                 * Calls CopyTables.
                 * @function copyTables
                 * @memberof Ydb.Table.V1.TableService
                 * @instance
                 * @param {Ydb.Table.ICopyTablesRequest} request CopyTablesRequest message or plain object
                 * @returns {Promise<Ydb.Table.CopyTablesResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link Ydb.Table.V1.TableService#renameTables}.
                 * @memberof Ydb.Table.V1.TableService
                 * @typedef RenameTablesCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {Ydb.Table.RenameTablesResponse} [response] RenameTablesResponse
                 */

                /**
                 * Calls RenameTables.
                 * @function renameTables
                 * @memberof Ydb.Table.V1.TableService
                 * @instance
                 * @param {Ydb.Table.IRenameTablesRequest} request RenameTablesRequest message or plain object
                 * @param {Ydb.Table.V1.TableService.RenameTablesCallback} callback Node-style callback called with the error, if any, and RenameTablesResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(TableService.prototype.renameTables = function renameTables(request, callback) {
                    return this.rpcCall(renameTables, $root.Ydb.Table.RenameTablesRequest, $root.Ydb.Table.RenameTablesResponse, request, callback);
                }, "name", { value: "RenameTables" });

                /**
                 * Calls RenameTables.
                 * @function renameTables
                 * @memberof Ydb.Table.V1.TableService
                 * @instance
                 * @param {Ydb.Table.IRenameTablesRequest} request RenameTablesRequest message or plain object
                 * @returns {Promise<Ydb.Table.RenameTablesResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link Ydb.Table.V1.TableService#describeTable}.
                 * @memberof Ydb.Table.V1.TableService
                 * @typedef DescribeTableCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {Ydb.Table.DescribeTableResponse} [response] DescribeTableResponse
                 */

                /**
                 * Calls DescribeTable.
                 * @function describeTable
                 * @memberof Ydb.Table.V1.TableService
                 * @instance
                 * @param {Ydb.Table.IDescribeTableRequest} request DescribeTableRequest message or plain object
                 * @param {Ydb.Table.V1.TableService.DescribeTableCallback} callback Node-style callback called with the error, if any, and DescribeTableResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(TableService.prototype.describeTable = function describeTable(request, callback) {
                    return this.rpcCall(describeTable, $root.Ydb.Table.DescribeTableRequest, $root.Ydb.Table.DescribeTableResponse, request, callback);
                }, "name", { value: "DescribeTable" });

                /**
                 * Calls DescribeTable.
                 * @function describeTable
                 * @memberof Ydb.Table.V1.TableService
                 * @instance
                 * @param {Ydb.Table.IDescribeTableRequest} request DescribeTableRequest message or plain object
                 * @returns {Promise<Ydb.Table.DescribeTableResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link Ydb.Table.V1.TableService#explainDataQuery}.
                 * @memberof Ydb.Table.V1.TableService
                 * @typedef ExplainDataQueryCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {Ydb.Table.ExplainDataQueryResponse} [response] ExplainDataQueryResponse
                 */

                /**
                 * Calls ExplainDataQuery.
                 * @function explainDataQuery
                 * @memberof Ydb.Table.V1.TableService
                 * @instance
                 * @param {Ydb.Table.IExplainDataQueryRequest} request ExplainDataQueryRequest message or plain object
                 * @param {Ydb.Table.V1.TableService.ExplainDataQueryCallback} callback Node-style callback called with the error, if any, and ExplainDataQueryResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(TableService.prototype.explainDataQuery = function explainDataQuery(request, callback) {
                    return this.rpcCall(explainDataQuery, $root.Ydb.Table.ExplainDataQueryRequest, $root.Ydb.Table.ExplainDataQueryResponse, request, callback);
                }, "name", { value: "ExplainDataQuery" });

                /**
                 * Calls ExplainDataQuery.
                 * @function explainDataQuery
                 * @memberof Ydb.Table.V1.TableService
                 * @instance
                 * @param {Ydb.Table.IExplainDataQueryRequest} request ExplainDataQueryRequest message or plain object
                 * @returns {Promise<Ydb.Table.ExplainDataQueryResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link Ydb.Table.V1.TableService#prepareDataQuery}.
                 * @memberof Ydb.Table.V1.TableService
                 * @typedef PrepareDataQueryCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {Ydb.Table.PrepareDataQueryResponse} [response] PrepareDataQueryResponse
                 */

                /**
                 * Calls PrepareDataQuery.
                 * @function prepareDataQuery
                 * @memberof Ydb.Table.V1.TableService
                 * @instance
                 * @param {Ydb.Table.IPrepareDataQueryRequest} request PrepareDataQueryRequest message or plain object
                 * @param {Ydb.Table.V1.TableService.PrepareDataQueryCallback} callback Node-style callback called with the error, if any, and PrepareDataQueryResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(TableService.prototype.prepareDataQuery = function prepareDataQuery(request, callback) {
                    return this.rpcCall(prepareDataQuery, $root.Ydb.Table.PrepareDataQueryRequest, $root.Ydb.Table.PrepareDataQueryResponse, request, callback);
                }, "name", { value: "PrepareDataQuery" });

                /**
                 * Calls PrepareDataQuery.
                 * @function prepareDataQuery
                 * @memberof Ydb.Table.V1.TableService
                 * @instance
                 * @param {Ydb.Table.IPrepareDataQueryRequest} request PrepareDataQueryRequest message or plain object
                 * @returns {Promise<Ydb.Table.PrepareDataQueryResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link Ydb.Table.V1.TableService#executeDataQuery}.
                 * @memberof Ydb.Table.V1.TableService
                 * @typedef ExecuteDataQueryCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {Ydb.Table.ExecuteDataQueryResponse} [response] ExecuteDataQueryResponse
                 */

                /**
                 * Calls ExecuteDataQuery.
                 * @function executeDataQuery
                 * @memberof Ydb.Table.V1.TableService
                 * @instance
                 * @param {Ydb.Table.IExecuteDataQueryRequest} request ExecuteDataQueryRequest message or plain object
                 * @param {Ydb.Table.V1.TableService.ExecuteDataQueryCallback} callback Node-style callback called with the error, if any, and ExecuteDataQueryResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(TableService.prototype.executeDataQuery = function executeDataQuery(request, callback) {
                    return this.rpcCall(executeDataQuery, $root.Ydb.Table.ExecuteDataQueryRequest, $root.Ydb.Table.ExecuteDataQueryResponse, request, callback);
                }, "name", { value: "ExecuteDataQuery" });

                /**
                 * Calls ExecuteDataQuery.
                 * @function executeDataQuery
                 * @memberof Ydb.Table.V1.TableService
                 * @instance
                 * @param {Ydb.Table.IExecuteDataQueryRequest} request ExecuteDataQueryRequest message or plain object
                 * @returns {Promise<Ydb.Table.ExecuteDataQueryResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link Ydb.Table.V1.TableService#executeSchemeQuery}.
                 * @memberof Ydb.Table.V1.TableService
                 * @typedef ExecuteSchemeQueryCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {Ydb.Table.ExecuteSchemeQueryResponse} [response] ExecuteSchemeQueryResponse
                 */

                /**
                 * Calls ExecuteSchemeQuery.
                 * @function executeSchemeQuery
                 * @memberof Ydb.Table.V1.TableService
                 * @instance
                 * @param {Ydb.Table.IExecuteSchemeQueryRequest} request ExecuteSchemeQueryRequest message or plain object
                 * @param {Ydb.Table.V1.TableService.ExecuteSchemeQueryCallback} callback Node-style callback called with the error, if any, and ExecuteSchemeQueryResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(TableService.prototype.executeSchemeQuery = function executeSchemeQuery(request, callback) {
                    return this.rpcCall(executeSchemeQuery, $root.Ydb.Table.ExecuteSchemeQueryRequest, $root.Ydb.Table.ExecuteSchemeQueryResponse, request, callback);
                }, "name", { value: "ExecuteSchemeQuery" });

                /**
                 * Calls ExecuteSchemeQuery.
                 * @function executeSchemeQuery
                 * @memberof Ydb.Table.V1.TableService
                 * @instance
                 * @param {Ydb.Table.IExecuteSchemeQueryRequest} request ExecuteSchemeQueryRequest message or plain object
                 * @returns {Promise<Ydb.Table.ExecuteSchemeQueryResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link Ydb.Table.V1.TableService#beginTransaction}.
                 * @memberof Ydb.Table.V1.TableService
                 * @typedef BeginTransactionCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {Ydb.Table.BeginTransactionResponse} [response] BeginTransactionResponse
                 */

                /**
                 * Calls BeginTransaction.
                 * @function beginTransaction
                 * @memberof Ydb.Table.V1.TableService
                 * @instance
                 * @param {Ydb.Table.IBeginTransactionRequest} request BeginTransactionRequest message or plain object
                 * @param {Ydb.Table.V1.TableService.BeginTransactionCallback} callback Node-style callback called with the error, if any, and BeginTransactionResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(TableService.prototype.beginTransaction = function beginTransaction(request, callback) {
                    return this.rpcCall(beginTransaction, $root.Ydb.Table.BeginTransactionRequest, $root.Ydb.Table.BeginTransactionResponse, request, callback);
                }, "name", { value: "BeginTransaction" });

                /**
                 * Calls BeginTransaction.
                 * @function beginTransaction
                 * @memberof Ydb.Table.V1.TableService
                 * @instance
                 * @param {Ydb.Table.IBeginTransactionRequest} request BeginTransactionRequest message or plain object
                 * @returns {Promise<Ydb.Table.BeginTransactionResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link Ydb.Table.V1.TableService#commitTransaction}.
                 * @memberof Ydb.Table.V1.TableService
                 * @typedef CommitTransactionCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {Ydb.Table.CommitTransactionResponse} [response] CommitTransactionResponse
                 */

                /**
                 * Calls CommitTransaction.
                 * @function commitTransaction
                 * @memberof Ydb.Table.V1.TableService
                 * @instance
                 * @param {Ydb.Table.ICommitTransactionRequest} request CommitTransactionRequest message or plain object
                 * @param {Ydb.Table.V1.TableService.CommitTransactionCallback} callback Node-style callback called with the error, if any, and CommitTransactionResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(TableService.prototype.commitTransaction = function commitTransaction(request, callback) {
                    return this.rpcCall(commitTransaction, $root.Ydb.Table.CommitTransactionRequest, $root.Ydb.Table.CommitTransactionResponse, request, callback);
                }, "name", { value: "CommitTransaction" });

                /**
                 * Calls CommitTransaction.
                 * @function commitTransaction
                 * @memberof Ydb.Table.V1.TableService
                 * @instance
                 * @param {Ydb.Table.ICommitTransactionRequest} request CommitTransactionRequest message or plain object
                 * @returns {Promise<Ydb.Table.CommitTransactionResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link Ydb.Table.V1.TableService#rollbackTransaction}.
                 * @memberof Ydb.Table.V1.TableService
                 * @typedef RollbackTransactionCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {Ydb.Table.RollbackTransactionResponse} [response] RollbackTransactionResponse
                 */

                /**
                 * Calls RollbackTransaction.
                 * @function rollbackTransaction
                 * @memberof Ydb.Table.V1.TableService
                 * @instance
                 * @param {Ydb.Table.IRollbackTransactionRequest} request RollbackTransactionRequest message or plain object
                 * @param {Ydb.Table.V1.TableService.RollbackTransactionCallback} callback Node-style callback called with the error, if any, and RollbackTransactionResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(TableService.prototype.rollbackTransaction = function rollbackTransaction(request, callback) {
                    return this.rpcCall(rollbackTransaction, $root.Ydb.Table.RollbackTransactionRequest, $root.Ydb.Table.RollbackTransactionResponse, request, callback);
                }, "name", { value: "RollbackTransaction" });

                /**
                 * Calls RollbackTransaction.
                 * @function rollbackTransaction
                 * @memberof Ydb.Table.V1.TableService
                 * @instance
                 * @param {Ydb.Table.IRollbackTransactionRequest} request RollbackTransactionRequest message or plain object
                 * @returns {Promise<Ydb.Table.RollbackTransactionResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link Ydb.Table.V1.TableService#describeTableOptions}.
                 * @memberof Ydb.Table.V1.TableService
                 * @typedef DescribeTableOptionsCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {Ydb.Table.DescribeTableOptionsResponse} [response] DescribeTableOptionsResponse
                 */

                /**
                 * Calls DescribeTableOptions.
                 * @function describeTableOptions
                 * @memberof Ydb.Table.V1.TableService
                 * @instance
                 * @param {Ydb.Table.IDescribeTableOptionsRequest} request DescribeTableOptionsRequest message or plain object
                 * @param {Ydb.Table.V1.TableService.DescribeTableOptionsCallback} callback Node-style callback called with the error, if any, and DescribeTableOptionsResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(TableService.prototype.describeTableOptions = function describeTableOptions(request, callback) {
                    return this.rpcCall(describeTableOptions, $root.Ydb.Table.DescribeTableOptionsRequest, $root.Ydb.Table.DescribeTableOptionsResponse, request, callback);
                }, "name", { value: "DescribeTableOptions" });

                /**
                 * Calls DescribeTableOptions.
                 * @function describeTableOptions
                 * @memberof Ydb.Table.V1.TableService
                 * @instance
                 * @param {Ydb.Table.IDescribeTableOptionsRequest} request DescribeTableOptionsRequest message or plain object
                 * @returns {Promise<Ydb.Table.DescribeTableOptionsResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link Ydb.Table.V1.TableService#streamReadTable}.
                 * @memberof Ydb.Table.V1.TableService
                 * @typedef StreamReadTableCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {Ydb.Table.ReadTableResponse} [response] ReadTableResponse
                 */

                /**
                 * Calls StreamReadTable.
                 * @function streamReadTable
                 * @memberof Ydb.Table.V1.TableService
                 * @instance
                 * @param {Ydb.Table.IReadTableRequest} request ReadTableRequest message or plain object
                 * @param {Ydb.Table.V1.TableService.StreamReadTableCallback} callback Node-style callback called with the error, if any, and ReadTableResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(TableService.prototype.streamReadTable = function streamReadTable(request, callback) {
                    return this.rpcCall(streamReadTable, $root.Ydb.Table.ReadTableRequest, $root.Ydb.Table.ReadTableResponse, request, callback);
                }, "name", { value: "StreamReadTable" });

                /**
                 * Calls StreamReadTable.
                 * @function streamReadTable
                 * @memberof Ydb.Table.V1.TableService
                 * @instance
                 * @param {Ydb.Table.IReadTableRequest} request ReadTableRequest message or plain object
                 * @returns {Promise<Ydb.Table.ReadTableResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link Ydb.Table.V1.TableService#bulkUpsert}.
                 * @memberof Ydb.Table.V1.TableService
                 * @typedef BulkUpsertCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {Ydb.Table.BulkUpsertResponse} [response] BulkUpsertResponse
                 */

                /**
                 * Calls BulkUpsert.
                 * @function bulkUpsert
                 * @memberof Ydb.Table.V1.TableService
                 * @instance
                 * @param {Ydb.Table.IBulkUpsertRequest} request BulkUpsertRequest message or plain object
                 * @param {Ydb.Table.V1.TableService.BulkUpsertCallback} callback Node-style callback called with the error, if any, and BulkUpsertResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(TableService.prototype.bulkUpsert = function bulkUpsert(request, callback) {
                    return this.rpcCall(bulkUpsert, $root.Ydb.Table.BulkUpsertRequest, $root.Ydb.Table.BulkUpsertResponse, request, callback);
                }, "name", { value: "BulkUpsert" });

                /**
                 * Calls BulkUpsert.
                 * @function bulkUpsert
                 * @memberof Ydb.Table.V1.TableService
                 * @instance
                 * @param {Ydb.Table.IBulkUpsertRequest} request BulkUpsertRequest message or plain object
                 * @returns {Promise<Ydb.Table.BulkUpsertResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link Ydb.Table.V1.TableService#streamExecuteScanQuery}.
                 * @memberof Ydb.Table.V1.TableService
                 * @typedef StreamExecuteScanQueryCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {Ydb.Table.ExecuteScanQueryPartialResponse} [response] ExecuteScanQueryPartialResponse
                 */

                /**
                 * Calls StreamExecuteScanQuery.
                 * @function streamExecuteScanQuery
                 * @memberof Ydb.Table.V1.TableService
                 * @instance
                 * @param {Ydb.Table.IExecuteScanQueryRequest} request ExecuteScanQueryRequest message or plain object
                 * @param {Ydb.Table.V1.TableService.StreamExecuteScanQueryCallback} callback Node-style callback called with the error, if any, and ExecuteScanQueryPartialResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(TableService.prototype.streamExecuteScanQuery = function streamExecuteScanQuery(request, callback) {
                    return this.rpcCall(streamExecuteScanQuery, $root.Ydb.Table.ExecuteScanQueryRequest, $root.Ydb.Table.ExecuteScanQueryPartialResponse, request, callback);
                }, "name", { value: "StreamExecuteScanQuery" });

                /**
                 * Calls StreamExecuteScanQuery.
                 * @function streamExecuteScanQuery
                 * @memberof Ydb.Table.V1.TableService
                 * @instance
                 * @param {Ydb.Table.IExecuteScanQueryRequest} request ExecuteScanQueryRequest message or plain object
                 * @returns {Promise<Ydb.Table.ExecuteScanQueryPartialResponse>} Promise
                 * @variation 2
                 */

                return TableService;
            })();

            return V1;
        })();

        Table.CreateSessionRequest = (function() {

            /**
             * Properties of a CreateSessionRequest.
             * @memberof Ydb.Table
             * @interface ICreateSessionRequest
             * @property {Ydb.Operations.IOperationParams|null} [operationParams] CreateSessionRequest operationParams
             */

            /**
             * Constructs a new CreateSessionRequest.
             * @memberof Ydb.Table
             * @classdesc Represents a CreateSessionRequest.
             * @implements ICreateSessionRequest
             * @constructor
             * @param {Ydb.Table.ICreateSessionRequest=} [properties] Properties to set
             */
            function CreateSessionRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CreateSessionRequest operationParams.
             * @member {Ydb.Operations.IOperationParams|null|undefined} operationParams
             * @memberof Ydb.Table.CreateSessionRequest
             * @instance
             */
            CreateSessionRequest.prototype.operationParams = null;

            /**
             * Creates a new CreateSessionRequest instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.CreateSessionRequest
             * @static
             * @param {Ydb.Table.ICreateSessionRequest=} [properties] Properties to set
             * @returns {Ydb.Table.CreateSessionRequest} CreateSessionRequest instance
             */
            CreateSessionRequest.create = function create(properties) {
                return new CreateSessionRequest(properties);
            };

            /**
             * Encodes the specified CreateSessionRequest message. Does not implicitly {@link Ydb.Table.CreateSessionRequest.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.CreateSessionRequest
             * @static
             * @param {Ydb.Table.ICreateSessionRequest} message CreateSessionRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CreateSessionRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.operationParams != null && Object.hasOwnProperty.call(message, "operationParams"))
                    $root.Ydb.Operations.OperationParams.encode(message.operationParams, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified CreateSessionRequest message, length delimited. Does not implicitly {@link Ydb.Table.CreateSessionRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.CreateSessionRequest
             * @static
             * @param {Ydb.Table.ICreateSessionRequest} message CreateSessionRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CreateSessionRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CreateSessionRequest message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.CreateSessionRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.CreateSessionRequest} CreateSessionRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CreateSessionRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.CreateSessionRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.operationParams = $root.Ydb.Operations.OperationParams.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a CreateSessionRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.CreateSessionRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.CreateSessionRequest} CreateSessionRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CreateSessionRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CreateSessionRequest message.
             * @function verify
             * @memberof Ydb.Table.CreateSessionRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CreateSessionRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.operationParams != null && message.hasOwnProperty("operationParams")) {
                    var error = $root.Ydb.Operations.OperationParams.verify(message.operationParams);
                    if (error)
                        return "operationParams." + error;
                }
                return null;
            };

            /**
             * Creates a CreateSessionRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.CreateSessionRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.CreateSessionRequest} CreateSessionRequest
             */
            CreateSessionRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.CreateSessionRequest)
                    return object;
                var message = new $root.Ydb.Table.CreateSessionRequest();
                if (object.operationParams != null) {
                    if (typeof object.operationParams !== "object")
                        throw TypeError(".Ydb.Table.CreateSessionRequest.operationParams: object expected");
                    message.operationParams = $root.Ydb.Operations.OperationParams.fromObject(object.operationParams);
                }
                return message;
            };

            /**
             * Creates a plain object from a CreateSessionRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.CreateSessionRequest
             * @static
             * @param {Ydb.Table.CreateSessionRequest} message CreateSessionRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CreateSessionRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.operationParams = null;
                if (message.operationParams != null && message.hasOwnProperty("operationParams"))
                    object.operationParams = $root.Ydb.Operations.OperationParams.toObject(message.operationParams, options);
                return object;
            };

            /**
             * Converts this CreateSessionRequest to JSON.
             * @function toJSON
             * @memberof Ydb.Table.CreateSessionRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CreateSessionRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return CreateSessionRequest;
        })();

        Table.CreateSessionResponse = (function() {

            /**
             * Properties of a CreateSessionResponse.
             * @memberof Ydb.Table
             * @interface ICreateSessionResponse
             * @property {Ydb.Operations.IOperation|null} [operation] CreateSessionResponse operation
             */

            /**
             * Constructs a new CreateSessionResponse.
             * @memberof Ydb.Table
             * @classdesc Represents a CreateSessionResponse.
             * @implements ICreateSessionResponse
             * @constructor
             * @param {Ydb.Table.ICreateSessionResponse=} [properties] Properties to set
             */
            function CreateSessionResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CreateSessionResponse operation.
             * @member {Ydb.Operations.IOperation|null|undefined} operation
             * @memberof Ydb.Table.CreateSessionResponse
             * @instance
             */
            CreateSessionResponse.prototype.operation = null;

            /**
             * Creates a new CreateSessionResponse instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.CreateSessionResponse
             * @static
             * @param {Ydb.Table.ICreateSessionResponse=} [properties] Properties to set
             * @returns {Ydb.Table.CreateSessionResponse} CreateSessionResponse instance
             */
            CreateSessionResponse.create = function create(properties) {
                return new CreateSessionResponse(properties);
            };

            /**
             * Encodes the specified CreateSessionResponse message. Does not implicitly {@link Ydb.Table.CreateSessionResponse.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.CreateSessionResponse
             * @static
             * @param {Ydb.Table.ICreateSessionResponse} message CreateSessionResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CreateSessionResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.operation != null && Object.hasOwnProperty.call(message, "operation"))
                    $root.Ydb.Operations.Operation.encode(message.operation, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified CreateSessionResponse message, length delimited. Does not implicitly {@link Ydb.Table.CreateSessionResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.CreateSessionResponse
             * @static
             * @param {Ydb.Table.ICreateSessionResponse} message CreateSessionResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CreateSessionResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CreateSessionResponse message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.CreateSessionResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.CreateSessionResponse} CreateSessionResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CreateSessionResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.CreateSessionResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.operation = $root.Ydb.Operations.Operation.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a CreateSessionResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.CreateSessionResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.CreateSessionResponse} CreateSessionResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CreateSessionResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CreateSessionResponse message.
             * @function verify
             * @memberof Ydb.Table.CreateSessionResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CreateSessionResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.operation != null && message.hasOwnProperty("operation")) {
                    var error = $root.Ydb.Operations.Operation.verify(message.operation);
                    if (error)
                        return "operation." + error;
                }
                return null;
            };

            /**
             * Creates a CreateSessionResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.CreateSessionResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.CreateSessionResponse} CreateSessionResponse
             */
            CreateSessionResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.CreateSessionResponse)
                    return object;
                var message = new $root.Ydb.Table.CreateSessionResponse();
                if (object.operation != null) {
                    if (typeof object.operation !== "object")
                        throw TypeError(".Ydb.Table.CreateSessionResponse.operation: object expected");
                    message.operation = $root.Ydb.Operations.Operation.fromObject(object.operation);
                }
                return message;
            };

            /**
             * Creates a plain object from a CreateSessionResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.CreateSessionResponse
             * @static
             * @param {Ydb.Table.CreateSessionResponse} message CreateSessionResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CreateSessionResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.operation = null;
                if (message.operation != null && message.hasOwnProperty("operation"))
                    object.operation = $root.Ydb.Operations.Operation.toObject(message.operation, options);
                return object;
            };

            /**
             * Converts this CreateSessionResponse to JSON.
             * @function toJSON
             * @memberof Ydb.Table.CreateSessionResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CreateSessionResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return CreateSessionResponse;
        })();

        Table.CreateSessionResult = (function() {

            /**
             * Properties of a CreateSessionResult.
             * @memberof Ydb.Table
             * @interface ICreateSessionResult
             * @property {string|null} [sessionId] CreateSessionResult sessionId
             */

            /**
             * Constructs a new CreateSessionResult.
             * @memberof Ydb.Table
             * @classdesc Represents a CreateSessionResult.
             * @implements ICreateSessionResult
             * @constructor
             * @param {Ydb.Table.ICreateSessionResult=} [properties] Properties to set
             */
            function CreateSessionResult(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CreateSessionResult sessionId.
             * @member {string} sessionId
             * @memberof Ydb.Table.CreateSessionResult
             * @instance
             */
            CreateSessionResult.prototype.sessionId = "";

            /**
             * Creates a new CreateSessionResult instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.CreateSessionResult
             * @static
             * @param {Ydb.Table.ICreateSessionResult=} [properties] Properties to set
             * @returns {Ydb.Table.CreateSessionResult} CreateSessionResult instance
             */
            CreateSessionResult.create = function create(properties) {
                return new CreateSessionResult(properties);
            };

            /**
             * Encodes the specified CreateSessionResult message. Does not implicitly {@link Ydb.Table.CreateSessionResult.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.CreateSessionResult
             * @static
             * @param {Ydb.Table.ICreateSessionResult} message CreateSessionResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CreateSessionResult.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.sessionId != null && Object.hasOwnProperty.call(message, "sessionId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.sessionId);
                return writer;
            };

            /**
             * Encodes the specified CreateSessionResult message, length delimited. Does not implicitly {@link Ydb.Table.CreateSessionResult.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.CreateSessionResult
             * @static
             * @param {Ydb.Table.ICreateSessionResult} message CreateSessionResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CreateSessionResult.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CreateSessionResult message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.CreateSessionResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.CreateSessionResult} CreateSessionResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CreateSessionResult.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.CreateSessionResult();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.sessionId = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a CreateSessionResult message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.CreateSessionResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.CreateSessionResult} CreateSessionResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CreateSessionResult.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CreateSessionResult message.
             * @function verify
             * @memberof Ydb.Table.CreateSessionResult
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CreateSessionResult.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.sessionId != null && message.hasOwnProperty("sessionId"))
                    if (!$util.isString(message.sessionId))
                        return "sessionId: string expected";
                return null;
            };

            /**
             * Creates a CreateSessionResult message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.CreateSessionResult
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.CreateSessionResult} CreateSessionResult
             */
            CreateSessionResult.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.CreateSessionResult)
                    return object;
                var message = new $root.Ydb.Table.CreateSessionResult();
                if (object.sessionId != null)
                    message.sessionId = String(object.sessionId);
                return message;
            };

            /**
             * Creates a plain object from a CreateSessionResult message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.CreateSessionResult
             * @static
             * @param {Ydb.Table.CreateSessionResult} message CreateSessionResult
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CreateSessionResult.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.sessionId = "";
                if (message.sessionId != null && message.hasOwnProperty("sessionId"))
                    object.sessionId = message.sessionId;
                return object;
            };

            /**
             * Converts this CreateSessionResult to JSON.
             * @function toJSON
             * @memberof Ydb.Table.CreateSessionResult
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CreateSessionResult.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return CreateSessionResult;
        })();

        Table.DeleteSessionRequest = (function() {

            /**
             * Properties of a DeleteSessionRequest.
             * @memberof Ydb.Table
             * @interface IDeleteSessionRequest
             * @property {string|null} [sessionId] DeleteSessionRequest sessionId
             * @property {Ydb.Operations.IOperationParams|null} [operationParams] DeleteSessionRequest operationParams
             */

            /**
             * Constructs a new DeleteSessionRequest.
             * @memberof Ydb.Table
             * @classdesc Represents a DeleteSessionRequest.
             * @implements IDeleteSessionRequest
             * @constructor
             * @param {Ydb.Table.IDeleteSessionRequest=} [properties] Properties to set
             */
            function DeleteSessionRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DeleteSessionRequest sessionId.
             * @member {string} sessionId
             * @memberof Ydb.Table.DeleteSessionRequest
             * @instance
             */
            DeleteSessionRequest.prototype.sessionId = "";

            /**
             * DeleteSessionRequest operationParams.
             * @member {Ydb.Operations.IOperationParams|null|undefined} operationParams
             * @memberof Ydb.Table.DeleteSessionRequest
             * @instance
             */
            DeleteSessionRequest.prototype.operationParams = null;

            /**
             * Creates a new DeleteSessionRequest instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.DeleteSessionRequest
             * @static
             * @param {Ydb.Table.IDeleteSessionRequest=} [properties] Properties to set
             * @returns {Ydb.Table.DeleteSessionRequest} DeleteSessionRequest instance
             */
            DeleteSessionRequest.create = function create(properties) {
                return new DeleteSessionRequest(properties);
            };

            /**
             * Encodes the specified DeleteSessionRequest message. Does not implicitly {@link Ydb.Table.DeleteSessionRequest.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.DeleteSessionRequest
             * @static
             * @param {Ydb.Table.IDeleteSessionRequest} message DeleteSessionRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeleteSessionRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.sessionId != null && Object.hasOwnProperty.call(message, "sessionId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.sessionId);
                if (message.operationParams != null && Object.hasOwnProperty.call(message, "operationParams"))
                    $root.Ydb.Operations.OperationParams.encode(message.operationParams, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified DeleteSessionRequest message, length delimited. Does not implicitly {@link Ydb.Table.DeleteSessionRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.DeleteSessionRequest
             * @static
             * @param {Ydb.Table.IDeleteSessionRequest} message DeleteSessionRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeleteSessionRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DeleteSessionRequest message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.DeleteSessionRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.DeleteSessionRequest} DeleteSessionRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeleteSessionRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.DeleteSessionRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.sessionId = reader.string();
                        break;
                    case 2:
                        message.operationParams = $root.Ydb.Operations.OperationParams.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DeleteSessionRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.DeleteSessionRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.DeleteSessionRequest} DeleteSessionRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeleteSessionRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DeleteSessionRequest message.
             * @function verify
             * @memberof Ydb.Table.DeleteSessionRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DeleteSessionRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.sessionId != null && message.hasOwnProperty("sessionId"))
                    if (!$util.isString(message.sessionId))
                        return "sessionId: string expected";
                if (message.operationParams != null && message.hasOwnProperty("operationParams")) {
                    var error = $root.Ydb.Operations.OperationParams.verify(message.operationParams);
                    if (error)
                        return "operationParams." + error;
                }
                return null;
            };

            /**
             * Creates a DeleteSessionRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.DeleteSessionRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.DeleteSessionRequest} DeleteSessionRequest
             */
            DeleteSessionRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.DeleteSessionRequest)
                    return object;
                var message = new $root.Ydb.Table.DeleteSessionRequest();
                if (object.sessionId != null)
                    message.sessionId = String(object.sessionId);
                if (object.operationParams != null) {
                    if (typeof object.operationParams !== "object")
                        throw TypeError(".Ydb.Table.DeleteSessionRequest.operationParams: object expected");
                    message.operationParams = $root.Ydb.Operations.OperationParams.fromObject(object.operationParams);
                }
                return message;
            };

            /**
             * Creates a plain object from a DeleteSessionRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.DeleteSessionRequest
             * @static
             * @param {Ydb.Table.DeleteSessionRequest} message DeleteSessionRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DeleteSessionRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.sessionId = "";
                    object.operationParams = null;
                }
                if (message.sessionId != null && message.hasOwnProperty("sessionId"))
                    object.sessionId = message.sessionId;
                if (message.operationParams != null && message.hasOwnProperty("operationParams"))
                    object.operationParams = $root.Ydb.Operations.OperationParams.toObject(message.operationParams, options);
                return object;
            };

            /**
             * Converts this DeleteSessionRequest to JSON.
             * @function toJSON
             * @memberof Ydb.Table.DeleteSessionRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DeleteSessionRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DeleteSessionRequest;
        })();

        Table.DeleteSessionResponse = (function() {

            /**
             * Properties of a DeleteSessionResponse.
             * @memberof Ydb.Table
             * @interface IDeleteSessionResponse
             * @property {Ydb.Operations.IOperation|null} [operation] DeleteSessionResponse operation
             */

            /**
             * Constructs a new DeleteSessionResponse.
             * @memberof Ydb.Table
             * @classdesc Represents a DeleteSessionResponse.
             * @implements IDeleteSessionResponse
             * @constructor
             * @param {Ydb.Table.IDeleteSessionResponse=} [properties] Properties to set
             */
            function DeleteSessionResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DeleteSessionResponse operation.
             * @member {Ydb.Operations.IOperation|null|undefined} operation
             * @memberof Ydb.Table.DeleteSessionResponse
             * @instance
             */
            DeleteSessionResponse.prototype.operation = null;

            /**
             * Creates a new DeleteSessionResponse instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.DeleteSessionResponse
             * @static
             * @param {Ydb.Table.IDeleteSessionResponse=} [properties] Properties to set
             * @returns {Ydb.Table.DeleteSessionResponse} DeleteSessionResponse instance
             */
            DeleteSessionResponse.create = function create(properties) {
                return new DeleteSessionResponse(properties);
            };

            /**
             * Encodes the specified DeleteSessionResponse message. Does not implicitly {@link Ydb.Table.DeleteSessionResponse.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.DeleteSessionResponse
             * @static
             * @param {Ydb.Table.IDeleteSessionResponse} message DeleteSessionResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeleteSessionResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.operation != null && Object.hasOwnProperty.call(message, "operation"))
                    $root.Ydb.Operations.Operation.encode(message.operation, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified DeleteSessionResponse message, length delimited. Does not implicitly {@link Ydb.Table.DeleteSessionResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.DeleteSessionResponse
             * @static
             * @param {Ydb.Table.IDeleteSessionResponse} message DeleteSessionResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeleteSessionResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DeleteSessionResponse message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.DeleteSessionResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.DeleteSessionResponse} DeleteSessionResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeleteSessionResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.DeleteSessionResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.operation = $root.Ydb.Operations.Operation.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DeleteSessionResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.DeleteSessionResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.DeleteSessionResponse} DeleteSessionResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeleteSessionResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DeleteSessionResponse message.
             * @function verify
             * @memberof Ydb.Table.DeleteSessionResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DeleteSessionResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.operation != null && message.hasOwnProperty("operation")) {
                    var error = $root.Ydb.Operations.Operation.verify(message.operation);
                    if (error)
                        return "operation." + error;
                }
                return null;
            };

            /**
             * Creates a DeleteSessionResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.DeleteSessionResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.DeleteSessionResponse} DeleteSessionResponse
             */
            DeleteSessionResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.DeleteSessionResponse)
                    return object;
                var message = new $root.Ydb.Table.DeleteSessionResponse();
                if (object.operation != null) {
                    if (typeof object.operation !== "object")
                        throw TypeError(".Ydb.Table.DeleteSessionResponse.operation: object expected");
                    message.operation = $root.Ydb.Operations.Operation.fromObject(object.operation);
                }
                return message;
            };

            /**
             * Creates a plain object from a DeleteSessionResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.DeleteSessionResponse
             * @static
             * @param {Ydb.Table.DeleteSessionResponse} message DeleteSessionResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DeleteSessionResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.operation = null;
                if (message.operation != null && message.hasOwnProperty("operation"))
                    object.operation = $root.Ydb.Operations.Operation.toObject(message.operation, options);
                return object;
            };

            /**
             * Converts this DeleteSessionResponse to JSON.
             * @function toJSON
             * @memberof Ydb.Table.DeleteSessionResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DeleteSessionResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DeleteSessionResponse;
        })();

        Table.GlobalIndex = (function() {

            /**
             * Properties of a GlobalIndex.
             * @memberof Ydb.Table
             * @interface IGlobalIndex
             */

            /**
             * Constructs a new GlobalIndex.
             * @memberof Ydb.Table
             * @classdesc Represents a GlobalIndex.
             * @implements IGlobalIndex
             * @constructor
             * @param {Ydb.Table.IGlobalIndex=} [properties] Properties to set
             */
            function GlobalIndex(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new GlobalIndex instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.GlobalIndex
             * @static
             * @param {Ydb.Table.IGlobalIndex=} [properties] Properties to set
             * @returns {Ydb.Table.GlobalIndex} GlobalIndex instance
             */
            GlobalIndex.create = function create(properties) {
                return new GlobalIndex(properties);
            };

            /**
             * Encodes the specified GlobalIndex message. Does not implicitly {@link Ydb.Table.GlobalIndex.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.GlobalIndex
             * @static
             * @param {Ydb.Table.IGlobalIndex} message GlobalIndex message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GlobalIndex.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified GlobalIndex message, length delimited. Does not implicitly {@link Ydb.Table.GlobalIndex.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.GlobalIndex
             * @static
             * @param {Ydb.Table.IGlobalIndex} message GlobalIndex message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GlobalIndex.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GlobalIndex message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.GlobalIndex
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.GlobalIndex} GlobalIndex
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GlobalIndex.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.GlobalIndex();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GlobalIndex message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.GlobalIndex
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.GlobalIndex} GlobalIndex
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GlobalIndex.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GlobalIndex message.
             * @function verify
             * @memberof Ydb.Table.GlobalIndex
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GlobalIndex.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a GlobalIndex message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.GlobalIndex
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.GlobalIndex} GlobalIndex
             */
            GlobalIndex.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.GlobalIndex)
                    return object;
                return new $root.Ydb.Table.GlobalIndex();
            };

            /**
             * Creates a plain object from a GlobalIndex message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.GlobalIndex
             * @static
             * @param {Ydb.Table.GlobalIndex} message GlobalIndex
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GlobalIndex.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this GlobalIndex to JSON.
             * @function toJSON
             * @memberof Ydb.Table.GlobalIndex
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GlobalIndex.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return GlobalIndex;
        })();

        Table.GlobalAsyncIndex = (function() {

            /**
             * Properties of a GlobalAsyncIndex.
             * @memberof Ydb.Table
             * @interface IGlobalAsyncIndex
             */

            /**
             * Constructs a new GlobalAsyncIndex.
             * @memberof Ydb.Table
             * @classdesc Represents a GlobalAsyncIndex.
             * @implements IGlobalAsyncIndex
             * @constructor
             * @param {Ydb.Table.IGlobalAsyncIndex=} [properties] Properties to set
             */
            function GlobalAsyncIndex(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new GlobalAsyncIndex instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.GlobalAsyncIndex
             * @static
             * @param {Ydb.Table.IGlobalAsyncIndex=} [properties] Properties to set
             * @returns {Ydb.Table.GlobalAsyncIndex} GlobalAsyncIndex instance
             */
            GlobalAsyncIndex.create = function create(properties) {
                return new GlobalAsyncIndex(properties);
            };

            /**
             * Encodes the specified GlobalAsyncIndex message. Does not implicitly {@link Ydb.Table.GlobalAsyncIndex.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.GlobalAsyncIndex
             * @static
             * @param {Ydb.Table.IGlobalAsyncIndex} message GlobalAsyncIndex message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GlobalAsyncIndex.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified GlobalAsyncIndex message, length delimited. Does not implicitly {@link Ydb.Table.GlobalAsyncIndex.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.GlobalAsyncIndex
             * @static
             * @param {Ydb.Table.IGlobalAsyncIndex} message GlobalAsyncIndex message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GlobalAsyncIndex.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GlobalAsyncIndex message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.GlobalAsyncIndex
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.GlobalAsyncIndex} GlobalAsyncIndex
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GlobalAsyncIndex.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.GlobalAsyncIndex();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GlobalAsyncIndex message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.GlobalAsyncIndex
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.GlobalAsyncIndex} GlobalAsyncIndex
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GlobalAsyncIndex.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GlobalAsyncIndex message.
             * @function verify
             * @memberof Ydb.Table.GlobalAsyncIndex
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GlobalAsyncIndex.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a GlobalAsyncIndex message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.GlobalAsyncIndex
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.GlobalAsyncIndex} GlobalAsyncIndex
             */
            GlobalAsyncIndex.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.GlobalAsyncIndex)
                    return object;
                return new $root.Ydb.Table.GlobalAsyncIndex();
            };

            /**
             * Creates a plain object from a GlobalAsyncIndex message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.GlobalAsyncIndex
             * @static
             * @param {Ydb.Table.GlobalAsyncIndex} message GlobalAsyncIndex
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GlobalAsyncIndex.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this GlobalAsyncIndex to JSON.
             * @function toJSON
             * @memberof Ydb.Table.GlobalAsyncIndex
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GlobalAsyncIndex.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return GlobalAsyncIndex;
        })();

        Table.TableIndex = (function() {

            /**
             * Properties of a TableIndex.
             * @memberof Ydb.Table
             * @interface ITableIndex
             * @property {string|null} [name] TableIndex name
             * @property {Array.<string>|null} [indexColumns] TableIndex indexColumns
             * @property {Ydb.Table.IGlobalIndex|null} [globalIndex] TableIndex globalIndex
             * @property {Ydb.Table.IGlobalAsyncIndex|null} [globalAsyncIndex] TableIndex globalAsyncIndex
             * @property {Array.<string>|null} [dataColumns] TableIndex dataColumns
             */

            /**
             * Constructs a new TableIndex.
             * @memberof Ydb.Table
             * @classdesc Represents a TableIndex.
             * @implements ITableIndex
             * @constructor
             * @param {Ydb.Table.ITableIndex=} [properties] Properties to set
             */
            function TableIndex(properties) {
                this.indexColumns = [];
                this.dataColumns = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * TableIndex name.
             * @member {string} name
             * @memberof Ydb.Table.TableIndex
             * @instance
             */
            TableIndex.prototype.name = "";

            /**
             * TableIndex indexColumns.
             * @member {Array.<string>} indexColumns
             * @memberof Ydb.Table.TableIndex
             * @instance
             */
            TableIndex.prototype.indexColumns = $util.emptyArray;

            /**
             * TableIndex globalIndex.
             * @member {Ydb.Table.IGlobalIndex|null|undefined} globalIndex
             * @memberof Ydb.Table.TableIndex
             * @instance
             */
            TableIndex.prototype.globalIndex = null;

            /**
             * TableIndex globalAsyncIndex.
             * @member {Ydb.Table.IGlobalAsyncIndex|null|undefined} globalAsyncIndex
             * @memberof Ydb.Table.TableIndex
             * @instance
             */
            TableIndex.prototype.globalAsyncIndex = null;

            /**
             * TableIndex dataColumns.
             * @member {Array.<string>} dataColumns
             * @memberof Ydb.Table.TableIndex
             * @instance
             */
            TableIndex.prototype.dataColumns = $util.emptyArray;

            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;

            /**
             * TableIndex type.
             * @member {"globalIndex"|"globalAsyncIndex"|undefined} type
             * @memberof Ydb.Table.TableIndex
             * @instance
             */
            Object.defineProperty(TableIndex.prototype, "type", {
                get: $util.oneOfGetter($oneOfFields = ["globalIndex", "globalAsyncIndex"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new TableIndex instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.TableIndex
             * @static
             * @param {Ydb.Table.ITableIndex=} [properties] Properties to set
             * @returns {Ydb.Table.TableIndex} TableIndex instance
             */
            TableIndex.create = function create(properties) {
                return new TableIndex(properties);
            };

            /**
             * Encodes the specified TableIndex message. Does not implicitly {@link Ydb.Table.TableIndex.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.TableIndex
             * @static
             * @param {Ydb.Table.ITableIndex} message TableIndex message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TableIndex.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.indexColumns != null && message.indexColumns.length)
                    for (var i = 0; i < message.indexColumns.length; ++i)
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.indexColumns[i]);
                if (message.globalIndex != null && Object.hasOwnProperty.call(message, "globalIndex"))
                    $root.Ydb.Table.GlobalIndex.encode(message.globalIndex, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.globalAsyncIndex != null && Object.hasOwnProperty.call(message, "globalAsyncIndex"))
                    $root.Ydb.Table.GlobalAsyncIndex.encode(message.globalAsyncIndex, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.dataColumns != null && message.dataColumns.length)
                    for (var i = 0; i < message.dataColumns.length; ++i)
                        writer.uint32(/* id 5, wireType 2 =*/42).string(message.dataColumns[i]);
                return writer;
            };

            /**
             * Encodes the specified TableIndex message, length delimited. Does not implicitly {@link Ydb.Table.TableIndex.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.TableIndex
             * @static
             * @param {Ydb.Table.ITableIndex} message TableIndex message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TableIndex.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a TableIndex message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.TableIndex
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.TableIndex} TableIndex
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TableIndex.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.TableIndex();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        if (!(message.indexColumns && message.indexColumns.length))
                            message.indexColumns = [];
                        message.indexColumns.push(reader.string());
                        break;
                    case 3:
                        message.globalIndex = $root.Ydb.Table.GlobalIndex.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.globalAsyncIndex = $root.Ydb.Table.GlobalAsyncIndex.decode(reader, reader.uint32());
                        break;
                    case 5:
                        if (!(message.dataColumns && message.dataColumns.length))
                            message.dataColumns = [];
                        message.dataColumns.push(reader.string());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a TableIndex message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.TableIndex
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.TableIndex} TableIndex
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TableIndex.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a TableIndex message.
             * @function verify
             * @memberof Ydb.Table.TableIndex
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TableIndex.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.indexColumns != null && message.hasOwnProperty("indexColumns")) {
                    if (!Array.isArray(message.indexColumns))
                        return "indexColumns: array expected";
                    for (var i = 0; i < message.indexColumns.length; ++i)
                        if (!$util.isString(message.indexColumns[i]))
                            return "indexColumns: string[] expected";
                }
                if (message.globalIndex != null && message.hasOwnProperty("globalIndex")) {
                    properties.type = 1;
                    {
                        var error = $root.Ydb.Table.GlobalIndex.verify(message.globalIndex);
                        if (error)
                            return "globalIndex." + error;
                    }
                }
                if (message.globalAsyncIndex != null && message.hasOwnProperty("globalAsyncIndex")) {
                    if (properties.type === 1)
                        return "type: multiple values";
                    properties.type = 1;
                    {
                        var error = $root.Ydb.Table.GlobalAsyncIndex.verify(message.globalAsyncIndex);
                        if (error)
                            return "globalAsyncIndex." + error;
                    }
                }
                if (message.dataColumns != null && message.hasOwnProperty("dataColumns")) {
                    if (!Array.isArray(message.dataColumns))
                        return "dataColumns: array expected";
                    for (var i = 0; i < message.dataColumns.length; ++i)
                        if (!$util.isString(message.dataColumns[i]))
                            return "dataColumns: string[] expected";
                }
                return null;
            };

            /**
             * Creates a TableIndex message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.TableIndex
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.TableIndex} TableIndex
             */
            TableIndex.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.TableIndex)
                    return object;
                var message = new $root.Ydb.Table.TableIndex();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.indexColumns) {
                    if (!Array.isArray(object.indexColumns))
                        throw TypeError(".Ydb.Table.TableIndex.indexColumns: array expected");
                    message.indexColumns = [];
                    for (var i = 0; i < object.indexColumns.length; ++i)
                        message.indexColumns[i] = String(object.indexColumns[i]);
                }
                if (object.globalIndex != null) {
                    if (typeof object.globalIndex !== "object")
                        throw TypeError(".Ydb.Table.TableIndex.globalIndex: object expected");
                    message.globalIndex = $root.Ydb.Table.GlobalIndex.fromObject(object.globalIndex);
                }
                if (object.globalAsyncIndex != null) {
                    if (typeof object.globalAsyncIndex !== "object")
                        throw TypeError(".Ydb.Table.TableIndex.globalAsyncIndex: object expected");
                    message.globalAsyncIndex = $root.Ydb.Table.GlobalAsyncIndex.fromObject(object.globalAsyncIndex);
                }
                if (object.dataColumns) {
                    if (!Array.isArray(object.dataColumns))
                        throw TypeError(".Ydb.Table.TableIndex.dataColumns: array expected");
                    message.dataColumns = [];
                    for (var i = 0; i < object.dataColumns.length; ++i)
                        message.dataColumns[i] = String(object.dataColumns[i]);
                }
                return message;
            };

            /**
             * Creates a plain object from a TableIndex message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.TableIndex
             * @static
             * @param {Ydb.Table.TableIndex} message TableIndex
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            TableIndex.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.indexColumns = [];
                    object.dataColumns = [];
                }
                if (options.defaults)
                    object.name = "";
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.indexColumns && message.indexColumns.length) {
                    object.indexColumns = [];
                    for (var j = 0; j < message.indexColumns.length; ++j)
                        object.indexColumns[j] = message.indexColumns[j];
                }
                if (message.globalIndex != null && message.hasOwnProperty("globalIndex")) {
                    object.globalIndex = $root.Ydb.Table.GlobalIndex.toObject(message.globalIndex, options);
                    if (options.oneofs)
                        object.type = "globalIndex";
                }
                if (message.globalAsyncIndex != null && message.hasOwnProperty("globalAsyncIndex")) {
                    object.globalAsyncIndex = $root.Ydb.Table.GlobalAsyncIndex.toObject(message.globalAsyncIndex, options);
                    if (options.oneofs)
                        object.type = "globalAsyncIndex";
                }
                if (message.dataColumns && message.dataColumns.length) {
                    object.dataColumns = [];
                    for (var j = 0; j < message.dataColumns.length; ++j)
                        object.dataColumns[j] = message.dataColumns[j];
                }
                return object;
            };

            /**
             * Converts this TableIndex to JSON.
             * @function toJSON
             * @memberof Ydb.Table.TableIndex
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            TableIndex.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return TableIndex;
        })();

        Table.TableIndexDescription = (function() {

            /**
             * Properties of a TableIndexDescription.
             * @memberof Ydb.Table
             * @interface ITableIndexDescription
             * @property {string|null} [name] TableIndexDescription name
             * @property {Array.<string>|null} [indexColumns] TableIndexDescription indexColumns
             * @property {Ydb.Table.IGlobalIndex|null} [globalIndex] TableIndexDescription globalIndex
             * @property {Ydb.Table.IGlobalAsyncIndex|null} [globalAsyncIndex] TableIndexDescription globalAsyncIndex
             * @property {Ydb.Table.TableIndexDescription.Status|null} [status] TableIndexDescription status
             * @property {Array.<string>|null} [dataColumns] TableIndexDescription dataColumns
             */

            /**
             * Constructs a new TableIndexDescription.
             * @memberof Ydb.Table
             * @classdesc Represents a TableIndexDescription.
             * @implements ITableIndexDescription
             * @constructor
             * @param {Ydb.Table.ITableIndexDescription=} [properties] Properties to set
             */
            function TableIndexDescription(properties) {
                this.indexColumns = [];
                this.dataColumns = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * TableIndexDescription name.
             * @member {string} name
             * @memberof Ydb.Table.TableIndexDescription
             * @instance
             */
            TableIndexDescription.prototype.name = "";

            /**
             * TableIndexDescription indexColumns.
             * @member {Array.<string>} indexColumns
             * @memberof Ydb.Table.TableIndexDescription
             * @instance
             */
            TableIndexDescription.prototype.indexColumns = $util.emptyArray;

            /**
             * TableIndexDescription globalIndex.
             * @member {Ydb.Table.IGlobalIndex|null|undefined} globalIndex
             * @memberof Ydb.Table.TableIndexDescription
             * @instance
             */
            TableIndexDescription.prototype.globalIndex = null;

            /**
             * TableIndexDescription globalAsyncIndex.
             * @member {Ydb.Table.IGlobalAsyncIndex|null|undefined} globalAsyncIndex
             * @memberof Ydb.Table.TableIndexDescription
             * @instance
             */
            TableIndexDescription.prototype.globalAsyncIndex = null;

            /**
             * TableIndexDescription status.
             * @member {Ydb.Table.TableIndexDescription.Status} status
             * @memberof Ydb.Table.TableIndexDescription
             * @instance
             */
            TableIndexDescription.prototype.status = 0;

            /**
             * TableIndexDescription dataColumns.
             * @member {Array.<string>} dataColumns
             * @memberof Ydb.Table.TableIndexDescription
             * @instance
             */
            TableIndexDescription.prototype.dataColumns = $util.emptyArray;

            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;

            /**
             * TableIndexDescription type.
             * @member {"globalIndex"|"globalAsyncIndex"|undefined} type
             * @memberof Ydb.Table.TableIndexDescription
             * @instance
             */
            Object.defineProperty(TableIndexDescription.prototype, "type", {
                get: $util.oneOfGetter($oneOfFields = ["globalIndex", "globalAsyncIndex"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new TableIndexDescription instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.TableIndexDescription
             * @static
             * @param {Ydb.Table.ITableIndexDescription=} [properties] Properties to set
             * @returns {Ydb.Table.TableIndexDescription} TableIndexDescription instance
             */
            TableIndexDescription.create = function create(properties) {
                return new TableIndexDescription(properties);
            };

            /**
             * Encodes the specified TableIndexDescription message. Does not implicitly {@link Ydb.Table.TableIndexDescription.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.TableIndexDescription
             * @static
             * @param {Ydb.Table.ITableIndexDescription} message TableIndexDescription message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TableIndexDescription.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.indexColumns != null && message.indexColumns.length)
                    for (var i = 0; i < message.indexColumns.length; ++i)
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.indexColumns[i]);
                if (message.globalIndex != null && Object.hasOwnProperty.call(message, "globalIndex"))
                    $root.Ydb.Table.GlobalIndex.encode(message.globalIndex, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.status);
                if (message.globalAsyncIndex != null && Object.hasOwnProperty.call(message, "globalAsyncIndex"))
                    $root.Ydb.Table.GlobalAsyncIndex.encode(message.globalAsyncIndex, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.dataColumns != null && message.dataColumns.length)
                    for (var i = 0; i < message.dataColumns.length; ++i)
                        writer.uint32(/* id 6, wireType 2 =*/50).string(message.dataColumns[i]);
                return writer;
            };

            /**
             * Encodes the specified TableIndexDescription message, length delimited. Does not implicitly {@link Ydb.Table.TableIndexDescription.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.TableIndexDescription
             * @static
             * @param {Ydb.Table.ITableIndexDescription} message TableIndexDescription message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TableIndexDescription.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a TableIndexDescription message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.TableIndexDescription
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.TableIndexDescription} TableIndexDescription
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TableIndexDescription.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.TableIndexDescription();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        if (!(message.indexColumns && message.indexColumns.length))
                            message.indexColumns = [];
                        message.indexColumns.push(reader.string());
                        break;
                    case 3:
                        message.globalIndex = $root.Ydb.Table.GlobalIndex.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.globalAsyncIndex = $root.Ydb.Table.GlobalAsyncIndex.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.status = reader.int32();
                        break;
                    case 6:
                        if (!(message.dataColumns && message.dataColumns.length))
                            message.dataColumns = [];
                        message.dataColumns.push(reader.string());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a TableIndexDescription message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.TableIndexDescription
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.TableIndexDescription} TableIndexDescription
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TableIndexDescription.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a TableIndexDescription message.
             * @function verify
             * @memberof Ydb.Table.TableIndexDescription
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TableIndexDescription.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.indexColumns != null && message.hasOwnProperty("indexColumns")) {
                    if (!Array.isArray(message.indexColumns))
                        return "indexColumns: array expected";
                    for (var i = 0; i < message.indexColumns.length; ++i)
                        if (!$util.isString(message.indexColumns[i]))
                            return "indexColumns: string[] expected";
                }
                if (message.globalIndex != null && message.hasOwnProperty("globalIndex")) {
                    properties.type = 1;
                    {
                        var error = $root.Ydb.Table.GlobalIndex.verify(message.globalIndex);
                        if (error)
                            return "globalIndex." + error;
                    }
                }
                if (message.globalAsyncIndex != null && message.hasOwnProperty("globalAsyncIndex")) {
                    if (properties.type === 1)
                        return "type: multiple values";
                    properties.type = 1;
                    {
                        var error = $root.Ydb.Table.GlobalAsyncIndex.verify(message.globalAsyncIndex);
                        if (error)
                            return "globalAsyncIndex." + error;
                    }
                }
                if (message.status != null && message.hasOwnProperty("status"))
                    switch (message.status) {
                    default:
                        return "status: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                if (message.dataColumns != null && message.hasOwnProperty("dataColumns")) {
                    if (!Array.isArray(message.dataColumns))
                        return "dataColumns: array expected";
                    for (var i = 0; i < message.dataColumns.length; ++i)
                        if (!$util.isString(message.dataColumns[i]))
                            return "dataColumns: string[] expected";
                }
                return null;
            };

            /**
             * Creates a TableIndexDescription message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.TableIndexDescription
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.TableIndexDescription} TableIndexDescription
             */
            TableIndexDescription.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.TableIndexDescription)
                    return object;
                var message = new $root.Ydb.Table.TableIndexDescription();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.indexColumns) {
                    if (!Array.isArray(object.indexColumns))
                        throw TypeError(".Ydb.Table.TableIndexDescription.indexColumns: array expected");
                    message.indexColumns = [];
                    for (var i = 0; i < object.indexColumns.length; ++i)
                        message.indexColumns[i] = String(object.indexColumns[i]);
                }
                if (object.globalIndex != null) {
                    if (typeof object.globalIndex !== "object")
                        throw TypeError(".Ydb.Table.TableIndexDescription.globalIndex: object expected");
                    message.globalIndex = $root.Ydb.Table.GlobalIndex.fromObject(object.globalIndex);
                }
                if (object.globalAsyncIndex != null) {
                    if (typeof object.globalAsyncIndex !== "object")
                        throw TypeError(".Ydb.Table.TableIndexDescription.globalAsyncIndex: object expected");
                    message.globalAsyncIndex = $root.Ydb.Table.GlobalAsyncIndex.fromObject(object.globalAsyncIndex);
                }
                switch (object.status) {
                case "STATUS_UNSPECIFIED":
                case 0:
                    message.status = 0;
                    break;
                case "STATUS_READY":
                case 1:
                    message.status = 1;
                    break;
                case "STATUS_BUILDING":
                case 2:
                    message.status = 2;
                    break;
                }
                if (object.dataColumns) {
                    if (!Array.isArray(object.dataColumns))
                        throw TypeError(".Ydb.Table.TableIndexDescription.dataColumns: array expected");
                    message.dataColumns = [];
                    for (var i = 0; i < object.dataColumns.length; ++i)
                        message.dataColumns[i] = String(object.dataColumns[i]);
                }
                return message;
            };

            /**
             * Creates a plain object from a TableIndexDescription message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.TableIndexDescription
             * @static
             * @param {Ydb.Table.TableIndexDescription} message TableIndexDescription
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            TableIndexDescription.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.indexColumns = [];
                    object.dataColumns = [];
                }
                if (options.defaults) {
                    object.name = "";
                    object.status = options.enums === String ? "STATUS_UNSPECIFIED" : 0;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.indexColumns && message.indexColumns.length) {
                    object.indexColumns = [];
                    for (var j = 0; j < message.indexColumns.length; ++j)
                        object.indexColumns[j] = message.indexColumns[j];
                }
                if (message.globalIndex != null && message.hasOwnProperty("globalIndex")) {
                    object.globalIndex = $root.Ydb.Table.GlobalIndex.toObject(message.globalIndex, options);
                    if (options.oneofs)
                        object.type = "globalIndex";
                }
                if (message.status != null && message.hasOwnProperty("status"))
                    object.status = options.enums === String ? $root.Ydb.Table.TableIndexDescription.Status[message.status] : message.status;
                if (message.globalAsyncIndex != null && message.hasOwnProperty("globalAsyncIndex")) {
                    object.globalAsyncIndex = $root.Ydb.Table.GlobalAsyncIndex.toObject(message.globalAsyncIndex, options);
                    if (options.oneofs)
                        object.type = "globalAsyncIndex";
                }
                if (message.dataColumns && message.dataColumns.length) {
                    object.dataColumns = [];
                    for (var j = 0; j < message.dataColumns.length; ++j)
                        object.dataColumns[j] = message.dataColumns[j];
                }
                return object;
            };

            /**
             * Converts this TableIndexDescription to JSON.
             * @function toJSON
             * @memberof Ydb.Table.TableIndexDescription
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            TableIndexDescription.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Status enum.
             * @name Ydb.Table.TableIndexDescription.Status
             * @enum {number}
             * @property {number} STATUS_UNSPECIFIED=0 STATUS_UNSPECIFIED value
             * @property {number} STATUS_READY=1 STATUS_READY value
             * @property {number} STATUS_BUILDING=2 STATUS_BUILDING value
             */
            TableIndexDescription.Status = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "STATUS_UNSPECIFIED"] = 0;
                values[valuesById[1] = "STATUS_READY"] = 1;
                values[valuesById[2] = "STATUS_BUILDING"] = 2;
                return values;
            })();

            return TableIndexDescription;
        })();

        Table.IndexBuildState = (function() {

            /**
             * Properties of an IndexBuildState.
             * @memberof Ydb.Table
             * @interface IIndexBuildState
             */

            /**
             * Constructs a new IndexBuildState.
             * @memberof Ydb.Table
             * @classdesc Represents an IndexBuildState.
             * @implements IIndexBuildState
             * @constructor
             * @param {Ydb.Table.IIndexBuildState=} [properties] Properties to set
             */
            function IndexBuildState(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new IndexBuildState instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.IndexBuildState
             * @static
             * @param {Ydb.Table.IIndexBuildState=} [properties] Properties to set
             * @returns {Ydb.Table.IndexBuildState} IndexBuildState instance
             */
            IndexBuildState.create = function create(properties) {
                return new IndexBuildState(properties);
            };

            /**
             * Encodes the specified IndexBuildState message. Does not implicitly {@link Ydb.Table.IndexBuildState.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.IndexBuildState
             * @static
             * @param {Ydb.Table.IIndexBuildState} message IndexBuildState message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            IndexBuildState.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified IndexBuildState message, length delimited. Does not implicitly {@link Ydb.Table.IndexBuildState.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.IndexBuildState
             * @static
             * @param {Ydb.Table.IIndexBuildState} message IndexBuildState message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            IndexBuildState.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an IndexBuildState message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.IndexBuildState
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.IndexBuildState} IndexBuildState
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            IndexBuildState.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.IndexBuildState();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an IndexBuildState message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.IndexBuildState
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.IndexBuildState} IndexBuildState
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            IndexBuildState.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an IndexBuildState message.
             * @function verify
             * @memberof Ydb.Table.IndexBuildState
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            IndexBuildState.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates an IndexBuildState message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.IndexBuildState
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.IndexBuildState} IndexBuildState
             */
            IndexBuildState.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.IndexBuildState)
                    return object;
                return new $root.Ydb.Table.IndexBuildState();
            };

            /**
             * Creates a plain object from an IndexBuildState message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.IndexBuildState
             * @static
             * @param {Ydb.Table.IndexBuildState} message IndexBuildState
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            IndexBuildState.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this IndexBuildState to JSON.
             * @function toJSON
             * @memberof Ydb.Table.IndexBuildState
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            IndexBuildState.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * State enum.
             * @name Ydb.Table.IndexBuildState.State
             * @enum {number}
             * @property {number} STATE_UNSPECIFIED=0 STATE_UNSPECIFIED value
             * @property {number} STATE_PREPARING=1 STATE_PREPARING value
             * @property {number} STATE_TRANSFERING_DATA=2 STATE_TRANSFERING_DATA value
             * @property {number} STATE_APPLYING=3 STATE_APPLYING value
             * @property {number} STATE_DONE=4 STATE_DONE value
             * @property {number} STATE_CANCELLATION=5 STATE_CANCELLATION value
             * @property {number} STATE_CANCELLED=6 STATE_CANCELLED value
             * @property {number} STATE_REJECTION=7 STATE_REJECTION value
             * @property {number} STATE_REJECTED=8 STATE_REJECTED value
             */
            IndexBuildState.State = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "STATE_UNSPECIFIED"] = 0;
                values[valuesById[1] = "STATE_PREPARING"] = 1;
                values[valuesById[2] = "STATE_TRANSFERING_DATA"] = 2;
                values[valuesById[3] = "STATE_APPLYING"] = 3;
                values[valuesById[4] = "STATE_DONE"] = 4;
                values[valuesById[5] = "STATE_CANCELLATION"] = 5;
                values[valuesById[6] = "STATE_CANCELLED"] = 6;
                values[valuesById[7] = "STATE_REJECTION"] = 7;
                values[valuesById[8] = "STATE_REJECTED"] = 8;
                return values;
            })();

            return IndexBuildState;
        })();

        Table.IndexBuildDescription = (function() {

            /**
             * Properties of an IndexBuildDescription.
             * @memberof Ydb.Table
             * @interface IIndexBuildDescription
             * @property {string|null} [path] IndexBuildDescription path
             * @property {Ydb.Table.ITableIndex|null} [index] IndexBuildDescription index
             */

            /**
             * Constructs a new IndexBuildDescription.
             * @memberof Ydb.Table
             * @classdesc Represents an IndexBuildDescription.
             * @implements IIndexBuildDescription
             * @constructor
             * @param {Ydb.Table.IIndexBuildDescription=} [properties] Properties to set
             */
            function IndexBuildDescription(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * IndexBuildDescription path.
             * @member {string} path
             * @memberof Ydb.Table.IndexBuildDescription
             * @instance
             */
            IndexBuildDescription.prototype.path = "";

            /**
             * IndexBuildDescription index.
             * @member {Ydb.Table.ITableIndex|null|undefined} index
             * @memberof Ydb.Table.IndexBuildDescription
             * @instance
             */
            IndexBuildDescription.prototype.index = null;

            /**
             * Creates a new IndexBuildDescription instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.IndexBuildDescription
             * @static
             * @param {Ydb.Table.IIndexBuildDescription=} [properties] Properties to set
             * @returns {Ydb.Table.IndexBuildDescription} IndexBuildDescription instance
             */
            IndexBuildDescription.create = function create(properties) {
                return new IndexBuildDescription(properties);
            };

            /**
             * Encodes the specified IndexBuildDescription message. Does not implicitly {@link Ydb.Table.IndexBuildDescription.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.IndexBuildDescription
             * @static
             * @param {Ydb.Table.IIndexBuildDescription} message IndexBuildDescription message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            IndexBuildDescription.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.path != null && Object.hasOwnProperty.call(message, "path"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.path);
                if (message.index != null && Object.hasOwnProperty.call(message, "index"))
                    $root.Ydb.Table.TableIndex.encode(message.index, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified IndexBuildDescription message, length delimited. Does not implicitly {@link Ydb.Table.IndexBuildDescription.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.IndexBuildDescription
             * @static
             * @param {Ydb.Table.IIndexBuildDescription} message IndexBuildDescription message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            IndexBuildDescription.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an IndexBuildDescription message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.IndexBuildDescription
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.IndexBuildDescription} IndexBuildDescription
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            IndexBuildDescription.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.IndexBuildDescription();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.path = reader.string();
                        break;
                    case 2:
                        message.index = $root.Ydb.Table.TableIndex.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an IndexBuildDescription message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.IndexBuildDescription
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.IndexBuildDescription} IndexBuildDescription
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            IndexBuildDescription.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an IndexBuildDescription message.
             * @function verify
             * @memberof Ydb.Table.IndexBuildDescription
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            IndexBuildDescription.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.path != null && message.hasOwnProperty("path"))
                    if (!$util.isString(message.path))
                        return "path: string expected";
                if (message.index != null && message.hasOwnProperty("index")) {
                    var error = $root.Ydb.Table.TableIndex.verify(message.index);
                    if (error)
                        return "index." + error;
                }
                return null;
            };

            /**
             * Creates an IndexBuildDescription message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.IndexBuildDescription
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.IndexBuildDescription} IndexBuildDescription
             */
            IndexBuildDescription.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.IndexBuildDescription)
                    return object;
                var message = new $root.Ydb.Table.IndexBuildDescription();
                if (object.path != null)
                    message.path = String(object.path);
                if (object.index != null) {
                    if (typeof object.index !== "object")
                        throw TypeError(".Ydb.Table.IndexBuildDescription.index: object expected");
                    message.index = $root.Ydb.Table.TableIndex.fromObject(object.index);
                }
                return message;
            };

            /**
             * Creates a plain object from an IndexBuildDescription message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.IndexBuildDescription
             * @static
             * @param {Ydb.Table.IndexBuildDescription} message IndexBuildDescription
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            IndexBuildDescription.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.path = "";
                    object.index = null;
                }
                if (message.path != null && message.hasOwnProperty("path"))
                    object.path = message.path;
                if (message.index != null && message.hasOwnProperty("index"))
                    object.index = $root.Ydb.Table.TableIndex.toObject(message.index, options);
                return object;
            };

            /**
             * Converts this IndexBuildDescription to JSON.
             * @function toJSON
             * @memberof Ydb.Table.IndexBuildDescription
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            IndexBuildDescription.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return IndexBuildDescription;
        })();

        Table.IndexBuildMetadata = (function() {

            /**
             * Properties of an IndexBuildMetadata.
             * @memberof Ydb.Table
             * @interface IIndexBuildMetadata
             * @property {Ydb.Table.IIndexBuildDescription|null} [description] IndexBuildMetadata description
             * @property {Ydb.Table.IndexBuildState.State|null} [state] IndexBuildMetadata state
             * @property {number|null} [progress] IndexBuildMetadata progress
             */

            /**
             * Constructs a new IndexBuildMetadata.
             * @memberof Ydb.Table
             * @classdesc Represents an IndexBuildMetadata.
             * @implements IIndexBuildMetadata
             * @constructor
             * @param {Ydb.Table.IIndexBuildMetadata=} [properties] Properties to set
             */
            function IndexBuildMetadata(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * IndexBuildMetadata description.
             * @member {Ydb.Table.IIndexBuildDescription|null|undefined} description
             * @memberof Ydb.Table.IndexBuildMetadata
             * @instance
             */
            IndexBuildMetadata.prototype.description = null;

            /**
             * IndexBuildMetadata state.
             * @member {Ydb.Table.IndexBuildState.State} state
             * @memberof Ydb.Table.IndexBuildMetadata
             * @instance
             */
            IndexBuildMetadata.prototype.state = 0;

            /**
             * IndexBuildMetadata progress.
             * @member {number} progress
             * @memberof Ydb.Table.IndexBuildMetadata
             * @instance
             */
            IndexBuildMetadata.prototype.progress = 0;

            /**
             * Creates a new IndexBuildMetadata instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.IndexBuildMetadata
             * @static
             * @param {Ydb.Table.IIndexBuildMetadata=} [properties] Properties to set
             * @returns {Ydb.Table.IndexBuildMetadata} IndexBuildMetadata instance
             */
            IndexBuildMetadata.create = function create(properties) {
                return new IndexBuildMetadata(properties);
            };

            /**
             * Encodes the specified IndexBuildMetadata message. Does not implicitly {@link Ydb.Table.IndexBuildMetadata.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.IndexBuildMetadata
             * @static
             * @param {Ydb.Table.IIndexBuildMetadata} message IndexBuildMetadata message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            IndexBuildMetadata.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.description != null && Object.hasOwnProperty.call(message, "description"))
                    $root.Ydb.Table.IndexBuildDescription.encode(message.description, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.state != null && Object.hasOwnProperty.call(message, "state"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.state);
                if (message.progress != null && Object.hasOwnProperty.call(message, "progress"))
                    writer.uint32(/* id 3, wireType 5 =*/29).float(message.progress);
                return writer;
            };

            /**
             * Encodes the specified IndexBuildMetadata message, length delimited. Does not implicitly {@link Ydb.Table.IndexBuildMetadata.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.IndexBuildMetadata
             * @static
             * @param {Ydb.Table.IIndexBuildMetadata} message IndexBuildMetadata message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            IndexBuildMetadata.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an IndexBuildMetadata message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.IndexBuildMetadata
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.IndexBuildMetadata} IndexBuildMetadata
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            IndexBuildMetadata.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.IndexBuildMetadata();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.description = $root.Ydb.Table.IndexBuildDescription.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.state = reader.int32();
                        break;
                    case 3:
                        message.progress = reader.float();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an IndexBuildMetadata message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.IndexBuildMetadata
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.IndexBuildMetadata} IndexBuildMetadata
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            IndexBuildMetadata.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an IndexBuildMetadata message.
             * @function verify
             * @memberof Ydb.Table.IndexBuildMetadata
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            IndexBuildMetadata.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.description != null && message.hasOwnProperty("description")) {
                    var error = $root.Ydb.Table.IndexBuildDescription.verify(message.description);
                    if (error)
                        return "description." + error;
                }
                if (message.state != null && message.hasOwnProperty("state"))
                    switch (message.state) {
                    default:
                        return "state: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                        break;
                    }
                if (message.progress != null && message.hasOwnProperty("progress"))
                    if (typeof message.progress !== "number")
                        return "progress: number expected";
                return null;
            };

            /**
             * Creates an IndexBuildMetadata message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.IndexBuildMetadata
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.IndexBuildMetadata} IndexBuildMetadata
             */
            IndexBuildMetadata.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.IndexBuildMetadata)
                    return object;
                var message = new $root.Ydb.Table.IndexBuildMetadata();
                if (object.description != null) {
                    if (typeof object.description !== "object")
                        throw TypeError(".Ydb.Table.IndexBuildMetadata.description: object expected");
                    message.description = $root.Ydb.Table.IndexBuildDescription.fromObject(object.description);
                }
                switch (object.state) {
                case "STATE_UNSPECIFIED":
                case 0:
                    message.state = 0;
                    break;
                case "STATE_PREPARING":
                case 1:
                    message.state = 1;
                    break;
                case "STATE_TRANSFERING_DATA":
                case 2:
                    message.state = 2;
                    break;
                case "STATE_APPLYING":
                case 3:
                    message.state = 3;
                    break;
                case "STATE_DONE":
                case 4:
                    message.state = 4;
                    break;
                case "STATE_CANCELLATION":
                case 5:
                    message.state = 5;
                    break;
                case "STATE_CANCELLED":
                case 6:
                    message.state = 6;
                    break;
                case "STATE_REJECTION":
                case 7:
                    message.state = 7;
                    break;
                case "STATE_REJECTED":
                case 8:
                    message.state = 8;
                    break;
                }
                if (object.progress != null)
                    message.progress = Number(object.progress);
                return message;
            };

            /**
             * Creates a plain object from an IndexBuildMetadata message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.IndexBuildMetadata
             * @static
             * @param {Ydb.Table.IndexBuildMetadata} message IndexBuildMetadata
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            IndexBuildMetadata.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.description = null;
                    object.state = options.enums === String ? "STATE_UNSPECIFIED" : 0;
                    object.progress = 0;
                }
                if (message.description != null && message.hasOwnProperty("description"))
                    object.description = $root.Ydb.Table.IndexBuildDescription.toObject(message.description, options);
                if (message.state != null && message.hasOwnProperty("state"))
                    object.state = options.enums === String ? $root.Ydb.Table.IndexBuildState.State[message.state] : message.state;
                if (message.progress != null && message.hasOwnProperty("progress"))
                    object.progress = options.json && !isFinite(message.progress) ? String(message.progress) : message.progress;
                return object;
            };

            /**
             * Converts this IndexBuildMetadata to JSON.
             * @function toJSON
             * @memberof Ydb.Table.IndexBuildMetadata
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            IndexBuildMetadata.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return IndexBuildMetadata;
        })();

        Table.StoragePool = (function() {

            /**
             * Properties of a StoragePool.
             * @memberof Ydb.Table
             * @interface IStoragePool
             * @property {string|null} [media] StoragePool media
             */

            /**
             * Constructs a new StoragePool.
             * @memberof Ydb.Table
             * @classdesc Represents a StoragePool.
             * @implements IStoragePool
             * @constructor
             * @param {Ydb.Table.IStoragePool=} [properties] Properties to set
             */
            function StoragePool(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * StoragePool media.
             * @member {string} media
             * @memberof Ydb.Table.StoragePool
             * @instance
             */
            StoragePool.prototype.media = "";

            /**
             * Creates a new StoragePool instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.StoragePool
             * @static
             * @param {Ydb.Table.IStoragePool=} [properties] Properties to set
             * @returns {Ydb.Table.StoragePool} StoragePool instance
             */
            StoragePool.create = function create(properties) {
                return new StoragePool(properties);
            };

            /**
             * Encodes the specified StoragePool message. Does not implicitly {@link Ydb.Table.StoragePool.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.StoragePool
             * @static
             * @param {Ydb.Table.IStoragePool} message StoragePool message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StoragePool.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.media != null && Object.hasOwnProperty.call(message, "media"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.media);
                return writer;
            };

            /**
             * Encodes the specified StoragePool message, length delimited. Does not implicitly {@link Ydb.Table.StoragePool.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.StoragePool
             * @static
             * @param {Ydb.Table.IStoragePool} message StoragePool message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StoragePool.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a StoragePool message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.StoragePool
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.StoragePool} StoragePool
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StoragePool.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.StoragePool();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.media = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a StoragePool message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.StoragePool
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.StoragePool} StoragePool
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StoragePool.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a StoragePool message.
             * @function verify
             * @memberof Ydb.Table.StoragePool
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            StoragePool.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.media != null && message.hasOwnProperty("media"))
                    if (!$util.isString(message.media))
                        return "media: string expected";
                return null;
            };

            /**
             * Creates a StoragePool message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.StoragePool
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.StoragePool} StoragePool
             */
            StoragePool.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.StoragePool)
                    return object;
                var message = new $root.Ydb.Table.StoragePool();
                if (object.media != null)
                    message.media = String(object.media);
                return message;
            };

            /**
             * Creates a plain object from a StoragePool message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.StoragePool
             * @static
             * @param {Ydb.Table.StoragePool} message StoragePool
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            StoragePool.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.media = "";
                if (message.media != null && message.hasOwnProperty("media"))
                    object.media = message.media;
                return object;
            };

            /**
             * Converts this StoragePool to JSON.
             * @function toJSON
             * @memberof Ydb.Table.StoragePool
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            StoragePool.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return StoragePool;
        })();

        Table.StoragePolicy = (function() {

            /**
             * Properties of a StoragePolicy.
             * @memberof Ydb.Table
             * @interface IStoragePolicy
             * @property {string|null} [presetName] StoragePolicy presetName
             * @property {Ydb.Table.IStoragePool|null} [syslog] StoragePolicy syslog
             * @property {Ydb.Table.IStoragePool|null} [log] StoragePolicy log
             * @property {Ydb.Table.IStoragePool|null} [data] StoragePolicy data
             * @property {Ydb.Table.IStoragePool|null} [external] StoragePolicy external
             * @property {Ydb.FeatureFlag.Status|null} [keepInMemory] StoragePolicy keepInMemory
             * @property {Array.<Ydb.Table.IColumnFamilyPolicy>|null} [columnFamilies] StoragePolicy columnFamilies
             */

            /**
             * Constructs a new StoragePolicy.
             * @memberof Ydb.Table
             * @classdesc Represents a StoragePolicy.
             * @implements IStoragePolicy
             * @constructor
             * @param {Ydb.Table.IStoragePolicy=} [properties] Properties to set
             */
            function StoragePolicy(properties) {
                this.columnFamilies = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * StoragePolicy presetName.
             * @member {string} presetName
             * @memberof Ydb.Table.StoragePolicy
             * @instance
             */
            StoragePolicy.prototype.presetName = "";

            /**
             * StoragePolicy syslog.
             * @member {Ydb.Table.IStoragePool|null|undefined} syslog
             * @memberof Ydb.Table.StoragePolicy
             * @instance
             */
            StoragePolicy.prototype.syslog = null;

            /**
             * StoragePolicy log.
             * @member {Ydb.Table.IStoragePool|null|undefined} log
             * @memberof Ydb.Table.StoragePolicy
             * @instance
             */
            StoragePolicy.prototype.log = null;

            /**
             * StoragePolicy data.
             * @member {Ydb.Table.IStoragePool|null|undefined} data
             * @memberof Ydb.Table.StoragePolicy
             * @instance
             */
            StoragePolicy.prototype.data = null;

            /**
             * StoragePolicy external.
             * @member {Ydb.Table.IStoragePool|null|undefined} external
             * @memberof Ydb.Table.StoragePolicy
             * @instance
             */
            StoragePolicy.prototype.external = null;

            /**
             * StoragePolicy keepInMemory.
             * @member {Ydb.FeatureFlag.Status} keepInMemory
             * @memberof Ydb.Table.StoragePolicy
             * @instance
             */
            StoragePolicy.prototype.keepInMemory = 0;

            /**
             * StoragePolicy columnFamilies.
             * @member {Array.<Ydb.Table.IColumnFamilyPolicy>} columnFamilies
             * @memberof Ydb.Table.StoragePolicy
             * @instance
             */
            StoragePolicy.prototype.columnFamilies = $util.emptyArray;

            /**
             * Creates a new StoragePolicy instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.StoragePolicy
             * @static
             * @param {Ydb.Table.IStoragePolicy=} [properties] Properties to set
             * @returns {Ydb.Table.StoragePolicy} StoragePolicy instance
             */
            StoragePolicy.create = function create(properties) {
                return new StoragePolicy(properties);
            };

            /**
             * Encodes the specified StoragePolicy message. Does not implicitly {@link Ydb.Table.StoragePolicy.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.StoragePolicy
             * @static
             * @param {Ydb.Table.IStoragePolicy} message StoragePolicy message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StoragePolicy.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.presetName != null && Object.hasOwnProperty.call(message, "presetName"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.presetName);
                if (message.syslog != null && Object.hasOwnProperty.call(message, "syslog"))
                    $root.Ydb.Table.StoragePool.encode(message.syslog, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.log != null && Object.hasOwnProperty.call(message, "log"))
                    $root.Ydb.Table.StoragePool.encode(message.log, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                    $root.Ydb.Table.StoragePool.encode(message.data, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.external != null && Object.hasOwnProperty.call(message, "external"))
                    $root.Ydb.Table.StoragePool.encode(message.external, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.keepInMemory != null && Object.hasOwnProperty.call(message, "keepInMemory"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int32(message.keepInMemory);
                if (message.columnFamilies != null && message.columnFamilies.length)
                    for (var i = 0; i < message.columnFamilies.length; ++i)
                        $root.Ydb.Table.ColumnFamilyPolicy.encode(message.columnFamilies[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified StoragePolicy message, length delimited. Does not implicitly {@link Ydb.Table.StoragePolicy.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.StoragePolicy
             * @static
             * @param {Ydb.Table.IStoragePolicy} message StoragePolicy message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StoragePolicy.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a StoragePolicy message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.StoragePolicy
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.StoragePolicy} StoragePolicy
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StoragePolicy.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.StoragePolicy();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.presetName = reader.string();
                        break;
                    case 2:
                        message.syslog = $root.Ydb.Table.StoragePool.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.log = $root.Ydb.Table.StoragePool.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.data = $root.Ydb.Table.StoragePool.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.external = $root.Ydb.Table.StoragePool.decode(reader, reader.uint32());
                        break;
                    case 6:
                        message.keepInMemory = reader.int32();
                        break;
                    case 7:
                        if (!(message.columnFamilies && message.columnFamilies.length))
                            message.columnFamilies = [];
                        message.columnFamilies.push($root.Ydb.Table.ColumnFamilyPolicy.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a StoragePolicy message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.StoragePolicy
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.StoragePolicy} StoragePolicy
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StoragePolicy.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a StoragePolicy message.
             * @function verify
             * @memberof Ydb.Table.StoragePolicy
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            StoragePolicy.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.presetName != null && message.hasOwnProperty("presetName"))
                    if (!$util.isString(message.presetName))
                        return "presetName: string expected";
                if (message.syslog != null && message.hasOwnProperty("syslog")) {
                    var error = $root.Ydb.Table.StoragePool.verify(message.syslog);
                    if (error)
                        return "syslog." + error;
                }
                if (message.log != null && message.hasOwnProperty("log")) {
                    var error = $root.Ydb.Table.StoragePool.verify(message.log);
                    if (error)
                        return "log." + error;
                }
                if (message.data != null && message.hasOwnProperty("data")) {
                    var error = $root.Ydb.Table.StoragePool.verify(message.data);
                    if (error)
                        return "data." + error;
                }
                if (message.external != null && message.hasOwnProperty("external")) {
                    var error = $root.Ydb.Table.StoragePool.verify(message.external);
                    if (error)
                        return "external." + error;
                }
                if (message.keepInMemory != null && message.hasOwnProperty("keepInMemory"))
                    switch (message.keepInMemory) {
                    default:
                        return "keepInMemory: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                if (message.columnFamilies != null && message.hasOwnProperty("columnFamilies")) {
                    if (!Array.isArray(message.columnFamilies))
                        return "columnFamilies: array expected";
                    for (var i = 0; i < message.columnFamilies.length; ++i) {
                        var error = $root.Ydb.Table.ColumnFamilyPolicy.verify(message.columnFamilies[i]);
                        if (error)
                            return "columnFamilies." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a StoragePolicy message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.StoragePolicy
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.StoragePolicy} StoragePolicy
             */
            StoragePolicy.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.StoragePolicy)
                    return object;
                var message = new $root.Ydb.Table.StoragePolicy();
                if (object.presetName != null)
                    message.presetName = String(object.presetName);
                if (object.syslog != null) {
                    if (typeof object.syslog !== "object")
                        throw TypeError(".Ydb.Table.StoragePolicy.syslog: object expected");
                    message.syslog = $root.Ydb.Table.StoragePool.fromObject(object.syslog);
                }
                if (object.log != null) {
                    if (typeof object.log !== "object")
                        throw TypeError(".Ydb.Table.StoragePolicy.log: object expected");
                    message.log = $root.Ydb.Table.StoragePool.fromObject(object.log);
                }
                if (object.data != null) {
                    if (typeof object.data !== "object")
                        throw TypeError(".Ydb.Table.StoragePolicy.data: object expected");
                    message.data = $root.Ydb.Table.StoragePool.fromObject(object.data);
                }
                if (object.external != null) {
                    if (typeof object.external !== "object")
                        throw TypeError(".Ydb.Table.StoragePolicy.external: object expected");
                    message.external = $root.Ydb.Table.StoragePool.fromObject(object.external);
                }
                switch (object.keepInMemory) {
                case "STATUS_UNSPECIFIED":
                case 0:
                    message.keepInMemory = 0;
                    break;
                case "ENABLED":
                case 1:
                    message.keepInMemory = 1;
                    break;
                case "DISABLED":
                case 2:
                    message.keepInMemory = 2;
                    break;
                }
                if (object.columnFamilies) {
                    if (!Array.isArray(object.columnFamilies))
                        throw TypeError(".Ydb.Table.StoragePolicy.columnFamilies: array expected");
                    message.columnFamilies = [];
                    for (var i = 0; i < object.columnFamilies.length; ++i) {
                        if (typeof object.columnFamilies[i] !== "object")
                            throw TypeError(".Ydb.Table.StoragePolicy.columnFamilies: object expected");
                        message.columnFamilies[i] = $root.Ydb.Table.ColumnFamilyPolicy.fromObject(object.columnFamilies[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a StoragePolicy message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.StoragePolicy
             * @static
             * @param {Ydb.Table.StoragePolicy} message StoragePolicy
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            StoragePolicy.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.columnFamilies = [];
                if (options.defaults) {
                    object.presetName = "";
                    object.syslog = null;
                    object.log = null;
                    object.data = null;
                    object.external = null;
                    object.keepInMemory = options.enums === String ? "STATUS_UNSPECIFIED" : 0;
                }
                if (message.presetName != null && message.hasOwnProperty("presetName"))
                    object.presetName = message.presetName;
                if (message.syslog != null && message.hasOwnProperty("syslog"))
                    object.syslog = $root.Ydb.Table.StoragePool.toObject(message.syslog, options);
                if (message.log != null && message.hasOwnProperty("log"))
                    object.log = $root.Ydb.Table.StoragePool.toObject(message.log, options);
                if (message.data != null && message.hasOwnProperty("data"))
                    object.data = $root.Ydb.Table.StoragePool.toObject(message.data, options);
                if (message.external != null && message.hasOwnProperty("external"))
                    object.external = $root.Ydb.Table.StoragePool.toObject(message.external, options);
                if (message.keepInMemory != null && message.hasOwnProperty("keepInMemory"))
                    object.keepInMemory = options.enums === String ? $root.Ydb.FeatureFlag.Status[message.keepInMemory] : message.keepInMemory;
                if (message.columnFamilies && message.columnFamilies.length) {
                    object.columnFamilies = [];
                    for (var j = 0; j < message.columnFamilies.length; ++j)
                        object.columnFamilies[j] = $root.Ydb.Table.ColumnFamilyPolicy.toObject(message.columnFamilies[j], options);
                }
                return object;
            };

            /**
             * Converts this StoragePolicy to JSON.
             * @function toJSON
             * @memberof Ydb.Table.StoragePolicy
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            StoragePolicy.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return StoragePolicy;
        })();

        Table.ColumnFamilyPolicy = (function() {

            /**
             * Properties of a ColumnFamilyPolicy.
             * @memberof Ydb.Table
             * @interface IColumnFamilyPolicy
             * @property {string|null} [name] ColumnFamilyPolicy name
             * @property {Ydb.Table.IStoragePool|null} [data] ColumnFamilyPolicy data
             * @property {Ydb.Table.IStoragePool|null} [external] ColumnFamilyPolicy external
             * @property {Ydb.FeatureFlag.Status|null} [keepInMemory] ColumnFamilyPolicy keepInMemory
             * @property {Ydb.Table.ColumnFamilyPolicy.Compression|null} [compression] ColumnFamilyPolicy compression
             */

            /**
             * Constructs a new ColumnFamilyPolicy.
             * @memberof Ydb.Table
             * @classdesc Represents a ColumnFamilyPolicy.
             * @implements IColumnFamilyPolicy
             * @constructor
             * @param {Ydb.Table.IColumnFamilyPolicy=} [properties] Properties to set
             */
            function ColumnFamilyPolicy(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ColumnFamilyPolicy name.
             * @member {string} name
             * @memberof Ydb.Table.ColumnFamilyPolicy
             * @instance
             */
            ColumnFamilyPolicy.prototype.name = "";

            /**
             * ColumnFamilyPolicy data.
             * @member {Ydb.Table.IStoragePool|null|undefined} data
             * @memberof Ydb.Table.ColumnFamilyPolicy
             * @instance
             */
            ColumnFamilyPolicy.prototype.data = null;

            /**
             * ColumnFamilyPolicy external.
             * @member {Ydb.Table.IStoragePool|null|undefined} external
             * @memberof Ydb.Table.ColumnFamilyPolicy
             * @instance
             */
            ColumnFamilyPolicy.prototype.external = null;

            /**
             * ColumnFamilyPolicy keepInMemory.
             * @member {Ydb.FeatureFlag.Status} keepInMemory
             * @memberof Ydb.Table.ColumnFamilyPolicy
             * @instance
             */
            ColumnFamilyPolicy.prototype.keepInMemory = 0;

            /**
             * ColumnFamilyPolicy compression.
             * @member {Ydb.Table.ColumnFamilyPolicy.Compression} compression
             * @memberof Ydb.Table.ColumnFamilyPolicy
             * @instance
             */
            ColumnFamilyPolicy.prototype.compression = 0;

            /**
             * Creates a new ColumnFamilyPolicy instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.ColumnFamilyPolicy
             * @static
             * @param {Ydb.Table.IColumnFamilyPolicy=} [properties] Properties to set
             * @returns {Ydb.Table.ColumnFamilyPolicy} ColumnFamilyPolicy instance
             */
            ColumnFamilyPolicy.create = function create(properties) {
                return new ColumnFamilyPolicy(properties);
            };

            /**
             * Encodes the specified ColumnFamilyPolicy message. Does not implicitly {@link Ydb.Table.ColumnFamilyPolicy.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.ColumnFamilyPolicy
             * @static
             * @param {Ydb.Table.IColumnFamilyPolicy} message ColumnFamilyPolicy message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ColumnFamilyPolicy.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                    $root.Ydb.Table.StoragePool.encode(message.data, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.external != null && Object.hasOwnProperty.call(message, "external"))
                    $root.Ydb.Table.StoragePool.encode(message.external, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.keepInMemory != null && Object.hasOwnProperty.call(message, "keepInMemory"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.keepInMemory);
                if (message.compression != null && Object.hasOwnProperty.call(message, "compression"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.compression);
                return writer;
            };

            /**
             * Encodes the specified ColumnFamilyPolicy message, length delimited. Does not implicitly {@link Ydb.Table.ColumnFamilyPolicy.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.ColumnFamilyPolicy
             * @static
             * @param {Ydb.Table.IColumnFamilyPolicy} message ColumnFamilyPolicy message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ColumnFamilyPolicy.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ColumnFamilyPolicy message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.ColumnFamilyPolicy
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.ColumnFamilyPolicy} ColumnFamilyPolicy
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ColumnFamilyPolicy.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.ColumnFamilyPolicy();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message.data = $root.Ydb.Table.StoragePool.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.external = $root.Ydb.Table.StoragePool.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.keepInMemory = reader.int32();
                        break;
                    case 5:
                        message.compression = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ColumnFamilyPolicy message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.ColumnFamilyPolicy
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.ColumnFamilyPolicy} ColumnFamilyPolicy
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ColumnFamilyPolicy.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ColumnFamilyPolicy message.
             * @function verify
             * @memberof Ydb.Table.ColumnFamilyPolicy
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ColumnFamilyPolicy.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.data != null && message.hasOwnProperty("data")) {
                    var error = $root.Ydb.Table.StoragePool.verify(message.data);
                    if (error)
                        return "data." + error;
                }
                if (message.external != null && message.hasOwnProperty("external")) {
                    var error = $root.Ydb.Table.StoragePool.verify(message.external);
                    if (error)
                        return "external." + error;
                }
                if (message.keepInMemory != null && message.hasOwnProperty("keepInMemory"))
                    switch (message.keepInMemory) {
                    default:
                        return "keepInMemory: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                if (message.compression != null && message.hasOwnProperty("compression"))
                    switch (message.compression) {
                    default:
                        return "compression: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                return null;
            };

            /**
             * Creates a ColumnFamilyPolicy message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.ColumnFamilyPolicy
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.ColumnFamilyPolicy} ColumnFamilyPolicy
             */
            ColumnFamilyPolicy.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.ColumnFamilyPolicy)
                    return object;
                var message = new $root.Ydb.Table.ColumnFamilyPolicy();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.data != null) {
                    if (typeof object.data !== "object")
                        throw TypeError(".Ydb.Table.ColumnFamilyPolicy.data: object expected");
                    message.data = $root.Ydb.Table.StoragePool.fromObject(object.data);
                }
                if (object.external != null) {
                    if (typeof object.external !== "object")
                        throw TypeError(".Ydb.Table.ColumnFamilyPolicy.external: object expected");
                    message.external = $root.Ydb.Table.StoragePool.fromObject(object.external);
                }
                switch (object.keepInMemory) {
                case "STATUS_UNSPECIFIED":
                case 0:
                    message.keepInMemory = 0;
                    break;
                case "ENABLED":
                case 1:
                    message.keepInMemory = 1;
                    break;
                case "DISABLED":
                case 2:
                    message.keepInMemory = 2;
                    break;
                }
                switch (object.compression) {
                case "COMPRESSION_UNSPECIFIED":
                case 0:
                    message.compression = 0;
                    break;
                case "UNCOMPRESSED":
                case 1:
                    message.compression = 1;
                    break;
                case "COMPRESSED":
                case 2:
                    message.compression = 2;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from a ColumnFamilyPolicy message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.ColumnFamilyPolicy
             * @static
             * @param {Ydb.Table.ColumnFamilyPolicy} message ColumnFamilyPolicy
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ColumnFamilyPolicy.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.name = "";
                    object.data = null;
                    object.external = null;
                    object.keepInMemory = options.enums === String ? "STATUS_UNSPECIFIED" : 0;
                    object.compression = options.enums === String ? "COMPRESSION_UNSPECIFIED" : 0;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.data != null && message.hasOwnProperty("data"))
                    object.data = $root.Ydb.Table.StoragePool.toObject(message.data, options);
                if (message.external != null && message.hasOwnProperty("external"))
                    object.external = $root.Ydb.Table.StoragePool.toObject(message.external, options);
                if (message.keepInMemory != null && message.hasOwnProperty("keepInMemory"))
                    object.keepInMemory = options.enums === String ? $root.Ydb.FeatureFlag.Status[message.keepInMemory] : message.keepInMemory;
                if (message.compression != null && message.hasOwnProperty("compression"))
                    object.compression = options.enums === String ? $root.Ydb.Table.ColumnFamilyPolicy.Compression[message.compression] : message.compression;
                return object;
            };

            /**
             * Converts this ColumnFamilyPolicy to JSON.
             * @function toJSON
             * @memberof Ydb.Table.ColumnFamilyPolicy
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ColumnFamilyPolicy.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Compression enum.
             * @name Ydb.Table.ColumnFamilyPolicy.Compression
             * @enum {number}
             * @property {number} COMPRESSION_UNSPECIFIED=0 COMPRESSION_UNSPECIFIED value
             * @property {number} UNCOMPRESSED=1 UNCOMPRESSED value
             * @property {number} COMPRESSED=2 COMPRESSED value
             */
            ColumnFamilyPolicy.Compression = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "COMPRESSION_UNSPECIFIED"] = 0;
                values[valuesById[1] = "UNCOMPRESSED"] = 1;
                values[valuesById[2] = "COMPRESSED"] = 2;
                return values;
            })();

            return ColumnFamilyPolicy;
        })();

        Table.CompactionPolicy = (function() {

            /**
             * Properties of a CompactionPolicy.
             * @memberof Ydb.Table
             * @interface ICompactionPolicy
             * @property {string|null} [presetName] CompactionPolicy presetName
             */

            /**
             * Constructs a new CompactionPolicy.
             * @memberof Ydb.Table
             * @classdesc Represents a CompactionPolicy.
             * @implements ICompactionPolicy
             * @constructor
             * @param {Ydb.Table.ICompactionPolicy=} [properties] Properties to set
             */
            function CompactionPolicy(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CompactionPolicy presetName.
             * @member {string} presetName
             * @memberof Ydb.Table.CompactionPolicy
             * @instance
             */
            CompactionPolicy.prototype.presetName = "";

            /**
             * Creates a new CompactionPolicy instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.CompactionPolicy
             * @static
             * @param {Ydb.Table.ICompactionPolicy=} [properties] Properties to set
             * @returns {Ydb.Table.CompactionPolicy} CompactionPolicy instance
             */
            CompactionPolicy.create = function create(properties) {
                return new CompactionPolicy(properties);
            };

            /**
             * Encodes the specified CompactionPolicy message. Does not implicitly {@link Ydb.Table.CompactionPolicy.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.CompactionPolicy
             * @static
             * @param {Ydb.Table.ICompactionPolicy} message CompactionPolicy message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CompactionPolicy.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.presetName != null && Object.hasOwnProperty.call(message, "presetName"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.presetName);
                return writer;
            };

            /**
             * Encodes the specified CompactionPolicy message, length delimited. Does not implicitly {@link Ydb.Table.CompactionPolicy.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.CompactionPolicy
             * @static
             * @param {Ydb.Table.ICompactionPolicy} message CompactionPolicy message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CompactionPolicy.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CompactionPolicy message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.CompactionPolicy
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.CompactionPolicy} CompactionPolicy
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CompactionPolicy.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.CompactionPolicy();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.presetName = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a CompactionPolicy message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.CompactionPolicy
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.CompactionPolicy} CompactionPolicy
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CompactionPolicy.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CompactionPolicy message.
             * @function verify
             * @memberof Ydb.Table.CompactionPolicy
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CompactionPolicy.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.presetName != null && message.hasOwnProperty("presetName"))
                    if (!$util.isString(message.presetName))
                        return "presetName: string expected";
                return null;
            };

            /**
             * Creates a CompactionPolicy message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.CompactionPolicy
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.CompactionPolicy} CompactionPolicy
             */
            CompactionPolicy.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.CompactionPolicy)
                    return object;
                var message = new $root.Ydb.Table.CompactionPolicy();
                if (object.presetName != null)
                    message.presetName = String(object.presetName);
                return message;
            };

            /**
             * Creates a plain object from a CompactionPolicy message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.CompactionPolicy
             * @static
             * @param {Ydb.Table.CompactionPolicy} message CompactionPolicy
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CompactionPolicy.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.presetName = "";
                if (message.presetName != null && message.hasOwnProperty("presetName"))
                    object.presetName = message.presetName;
                return object;
            };

            /**
             * Converts this CompactionPolicy to JSON.
             * @function toJSON
             * @memberof Ydb.Table.CompactionPolicy
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CompactionPolicy.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return CompactionPolicy;
        })();

        Table.ExplicitPartitions = (function() {

            /**
             * Properties of an ExplicitPartitions.
             * @memberof Ydb.Table
             * @interface IExplicitPartitions
             * @property {Array.<Ydb.ITypedValue>|null} [splitPoints] ExplicitPartitions splitPoints
             */

            /**
             * Constructs a new ExplicitPartitions.
             * @memberof Ydb.Table
             * @classdesc Represents an ExplicitPartitions.
             * @implements IExplicitPartitions
             * @constructor
             * @param {Ydb.Table.IExplicitPartitions=} [properties] Properties to set
             */
            function ExplicitPartitions(properties) {
                this.splitPoints = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ExplicitPartitions splitPoints.
             * @member {Array.<Ydb.ITypedValue>} splitPoints
             * @memberof Ydb.Table.ExplicitPartitions
             * @instance
             */
            ExplicitPartitions.prototype.splitPoints = $util.emptyArray;

            /**
             * Creates a new ExplicitPartitions instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.ExplicitPartitions
             * @static
             * @param {Ydb.Table.IExplicitPartitions=} [properties] Properties to set
             * @returns {Ydb.Table.ExplicitPartitions} ExplicitPartitions instance
             */
            ExplicitPartitions.create = function create(properties) {
                return new ExplicitPartitions(properties);
            };

            /**
             * Encodes the specified ExplicitPartitions message. Does not implicitly {@link Ydb.Table.ExplicitPartitions.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.ExplicitPartitions
             * @static
             * @param {Ydb.Table.IExplicitPartitions} message ExplicitPartitions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExplicitPartitions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.splitPoints != null && message.splitPoints.length)
                    for (var i = 0; i < message.splitPoints.length; ++i)
                        $root.Ydb.TypedValue.encode(message.splitPoints[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ExplicitPartitions message, length delimited. Does not implicitly {@link Ydb.Table.ExplicitPartitions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.ExplicitPartitions
             * @static
             * @param {Ydb.Table.IExplicitPartitions} message ExplicitPartitions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExplicitPartitions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ExplicitPartitions message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.ExplicitPartitions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.ExplicitPartitions} ExplicitPartitions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExplicitPartitions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.ExplicitPartitions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.splitPoints && message.splitPoints.length))
                            message.splitPoints = [];
                        message.splitPoints.push($root.Ydb.TypedValue.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an ExplicitPartitions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.ExplicitPartitions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.ExplicitPartitions} ExplicitPartitions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExplicitPartitions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ExplicitPartitions message.
             * @function verify
             * @memberof Ydb.Table.ExplicitPartitions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ExplicitPartitions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.splitPoints != null && message.hasOwnProperty("splitPoints")) {
                    if (!Array.isArray(message.splitPoints))
                        return "splitPoints: array expected";
                    for (var i = 0; i < message.splitPoints.length; ++i) {
                        var error = $root.Ydb.TypedValue.verify(message.splitPoints[i]);
                        if (error)
                            return "splitPoints." + error;
                    }
                }
                return null;
            };

            /**
             * Creates an ExplicitPartitions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.ExplicitPartitions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.ExplicitPartitions} ExplicitPartitions
             */
            ExplicitPartitions.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.ExplicitPartitions)
                    return object;
                var message = new $root.Ydb.Table.ExplicitPartitions();
                if (object.splitPoints) {
                    if (!Array.isArray(object.splitPoints))
                        throw TypeError(".Ydb.Table.ExplicitPartitions.splitPoints: array expected");
                    message.splitPoints = [];
                    for (var i = 0; i < object.splitPoints.length; ++i) {
                        if (typeof object.splitPoints[i] !== "object")
                            throw TypeError(".Ydb.Table.ExplicitPartitions.splitPoints: object expected");
                        message.splitPoints[i] = $root.Ydb.TypedValue.fromObject(object.splitPoints[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from an ExplicitPartitions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.ExplicitPartitions
             * @static
             * @param {Ydb.Table.ExplicitPartitions} message ExplicitPartitions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ExplicitPartitions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.splitPoints = [];
                if (message.splitPoints && message.splitPoints.length) {
                    object.splitPoints = [];
                    for (var j = 0; j < message.splitPoints.length; ++j)
                        object.splitPoints[j] = $root.Ydb.TypedValue.toObject(message.splitPoints[j], options);
                }
                return object;
            };

            /**
             * Converts this ExplicitPartitions to JSON.
             * @function toJSON
             * @memberof Ydb.Table.ExplicitPartitions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ExplicitPartitions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ExplicitPartitions;
        })();

        Table.PartitionStats = (function() {

            /**
             * Properties of a PartitionStats.
             * @memberof Ydb.Table
             * @interface IPartitionStats
             * @property {number|Long|null} [rowsEstimate] PartitionStats rowsEstimate
             * @property {number|Long|null} [storeSize] PartitionStats storeSize
             */

            /**
             * Constructs a new PartitionStats.
             * @memberof Ydb.Table
             * @classdesc Represents a PartitionStats.
             * @implements IPartitionStats
             * @constructor
             * @param {Ydb.Table.IPartitionStats=} [properties] Properties to set
             */
            function PartitionStats(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PartitionStats rowsEstimate.
             * @member {number|Long} rowsEstimate
             * @memberof Ydb.Table.PartitionStats
             * @instance
             */
            PartitionStats.prototype.rowsEstimate = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * PartitionStats storeSize.
             * @member {number|Long} storeSize
             * @memberof Ydb.Table.PartitionStats
             * @instance
             */
            PartitionStats.prototype.storeSize = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Creates a new PartitionStats instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.PartitionStats
             * @static
             * @param {Ydb.Table.IPartitionStats=} [properties] Properties to set
             * @returns {Ydb.Table.PartitionStats} PartitionStats instance
             */
            PartitionStats.create = function create(properties) {
                return new PartitionStats(properties);
            };

            /**
             * Encodes the specified PartitionStats message. Does not implicitly {@link Ydb.Table.PartitionStats.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.PartitionStats
             * @static
             * @param {Ydb.Table.IPartitionStats} message PartitionStats message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PartitionStats.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.rowsEstimate != null && Object.hasOwnProperty.call(message, "rowsEstimate"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.rowsEstimate);
                if (message.storeSize != null && Object.hasOwnProperty.call(message, "storeSize"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.storeSize);
                return writer;
            };

            /**
             * Encodes the specified PartitionStats message, length delimited. Does not implicitly {@link Ydb.Table.PartitionStats.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.PartitionStats
             * @static
             * @param {Ydb.Table.IPartitionStats} message PartitionStats message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PartitionStats.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PartitionStats message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.PartitionStats
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.PartitionStats} PartitionStats
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PartitionStats.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.PartitionStats();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.rowsEstimate = reader.uint64();
                        break;
                    case 2:
                        message.storeSize = reader.uint64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a PartitionStats message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.PartitionStats
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.PartitionStats} PartitionStats
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PartitionStats.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PartitionStats message.
             * @function verify
             * @memberof Ydb.Table.PartitionStats
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PartitionStats.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.rowsEstimate != null && message.hasOwnProperty("rowsEstimate"))
                    if (!$util.isInteger(message.rowsEstimate) && !(message.rowsEstimate && $util.isInteger(message.rowsEstimate.low) && $util.isInteger(message.rowsEstimate.high)))
                        return "rowsEstimate: integer|Long expected";
                if (message.storeSize != null && message.hasOwnProperty("storeSize"))
                    if (!$util.isInteger(message.storeSize) && !(message.storeSize && $util.isInteger(message.storeSize.low) && $util.isInteger(message.storeSize.high)))
                        return "storeSize: integer|Long expected";
                return null;
            };

            /**
             * Creates a PartitionStats message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.PartitionStats
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.PartitionStats} PartitionStats
             */
            PartitionStats.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.PartitionStats)
                    return object;
                var message = new $root.Ydb.Table.PartitionStats();
                if (object.rowsEstimate != null)
                    if ($util.Long)
                        (message.rowsEstimate = $util.Long.fromValue(object.rowsEstimate)).unsigned = true;
                    else if (typeof object.rowsEstimate === "string")
                        message.rowsEstimate = parseInt(object.rowsEstimate, 10);
                    else if (typeof object.rowsEstimate === "number")
                        message.rowsEstimate = object.rowsEstimate;
                    else if (typeof object.rowsEstimate === "object")
                        message.rowsEstimate = new $util.LongBits(object.rowsEstimate.low >>> 0, object.rowsEstimate.high >>> 0).toNumber(true);
                if (object.storeSize != null)
                    if ($util.Long)
                        (message.storeSize = $util.Long.fromValue(object.storeSize)).unsigned = true;
                    else if (typeof object.storeSize === "string")
                        message.storeSize = parseInt(object.storeSize, 10);
                    else if (typeof object.storeSize === "number")
                        message.storeSize = object.storeSize;
                    else if (typeof object.storeSize === "object")
                        message.storeSize = new $util.LongBits(object.storeSize.low >>> 0, object.storeSize.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a PartitionStats message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.PartitionStats
             * @static
             * @param {Ydb.Table.PartitionStats} message PartitionStats
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PartitionStats.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.rowsEstimate = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.rowsEstimate = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.storeSize = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.storeSize = options.longs === String ? "0" : 0;
                }
                if (message.rowsEstimate != null && message.hasOwnProperty("rowsEstimate"))
                    if (typeof message.rowsEstimate === "number")
                        object.rowsEstimate = options.longs === String ? String(message.rowsEstimate) : message.rowsEstimate;
                    else
                        object.rowsEstimate = options.longs === String ? $util.Long.prototype.toString.call(message.rowsEstimate) : options.longs === Number ? new $util.LongBits(message.rowsEstimate.low >>> 0, message.rowsEstimate.high >>> 0).toNumber(true) : message.rowsEstimate;
                if (message.storeSize != null && message.hasOwnProperty("storeSize"))
                    if (typeof message.storeSize === "number")
                        object.storeSize = options.longs === String ? String(message.storeSize) : message.storeSize;
                    else
                        object.storeSize = options.longs === String ? $util.Long.prototype.toString.call(message.storeSize) : options.longs === Number ? new $util.LongBits(message.storeSize.low >>> 0, message.storeSize.high >>> 0).toNumber(true) : message.storeSize;
                return object;
            };

            /**
             * Converts this PartitionStats to JSON.
             * @function toJSON
             * @memberof Ydb.Table.PartitionStats
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PartitionStats.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return PartitionStats;
        })();

        Table.TableStats = (function() {

            /**
             * Properties of a TableStats.
             * @memberof Ydb.Table
             * @interface ITableStats
             * @property {Array.<Ydb.Table.IPartitionStats>|null} [partitionStats] TableStats partitionStats
             * @property {number|Long|null} [rowsEstimate] TableStats rowsEstimate
             * @property {number|Long|null} [storeSize] TableStats storeSize
             * @property {number|Long|null} [partitions] TableStats partitions
             * @property {google.protobuf.ITimestamp|null} [creationTime] TableStats creationTime
             * @property {google.protobuf.ITimestamp|null} [modificationTime] TableStats modificationTime
             */

            /**
             * Constructs a new TableStats.
             * @memberof Ydb.Table
             * @classdesc Represents a TableStats.
             * @implements ITableStats
             * @constructor
             * @param {Ydb.Table.ITableStats=} [properties] Properties to set
             */
            function TableStats(properties) {
                this.partitionStats = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * TableStats partitionStats.
             * @member {Array.<Ydb.Table.IPartitionStats>} partitionStats
             * @memberof Ydb.Table.TableStats
             * @instance
             */
            TableStats.prototype.partitionStats = $util.emptyArray;

            /**
             * TableStats rowsEstimate.
             * @member {number|Long} rowsEstimate
             * @memberof Ydb.Table.TableStats
             * @instance
             */
            TableStats.prototype.rowsEstimate = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * TableStats storeSize.
             * @member {number|Long} storeSize
             * @memberof Ydb.Table.TableStats
             * @instance
             */
            TableStats.prototype.storeSize = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * TableStats partitions.
             * @member {number|Long} partitions
             * @memberof Ydb.Table.TableStats
             * @instance
             */
            TableStats.prototype.partitions = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * TableStats creationTime.
             * @member {google.protobuf.ITimestamp|null|undefined} creationTime
             * @memberof Ydb.Table.TableStats
             * @instance
             */
            TableStats.prototype.creationTime = null;

            /**
             * TableStats modificationTime.
             * @member {google.protobuf.ITimestamp|null|undefined} modificationTime
             * @memberof Ydb.Table.TableStats
             * @instance
             */
            TableStats.prototype.modificationTime = null;

            /**
             * Creates a new TableStats instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.TableStats
             * @static
             * @param {Ydb.Table.ITableStats=} [properties] Properties to set
             * @returns {Ydb.Table.TableStats} TableStats instance
             */
            TableStats.create = function create(properties) {
                return new TableStats(properties);
            };

            /**
             * Encodes the specified TableStats message. Does not implicitly {@link Ydb.Table.TableStats.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.TableStats
             * @static
             * @param {Ydb.Table.ITableStats} message TableStats message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TableStats.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.partitionStats != null && message.partitionStats.length)
                    for (var i = 0; i < message.partitionStats.length; ++i)
                        $root.Ydb.Table.PartitionStats.encode(message.partitionStats[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.rowsEstimate != null && Object.hasOwnProperty.call(message, "rowsEstimate"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.rowsEstimate);
                if (message.storeSize != null && Object.hasOwnProperty.call(message, "storeSize"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.storeSize);
                if (message.partitions != null && Object.hasOwnProperty.call(message, "partitions"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.partitions);
                if (message.creationTime != null && Object.hasOwnProperty.call(message, "creationTime"))
                    $root.google.protobuf.Timestamp.encode(message.creationTime, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.modificationTime != null && Object.hasOwnProperty.call(message, "modificationTime"))
                    $root.google.protobuf.Timestamp.encode(message.modificationTime, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified TableStats message, length delimited. Does not implicitly {@link Ydb.Table.TableStats.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.TableStats
             * @static
             * @param {Ydb.Table.ITableStats} message TableStats message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TableStats.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a TableStats message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.TableStats
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.TableStats} TableStats
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TableStats.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.TableStats();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.partitionStats && message.partitionStats.length))
                            message.partitionStats = [];
                        message.partitionStats.push($root.Ydb.Table.PartitionStats.decode(reader, reader.uint32()));
                        break;
                    case 2:
                        message.rowsEstimate = reader.uint64();
                        break;
                    case 3:
                        message.storeSize = reader.uint64();
                        break;
                    case 4:
                        message.partitions = reader.uint64();
                        break;
                    case 5:
                        message.creationTime = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                        break;
                    case 6:
                        message.modificationTime = $root.google.protobuf.Timestamp.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a TableStats message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.TableStats
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.TableStats} TableStats
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TableStats.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a TableStats message.
             * @function verify
             * @memberof Ydb.Table.TableStats
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TableStats.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.partitionStats != null && message.hasOwnProperty("partitionStats")) {
                    if (!Array.isArray(message.partitionStats))
                        return "partitionStats: array expected";
                    for (var i = 0; i < message.partitionStats.length; ++i) {
                        var error = $root.Ydb.Table.PartitionStats.verify(message.partitionStats[i]);
                        if (error)
                            return "partitionStats." + error;
                    }
                }
                if (message.rowsEstimate != null && message.hasOwnProperty("rowsEstimate"))
                    if (!$util.isInteger(message.rowsEstimate) && !(message.rowsEstimate && $util.isInteger(message.rowsEstimate.low) && $util.isInteger(message.rowsEstimate.high)))
                        return "rowsEstimate: integer|Long expected";
                if (message.storeSize != null && message.hasOwnProperty("storeSize"))
                    if (!$util.isInteger(message.storeSize) && !(message.storeSize && $util.isInteger(message.storeSize.low) && $util.isInteger(message.storeSize.high)))
                        return "storeSize: integer|Long expected";
                if (message.partitions != null && message.hasOwnProperty("partitions"))
                    if (!$util.isInteger(message.partitions) && !(message.partitions && $util.isInteger(message.partitions.low) && $util.isInteger(message.partitions.high)))
                        return "partitions: integer|Long expected";
                if (message.creationTime != null && message.hasOwnProperty("creationTime")) {
                    var error = $root.google.protobuf.Timestamp.verify(message.creationTime);
                    if (error)
                        return "creationTime." + error;
                }
                if (message.modificationTime != null && message.hasOwnProperty("modificationTime")) {
                    var error = $root.google.protobuf.Timestamp.verify(message.modificationTime);
                    if (error)
                        return "modificationTime." + error;
                }
                return null;
            };

            /**
             * Creates a TableStats message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.TableStats
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.TableStats} TableStats
             */
            TableStats.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.TableStats)
                    return object;
                var message = new $root.Ydb.Table.TableStats();
                if (object.partitionStats) {
                    if (!Array.isArray(object.partitionStats))
                        throw TypeError(".Ydb.Table.TableStats.partitionStats: array expected");
                    message.partitionStats = [];
                    for (var i = 0; i < object.partitionStats.length; ++i) {
                        if (typeof object.partitionStats[i] !== "object")
                            throw TypeError(".Ydb.Table.TableStats.partitionStats: object expected");
                        message.partitionStats[i] = $root.Ydb.Table.PartitionStats.fromObject(object.partitionStats[i]);
                    }
                }
                if (object.rowsEstimate != null)
                    if ($util.Long)
                        (message.rowsEstimate = $util.Long.fromValue(object.rowsEstimate)).unsigned = true;
                    else if (typeof object.rowsEstimate === "string")
                        message.rowsEstimate = parseInt(object.rowsEstimate, 10);
                    else if (typeof object.rowsEstimate === "number")
                        message.rowsEstimate = object.rowsEstimate;
                    else if (typeof object.rowsEstimate === "object")
                        message.rowsEstimate = new $util.LongBits(object.rowsEstimate.low >>> 0, object.rowsEstimate.high >>> 0).toNumber(true);
                if (object.storeSize != null)
                    if ($util.Long)
                        (message.storeSize = $util.Long.fromValue(object.storeSize)).unsigned = true;
                    else if (typeof object.storeSize === "string")
                        message.storeSize = parseInt(object.storeSize, 10);
                    else if (typeof object.storeSize === "number")
                        message.storeSize = object.storeSize;
                    else if (typeof object.storeSize === "object")
                        message.storeSize = new $util.LongBits(object.storeSize.low >>> 0, object.storeSize.high >>> 0).toNumber(true);
                if (object.partitions != null)
                    if ($util.Long)
                        (message.partitions = $util.Long.fromValue(object.partitions)).unsigned = true;
                    else if (typeof object.partitions === "string")
                        message.partitions = parseInt(object.partitions, 10);
                    else if (typeof object.partitions === "number")
                        message.partitions = object.partitions;
                    else if (typeof object.partitions === "object")
                        message.partitions = new $util.LongBits(object.partitions.low >>> 0, object.partitions.high >>> 0).toNumber(true);
                if (object.creationTime != null) {
                    if (typeof object.creationTime !== "object")
                        throw TypeError(".Ydb.Table.TableStats.creationTime: object expected");
                    message.creationTime = $root.google.protobuf.Timestamp.fromObject(object.creationTime);
                }
                if (object.modificationTime != null) {
                    if (typeof object.modificationTime !== "object")
                        throw TypeError(".Ydb.Table.TableStats.modificationTime: object expected");
                    message.modificationTime = $root.google.protobuf.Timestamp.fromObject(object.modificationTime);
                }
                return message;
            };

            /**
             * Creates a plain object from a TableStats message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.TableStats
             * @static
             * @param {Ydb.Table.TableStats} message TableStats
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            TableStats.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.partitionStats = [];
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.rowsEstimate = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.rowsEstimate = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.storeSize = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.storeSize = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.partitions = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.partitions = options.longs === String ? "0" : 0;
                    object.creationTime = null;
                    object.modificationTime = null;
                }
                if (message.partitionStats && message.partitionStats.length) {
                    object.partitionStats = [];
                    for (var j = 0; j < message.partitionStats.length; ++j)
                        object.partitionStats[j] = $root.Ydb.Table.PartitionStats.toObject(message.partitionStats[j], options);
                }
                if (message.rowsEstimate != null && message.hasOwnProperty("rowsEstimate"))
                    if (typeof message.rowsEstimate === "number")
                        object.rowsEstimate = options.longs === String ? String(message.rowsEstimate) : message.rowsEstimate;
                    else
                        object.rowsEstimate = options.longs === String ? $util.Long.prototype.toString.call(message.rowsEstimate) : options.longs === Number ? new $util.LongBits(message.rowsEstimate.low >>> 0, message.rowsEstimate.high >>> 0).toNumber(true) : message.rowsEstimate;
                if (message.storeSize != null && message.hasOwnProperty("storeSize"))
                    if (typeof message.storeSize === "number")
                        object.storeSize = options.longs === String ? String(message.storeSize) : message.storeSize;
                    else
                        object.storeSize = options.longs === String ? $util.Long.prototype.toString.call(message.storeSize) : options.longs === Number ? new $util.LongBits(message.storeSize.low >>> 0, message.storeSize.high >>> 0).toNumber(true) : message.storeSize;
                if (message.partitions != null && message.hasOwnProperty("partitions"))
                    if (typeof message.partitions === "number")
                        object.partitions = options.longs === String ? String(message.partitions) : message.partitions;
                    else
                        object.partitions = options.longs === String ? $util.Long.prototype.toString.call(message.partitions) : options.longs === Number ? new $util.LongBits(message.partitions.low >>> 0, message.partitions.high >>> 0).toNumber(true) : message.partitions;
                if (message.creationTime != null && message.hasOwnProperty("creationTime"))
                    object.creationTime = $root.google.protobuf.Timestamp.toObject(message.creationTime, options);
                if (message.modificationTime != null && message.hasOwnProperty("modificationTime"))
                    object.modificationTime = $root.google.protobuf.Timestamp.toObject(message.modificationTime, options);
                return object;
            };

            /**
             * Converts this TableStats to JSON.
             * @function toJSON
             * @memberof Ydb.Table.TableStats
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            TableStats.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return TableStats;
        })();

        Table.PartitioningPolicy = (function() {

            /**
             * Properties of a PartitioningPolicy.
             * @memberof Ydb.Table
             * @interface IPartitioningPolicy
             * @property {string|null} [presetName] PartitioningPolicy presetName
             * @property {Ydb.Table.PartitioningPolicy.AutoPartitioningPolicy|null} [autoPartitioning] PartitioningPolicy autoPartitioning
             * @property {number|Long|null} [uniformPartitions] PartitioningPolicy uniformPartitions
             * @property {Ydb.Table.IExplicitPartitions|null} [explicitPartitions] PartitioningPolicy explicitPartitions
             */

            /**
             * Constructs a new PartitioningPolicy.
             * @memberof Ydb.Table
             * @classdesc Represents a PartitioningPolicy.
             * @implements IPartitioningPolicy
             * @constructor
             * @param {Ydb.Table.IPartitioningPolicy=} [properties] Properties to set
             */
            function PartitioningPolicy(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PartitioningPolicy presetName.
             * @member {string} presetName
             * @memberof Ydb.Table.PartitioningPolicy
             * @instance
             */
            PartitioningPolicy.prototype.presetName = "";

            /**
             * PartitioningPolicy autoPartitioning.
             * @member {Ydb.Table.PartitioningPolicy.AutoPartitioningPolicy} autoPartitioning
             * @memberof Ydb.Table.PartitioningPolicy
             * @instance
             */
            PartitioningPolicy.prototype.autoPartitioning = 0;

            /**
             * PartitioningPolicy uniformPartitions.
             * @member {number|Long|null|undefined} uniformPartitions
             * @memberof Ydb.Table.PartitioningPolicy
             * @instance
             */
            PartitioningPolicy.prototype.uniformPartitions = null;

            /**
             * PartitioningPolicy explicitPartitions.
             * @member {Ydb.Table.IExplicitPartitions|null|undefined} explicitPartitions
             * @memberof Ydb.Table.PartitioningPolicy
             * @instance
             */
            PartitioningPolicy.prototype.explicitPartitions = null;

            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;

            /**
             * PartitioningPolicy partitions.
             * @member {"uniformPartitions"|"explicitPartitions"|undefined} partitions
             * @memberof Ydb.Table.PartitioningPolicy
             * @instance
             */
            Object.defineProperty(PartitioningPolicy.prototype, "partitions", {
                get: $util.oneOfGetter($oneOfFields = ["uniformPartitions", "explicitPartitions"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new PartitioningPolicy instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.PartitioningPolicy
             * @static
             * @param {Ydb.Table.IPartitioningPolicy=} [properties] Properties to set
             * @returns {Ydb.Table.PartitioningPolicy} PartitioningPolicy instance
             */
            PartitioningPolicy.create = function create(properties) {
                return new PartitioningPolicy(properties);
            };

            /**
             * Encodes the specified PartitioningPolicy message. Does not implicitly {@link Ydb.Table.PartitioningPolicy.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.PartitioningPolicy
             * @static
             * @param {Ydb.Table.IPartitioningPolicy} message PartitioningPolicy message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PartitioningPolicy.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.presetName != null && Object.hasOwnProperty.call(message, "presetName"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.presetName);
                if (message.autoPartitioning != null && Object.hasOwnProperty.call(message, "autoPartitioning"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.autoPartitioning);
                if (message.uniformPartitions != null && Object.hasOwnProperty.call(message, "uniformPartitions"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.uniformPartitions);
                if (message.explicitPartitions != null && Object.hasOwnProperty.call(message, "explicitPartitions"))
                    $root.Ydb.Table.ExplicitPartitions.encode(message.explicitPartitions, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified PartitioningPolicy message, length delimited. Does not implicitly {@link Ydb.Table.PartitioningPolicy.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.PartitioningPolicy
             * @static
             * @param {Ydb.Table.IPartitioningPolicy} message PartitioningPolicy message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PartitioningPolicy.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PartitioningPolicy message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.PartitioningPolicy
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.PartitioningPolicy} PartitioningPolicy
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PartitioningPolicy.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.PartitioningPolicy();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.presetName = reader.string();
                        break;
                    case 2:
                        message.autoPartitioning = reader.int32();
                        break;
                    case 3:
                        message.uniformPartitions = reader.uint64();
                        break;
                    case 4:
                        message.explicitPartitions = $root.Ydb.Table.ExplicitPartitions.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a PartitioningPolicy message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.PartitioningPolicy
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.PartitioningPolicy} PartitioningPolicy
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PartitioningPolicy.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PartitioningPolicy message.
             * @function verify
             * @memberof Ydb.Table.PartitioningPolicy
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PartitioningPolicy.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.presetName != null && message.hasOwnProperty("presetName"))
                    if (!$util.isString(message.presetName))
                        return "presetName: string expected";
                if (message.autoPartitioning != null && message.hasOwnProperty("autoPartitioning"))
                    switch (message.autoPartitioning) {
                    default:
                        return "autoPartitioning: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                        break;
                    }
                if (message.uniformPartitions != null && message.hasOwnProperty("uniformPartitions")) {
                    properties.partitions = 1;
                    if (!$util.isInteger(message.uniformPartitions) && !(message.uniformPartitions && $util.isInteger(message.uniformPartitions.low) && $util.isInteger(message.uniformPartitions.high)))
                        return "uniformPartitions: integer|Long expected";
                }
                if (message.explicitPartitions != null && message.hasOwnProperty("explicitPartitions")) {
                    if (properties.partitions === 1)
                        return "partitions: multiple values";
                    properties.partitions = 1;
                    {
                        var error = $root.Ydb.Table.ExplicitPartitions.verify(message.explicitPartitions);
                        if (error)
                            return "explicitPartitions." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a PartitioningPolicy message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.PartitioningPolicy
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.PartitioningPolicy} PartitioningPolicy
             */
            PartitioningPolicy.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.PartitioningPolicy)
                    return object;
                var message = new $root.Ydb.Table.PartitioningPolicy();
                if (object.presetName != null)
                    message.presetName = String(object.presetName);
                switch (object.autoPartitioning) {
                case "AUTO_PARTITIONING_POLICY_UNSPECIFIED":
                case 0:
                    message.autoPartitioning = 0;
                    break;
                case "DISABLED":
                case 1:
                    message.autoPartitioning = 1;
                    break;
                case "AUTO_SPLIT":
                case 2:
                    message.autoPartitioning = 2;
                    break;
                case "AUTO_SPLIT_MERGE":
                case 3:
                    message.autoPartitioning = 3;
                    break;
                }
                if (object.uniformPartitions != null)
                    if ($util.Long)
                        (message.uniformPartitions = $util.Long.fromValue(object.uniformPartitions)).unsigned = true;
                    else if (typeof object.uniformPartitions === "string")
                        message.uniformPartitions = parseInt(object.uniformPartitions, 10);
                    else if (typeof object.uniformPartitions === "number")
                        message.uniformPartitions = object.uniformPartitions;
                    else if (typeof object.uniformPartitions === "object")
                        message.uniformPartitions = new $util.LongBits(object.uniformPartitions.low >>> 0, object.uniformPartitions.high >>> 0).toNumber(true);
                if (object.explicitPartitions != null) {
                    if (typeof object.explicitPartitions !== "object")
                        throw TypeError(".Ydb.Table.PartitioningPolicy.explicitPartitions: object expected");
                    message.explicitPartitions = $root.Ydb.Table.ExplicitPartitions.fromObject(object.explicitPartitions);
                }
                return message;
            };

            /**
             * Creates a plain object from a PartitioningPolicy message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.PartitioningPolicy
             * @static
             * @param {Ydb.Table.PartitioningPolicy} message PartitioningPolicy
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PartitioningPolicy.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.presetName = "";
                    object.autoPartitioning = options.enums === String ? "AUTO_PARTITIONING_POLICY_UNSPECIFIED" : 0;
                }
                if (message.presetName != null && message.hasOwnProperty("presetName"))
                    object.presetName = message.presetName;
                if (message.autoPartitioning != null && message.hasOwnProperty("autoPartitioning"))
                    object.autoPartitioning = options.enums === String ? $root.Ydb.Table.PartitioningPolicy.AutoPartitioningPolicy[message.autoPartitioning] : message.autoPartitioning;
                if (message.uniformPartitions != null && message.hasOwnProperty("uniformPartitions")) {
                    if (typeof message.uniformPartitions === "number")
                        object.uniformPartitions = options.longs === String ? String(message.uniformPartitions) : message.uniformPartitions;
                    else
                        object.uniformPartitions = options.longs === String ? $util.Long.prototype.toString.call(message.uniformPartitions) : options.longs === Number ? new $util.LongBits(message.uniformPartitions.low >>> 0, message.uniformPartitions.high >>> 0).toNumber(true) : message.uniformPartitions;
                    if (options.oneofs)
                        object.partitions = "uniformPartitions";
                }
                if (message.explicitPartitions != null && message.hasOwnProperty("explicitPartitions")) {
                    object.explicitPartitions = $root.Ydb.Table.ExplicitPartitions.toObject(message.explicitPartitions, options);
                    if (options.oneofs)
                        object.partitions = "explicitPartitions";
                }
                return object;
            };

            /**
             * Converts this PartitioningPolicy to JSON.
             * @function toJSON
             * @memberof Ydb.Table.PartitioningPolicy
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PartitioningPolicy.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * AutoPartitioningPolicy enum.
             * @name Ydb.Table.PartitioningPolicy.AutoPartitioningPolicy
             * @enum {number}
             * @property {number} AUTO_PARTITIONING_POLICY_UNSPECIFIED=0 AUTO_PARTITIONING_POLICY_UNSPECIFIED value
             * @property {number} DISABLED=1 DISABLED value
             * @property {number} AUTO_SPLIT=2 AUTO_SPLIT value
             * @property {number} AUTO_SPLIT_MERGE=3 AUTO_SPLIT_MERGE value
             */
            PartitioningPolicy.AutoPartitioningPolicy = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "AUTO_PARTITIONING_POLICY_UNSPECIFIED"] = 0;
                values[valuesById[1] = "DISABLED"] = 1;
                values[valuesById[2] = "AUTO_SPLIT"] = 2;
                values[valuesById[3] = "AUTO_SPLIT_MERGE"] = 3;
                return values;
            })();

            return PartitioningPolicy;
        })();

        Table.ExecutionPolicy = (function() {

            /**
             * Properties of an ExecutionPolicy.
             * @memberof Ydb.Table
             * @interface IExecutionPolicy
             * @property {string|null} [presetName] ExecutionPolicy presetName
             */

            /**
             * Constructs a new ExecutionPolicy.
             * @memberof Ydb.Table
             * @classdesc Represents an ExecutionPolicy.
             * @implements IExecutionPolicy
             * @constructor
             * @param {Ydb.Table.IExecutionPolicy=} [properties] Properties to set
             */
            function ExecutionPolicy(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ExecutionPolicy presetName.
             * @member {string} presetName
             * @memberof Ydb.Table.ExecutionPolicy
             * @instance
             */
            ExecutionPolicy.prototype.presetName = "";

            /**
             * Creates a new ExecutionPolicy instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.ExecutionPolicy
             * @static
             * @param {Ydb.Table.IExecutionPolicy=} [properties] Properties to set
             * @returns {Ydb.Table.ExecutionPolicy} ExecutionPolicy instance
             */
            ExecutionPolicy.create = function create(properties) {
                return new ExecutionPolicy(properties);
            };

            /**
             * Encodes the specified ExecutionPolicy message. Does not implicitly {@link Ydb.Table.ExecutionPolicy.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.ExecutionPolicy
             * @static
             * @param {Ydb.Table.IExecutionPolicy} message ExecutionPolicy message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExecutionPolicy.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.presetName != null && Object.hasOwnProperty.call(message, "presetName"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.presetName);
                return writer;
            };

            /**
             * Encodes the specified ExecutionPolicy message, length delimited. Does not implicitly {@link Ydb.Table.ExecutionPolicy.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.ExecutionPolicy
             * @static
             * @param {Ydb.Table.IExecutionPolicy} message ExecutionPolicy message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExecutionPolicy.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ExecutionPolicy message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.ExecutionPolicy
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.ExecutionPolicy} ExecutionPolicy
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExecutionPolicy.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.ExecutionPolicy();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.presetName = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an ExecutionPolicy message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.ExecutionPolicy
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.ExecutionPolicy} ExecutionPolicy
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExecutionPolicy.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ExecutionPolicy message.
             * @function verify
             * @memberof Ydb.Table.ExecutionPolicy
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ExecutionPolicy.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.presetName != null && message.hasOwnProperty("presetName"))
                    if (!$util.isString(message.presetName))
                        return "presetName: string expected";
                return null;
            };

            /**
             * Creates an ExecutionPolicy message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.ExecutionPolicy
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.ExecutionPolicy} ExecutionPolicy
             */
            ExecutionPolicy.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.ExecutionPolicy)
                    return object;
                var message = new $root.Ydb.Table.ExecutionPolicy();
                if (object.presetName != null)
                    message.presetName = String(object.presetName);
                return message;
            };

            /**
             * Creates a plain object from an ExecutionPolicy message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.ExecutionPolicy
             * @static
             * @param {Ydb.Table.ExecutionPolicy} message ExecutionPolicy
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ExecutionPolicy.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.presetName = "";
                if (message.presetName != null && message.hasOwnProperty("presetName"))
                    object.presetName = message.presetName;
                return object;
            };

            /**
             * Converts this ExecutionPolicy to JSON.
             * @function toJSON
             * @memberof Ydb.Table.ExecutionPolicy
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ExecutionPolicy.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ExecutionPolicy;
        })();

        Table.ReplicationPolicy = (function() {

            /**
             * Properties of a ReplicationPolicy.
             * @memberof Ydb.Table
             * @interface IReplicationPolicy
             * @property {string|null} [presetName] ReplicationPolicy presetName
             * @property {number|null} [replicasCount] ReplicationPolicy replicasCount
             * @property {Ydb.FeatureFlag.Status|null} [createPerAvailabilityZone] ReplicationPolicy createPerAvailabilityZone
             * @property {Ydb.FeatureFlag.Status|null} [allowPromotion] ReplicationPolicy allowPromotion
             */

            /**
             * Constructs a new ReplicationPolicy.
             * @memberof Ydb.Table
             * @classdesc Represents a ReplicationPolicy.
             * @implements IReplicationPolicy
             * @constructor
             * @param {Ydb.Table.IReplicationPolicy=} [properties] Properties to set
             */
            function ReplicationPolicy(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ReplicationPolicy presetName.
             * @member {string} presetName
             * @memberof Ydb.Table.ReplicationPolicy
             * @instance
             */
            ReplicationPolicy.prototype.presetName = "";

            /**
             * ReplicationPolicy replicasCount.
             * @member {number} replicasCount
             * @memberof Ydb.Table.ReplicationPolicy
             * @instance
             */
            ReplicationPolicy.prototype.replicasCount = 0;

            /**
             * ReplicationPolicy createPerAvailabilityZone.
             * @member {Ydb.FeatureFlag.Status} createPerAvailabilityZone
             * @memberof Ydb.Table.ReplicationPolicy
             * @instance
             */
            ReplicationPolicy.prototype.createPerAvailabilityZone = 0;

            /**
             * ReplicationPolicy allowPromotion.
             * @member {Ydb.FeatureFlag.Status} allowPromotion
             * @memberof Ydb.Table.ReplicationPolicy
             * @instance
             */
            ReplicationPolicy.prototype.allowPromotion = 0;

            /**
             * Creates a new ReplicationPolicy instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.ReplicationPolicy
             * @static
             * @param {Ydb.Table.IReplicationPolicy=} [properties] Properties to set
             * @returns {Ydb.Table.ReplicationPolicy} ReplicationPolicy instance
             */
            ReplicationPolicy.create = function create(properties) {
                return new ReplicationPolicy(properties);
            };

            /**
             * Encodes the specified ReplicationPolicy message. Does not implicitly {@link Ydb.Table.ReplicationPolicy.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.ReplicationPolicy
             * @static
             * @param {Ydb.Table.IReplicationPolicy} message ReplicationPolicy message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReplicationPolicy.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.presetName != null && Object.hasOwnProperty.call(message, "presetName"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.presetName);
                if (message.replicasCount != null && Object.hasOwnProperty.call(message, "replicasCount"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.replicasCount);
                if (message.createPerAvailabilityZone != null && Object.hasOwnProperty.call(message, "createPerAvailabilityZone"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.createPerAvailabilityZone);
                if (message.allowPromotion != null && Object.hasOwnProperty.call(message, "allowPromotion"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.allowPromotion);
                return writer;
            };

            /**
             * Encodes the specified ReplicationPolicy message, length delimited. Does not implicitly {@link Ydb.Table.ReplicationPolicy.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.ReplicationPolicy
             * @static
             * @param {Ydb.Table.IReplicationPolicy} message ReplicationPolicy message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReplicationPolicy.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReplicationPolicy message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.ReplicationPolicy
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.ReplicationPolicy} ReplicationPolicy
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReplicationPolicy.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.ReplicationPolicy();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.presetName = reader.string();
                        break;
                    case 2:
                        message.replicasCount = reader.uint32();
                        break;
                    case 3:
                        message.createPerAvailabilityZone = reader.int32();
                        break;
                    case 4:
                        message.allowPromotion = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ReplicationPolicy message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.ReplicationPolicy
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.ReplicationPolicy} ReplicationPolicy
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReplicationPolicy.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReplicationPolicy message.
             * @function verify
             * @memberof Ydb.Table.ReplicationPolicy
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReplicationPolicy.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.presetName != null && message.hasOwnProperty("presetName"))
                    if (!$util.isString(message.presetName))
                        return "presetName: string expected";
                if (message.replicasCount != null && message.hasOwnProperty("replicasCount"))
                    if (!$util.isInteger(message.replicasCount))
                        return "replicasCount: integer expected";
                if (message.createPerAvailabilityZone != null && message.hasOwnProperty("createPerAvailabilityZone"))
                    switch (message.createPerAvailabilityZone) {
                    default:
                        return "createPerAvailabilityZone: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                if (message.allowPromotion != null && message.hasOwnProperty("allowPromotion"))
                    switch (message.allowPromotion) {
                    default:
                        return "allowPromotion: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                return null;
            };

            /**
             * Creates a ReplicationPolicy message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.ReplicationPolicy
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.ReplicationPolicy} ReplicationPolicy
             */
            ReplicationPolicy.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.ReplicationPolicy)
                    return object;
                var message = new $root.Ydb.Table.ReplicationPolicy();
                if (object.presetName != null)
                    message.presetName = String(object.presetName);
                if (object.replicasCount != null)
                    message.replicasCount = object.replicasCount >>> 0;
                switch (object.createPerAvailabilityZone) {
                case "STATUS_UNSPECIFIED":
                case 0:
                    message.createPerAvailabilityZone = 0;
                    break;
                case "ENABLED":
                case 1:
                    message.createPerAvailabilityZone = 1;
                    break;
                case "DISABLED":
                case 2:
                    message.createPerAvailabilityZone = 2;
                    break;
                }
                switch (object.allowPromotion) {
                case "STATUS_UNSPECIFIED":
                case 0:
                    message.allowPromotion = 0;
                    break;
                case "ENABLED":
                case 1:
                    message.allowPromotion = 1;
                    break;
                case "DISABLED":
                case 2:
                    message.allowPromotion = 2;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from a ReplicationPolicy message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.ReplicationPolicy
             * @static
             * @param {Ydb.Table.ReplicationPolicy} message ReplicationPolicy
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReplicationPolicy.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.presetName = "";
                    object.replicasCount = 0;
                    object.createPerAvailabilityZone = options.enums === String ? "STATUS_UNSPECIFIED" : 0;
                    object.allowPromotion = options.enums === String ? "STATUS_UNSPECIFIED" : 0;
                }
                if (message.presetName != null && message.hasOwnProperty("presetName"))
                    object.presetName = message.presetName;
                if (message.replicasCount != null && message.hasOwnProperty("replicasCount"))
                    object.replicasCount = message.replicasCount;
                if (message.createPerAvailabilityZone != null && message.hasOwnProperty("createPerAvailabilityZone"))
                    object.createPerAvailabilityZone = options.enums === String ? $root.Ydb.FeatureFlag.Status[message.createPerAvailabilityZone] : message.createPerAvailabilityZone;
                if (message.allowPromotion != null && message.hasOwnProperty("allowPromotion"))
                    object.allowPromotion = options.enums === String ? $root.Ydb.FeatureFlag.Status[message.allowPromotion] : message.allowPromotion;
                return object;
            };

            /**
             * Converts this ReplicationPolicy to JSON.
             * @function toJSON
             * @memberof Ydb.Table.ReplicationPolicy
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReplicationPolicy.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ReplicationPolicy;
        })();

        Table.CachingPolicy = (function() {

            /**
             * Properties of a CachingPolicy.
             * @memberof Ydb.Table
             * @interface ICachingPolicy
             * @property {string|null} [presetName] CachingPolicy presetName
             */

            /**
             * Constructs a new CachingPolicy.
             * @memberof Ydb.Table
             * @classdesc Represents a CachingPolicy.
             * @implements ICachingPolicy
             * @constructor
             * @param {Ydb.Table.ICachingPolicy=} [properties] Properties to set
             */
            function CachingPolicy(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CachingPolicy presetName.
             * @member {string} presetName
             * @memberof Ydb.Table.CachingPolicy
             * @instance
             */
            CachingPolicy.prototype.presetName = "";

            /**
             * Creates a new CachingPolicy instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.CachingPolicy
             * @static
             * @param {Ydb.Table.ICachingPolicy=} [properties] Properties to set
             * @returns {Ydb.Table.CachingPolicy} CachingPolicy instance
             */
            CachingPolicy.create = function create(properties) {
                return new CachingPolicy(properties);
            };

            /**
             * Encodes the specified CachingPolicy message. Does not implicitly {@link Ydb.Table.CachingPolicy.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.CachingPolicy
             * @static
             * @param {Ydb.Table.ICachingPolicy} message CachingPolicy message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CachingPolicy.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.presetName != null && Object.hasOwnProperty.call(message, "presetName"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.presetName);
                return writer;
            };

            /**
             * Encodes the specified CachingPolicy message, length delimited. Does not implicitly {@link Ydb.Table.CachingPolicy.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.CachingPolicy
             * @static
             * @param {Ydb.Table.ICachingPolicy} message CachingPolicy message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CachingPolicy.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CachingPolicy message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.CachingPolicy
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.CachingPolicy} CachingPolicy
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CachingPolicy.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.CachingPolicy();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.presetName = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a CachingPolicy message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.CachingPolicy
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.CachingPolicy} CachingPolicy
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CachingPolicy.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CachingPolicy message.
             * @function verify
             * @memberof Ydb.Table.CachingPolicy
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CachingPolicy.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.presetName != null && message.hasOwnProperty("presetName"))
                    if (!$util.isString(message.presetName))
                        return "presetName: string expected";
                return null;
            };

            /**
             * Creates a CachingPolicy message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.CachingPolicy
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.CachingPolicy} CachingPolicy
             */
            CachingPolicy.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.CachingPolicy)
                    return object;
                var message = new $root.Ydb.Table.CachingPolicy();
                if (object.presetName != null)
                    message.presetName = String(object.presetName);
                return message;
            };

            /**
             * Creates a plain object from a CachingPolicy message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.CachingPolicy
             * @static
             * @param {Ydb.Table.CachingPolicy} message CachingPolicy
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CachingPolicy.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.presetName = "";
                if (message.presetName != null && message.hasOwnProperty("presetName"))
                    object.presetName = message.presetName;
                return object;
            };

            /**
             * Converts this CachingPolicy to JSON.
             * @function toJSON
             * @memberof Ydb.Table.CachingPolicy
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CachingPolicy.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return CachingPolicy;
        })();

        Table.TableProfile = (function() {

            /**
             * Properties of a TableProfile.
             * @memberof Ydb.Table
             * @interface ITableProfile
             * @property {string|null} [presetName] TableProfile presetName
             * @property {Ydb.Table.IStoragePolicy|null} [storagePolicy] TableProfile storagePolicy
             * @property {Ydb.Table.ICompactionPolicy|null} [compactionPolicy] TableProfile compactionPolicy
             * @property {Ydb.Table.IPartitioningPolicy|null} [partitioningPolicy] TableProfile partitioningPolicy
             * @property {Ydb.Table.IExecutionPolicy|null} [executionPolicy] TableProfile executionPolicy
             * @property {Ydb.Table.IReplicationPolicy|null} [replicationPolicy] TableProfile replicationPolicy
             * @property {Ydb.Table.ICachingPolicy|null} [cachingPolicy] TableProfile cachingPolicy
             */

            /**
             * Constructs a new TableProfile.
             * @memberof Ydb.Table
             * @classdesc Represents a TableProfile.
             * @implements ITableProfile
             * @constructor
             * @param {Ydb.Table.ITableProfile=} [properties] Properties to set
             */
            function TableProfile(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * TableProfile presetName.
             * @member {string} presetName
             * @memberof Ydb.Table.TableProfile
             * @instance
             */
            TableProfile.prototype.presetName = "";

            /**
             * TableProfile storagePolicy.
             * @member {Ydb.Table.IStoragePolicy|null|undefined} storagePolicy
             * @memberof Ydb.Table.TableProfile
             * @instance
             */
            TableProfile.prototype.storagePolicy = null;

            /**
             * TableProfile compactionPolicy.
             * @member {Ydb.Table.ICompactionPolicy|null|undefined} compactionPolicy
             * @memberof Ydb.Table.TableProfile
             * @instance
             */
            TableProfile.prototype.compactionPolicy = null;

            /**
             * TableProfile partitioningPolicy.
             * @member {Ydb.Table.IPartitioningPolicy|null|undefined} partitioningPolicy
             * @memberof Ydb.Table.TableProfile
             * @instance
             */
            TableProfile.prototype.partitioningPolicy = null;

            /**
             * TableProfile executionPolicy.
             * @member {Ydb.Table.IExecutionPolicy|null|undefined} executionPolicy
             * @memberof Ydb.Table.TableProfile
             * @instance
             */
            TableProfile.prototype.executionPolicy = null;

            /**
             * TableProfile replicationPolicy.
             * @member {Ydb.Table.IReplicationPolicy|null|undefined} replicationPolicy
             * @memberof Ydb.Table.TableProfile
             * @instance
             */
            TableProfile.prototype.replicationPolicy = null;

            /**
             * TableProfile cachingPolicy.
             * @member {Ydb.Table.ICachingPolicy|null|undefined} cachingPolicy
             * @memberof Ydb.Table.TableProfile
             * @instance
             */
            TableProfile.prototype.cachingPolicy = null;

            /**
             * Creates a new TableProfile instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.TableProfile
             * @static
             * @param {Ydb.Table.ITableProfile=} [properties] Properties to set
             * @returns {Ydb.Table.TableProfile} TableProfile instance
             */
            TableProfile.create = function create(properties) {
                return new TableProfile(properties);
            };

            /**
             * Encodes the specified TableProfile message. Does not implicitly {@link Ydb.Table.TableProfile.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.TableProfile
             * @static
             * @param {Ydb.Table.ITableProfile} message TableProfile message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TableProfile.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.presetName != null && Object.hasOwnProperty.call(message, "presetName"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.presetName);
                if (message.storagePolicy != null && Object.hasOwnProperty.call(message, "storagePolicy"))
                    $root.Ydb.Table.StoragePolicy.encode(message.storagePolicy, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.compactionPolicy != null && Object.hasOwnProperty.call(message, "compactionPolicy"))
                    $root.Ydb.Table.CompactionPolicy.encode(message.compactionPolicy, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.partitioningPolicy != null && Object.hasOwnProperty.call(message, "partitioningPolicy"))
                    $root.Ydb.Table.PartitioningPolicy.encode(message.partitioningPolicy, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.executionPolicy != null && Object.hasOwnProperty.call(message, "executionPolicy"))
                    $root.Ydb.Table.ExecutionPolicy.encode(message.executionPolicy, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.replicationPolicy != null && Object.hasOwnProperty.call(message, "replicationPolicy"))
                    $root.Ydb.Table.ReplicationPolicy.encode(message.replicationPolicy, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.cachingPolicy != null && Object.hasOwnProperty.call(message, "cachingPolicy"))
                    $root.Ydb.Table.CachingPolicy.encode(message.cachingPolicy, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified TableProfile message, length delimited. Does not implicitly {@link Ydb.Table.TableProfile.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.TableProfile
             * @static
             * @param {Ydb.Table.ITableProfile} message TableProfile message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TableProfile.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a TableProfile message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.TableProfile
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.TableProfile} TableProfile
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TableProfile.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.TableProfile();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.presetName = reader.string();
                        break;
                    case 2:
                        message.storagePolicy = $root.Ydb.Table.StoragePolicy.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.compactionPolicy = $root.Ydb.Table.CompactionPolicy.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.partitioningPolicy = $root.Ydb.Table.PartitioningPolicy.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.executionPolicy = $root.Ydb.Table.ExecutionPolicy.decode(reader, reader.uint32());
                        break;
                    case 6:
                        message.replicationPolicy = $root.Ydb.Table.ReplicationPolicy.decode(reader, reader.uint32());
                        break;
                    case 7:
                        message.cachingPolicy = $root.Ydb.Table.CachingPolicy.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a TableProfile message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.TableProfile
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.TableProfile} TableProfile
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TableProfile.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a TableProfile message.
             * @function verify
             * @memberof Ydb.Table.TableProfile
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TableProfile.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.presetName != null && message.hasOwnProperty("presetName"))
                    if (!$util.isString(message.presetName))
                        return "presetName: string expected";
                if (message.storagePolicy != null && message.hasOwnProperty("storagePolicy")) {
                    var error = $root.Ydb.Table.StoragePolicy.verify(message.storagePolicy);
                    if (error)
                        return "storagePolicy." + error;
                }
                if (message.compactionPolicy != null && message.hasOwnProperty("compactionPolicy")) {
                    var error = $root.Ydb.Table.CompactionPolicy.verify(message.compactionPolicy);
                    if (error)
                        return "compactionPolicy." + error;
                }
                if (message.partitioningPolicy != null && message.hasOwnProperty("partitioningPolicy")) {
                    var error = $root.Ydb.Table.PartitioningPolicy.verify(message.partitioningPolicy);
                    if (error)
                        return "partitioningPolicy." + error;
                }
                if (message.executionPolicy != null && message.hasOwnProperty("executionPolicy")) {
                    var error = $root.Ydb.Table.ExecutionPolicy.verify(message.executionPolicy);
                    if (error)
                        return "executionPolicy." + error;
                }
                if (message.replicationPolicy != null && message.hasOwnProperty("replicationPolicy")) {
                    var error = $root.Ydb.Table.ReplicationPolicy.verify(message.replicationPolicy);
                    if (error)
                        return "replicationPolicy." + error;
                }
                if (message.cachingPolicy != null && message.hasOwnProperty("cachingPolicy")) {
                    var error = $root.Ydb.Table.CachingPolicy.verify(message.cachingPolicy);
                    if (error)
                        return "cachingPolicy." + error;
                }
                return null;
            };

            /**
             * Creates a TableProfile message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.TableProfile
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.TableProfile} TableProfile
             */
            TableProfile.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.TableProfile)
                    return object;
                var message = new $root.Ydb.Table.TableProfile();
                if (object.presetName != null)
                    message.presetName = String(object.presetName);
                if (object.storagePolicy != null) {
                    if (typeof object.storagePolicy !== "object")
                        throw TypeError(".Ydb.Table.TableProfile.storagePolicy: object expected");
                    message.storagePolicy = $root.Ydb.Table.StoragePolicy.fromObject(object.storagePolicy);
                }
                if (object.compactionPolicy != null) {
                    if (typeof object.compactionPolicy !== "object")
                        throw TypeError(".Ydb.Table.TableProfile.compactionPolicy: object expected");
                    message.compactionPolicy = $root.Ydb.Table.CompactionPolicy.fromObject(object.compactionPolicy);
                }
                if (object.partitioningPolicy != null) {
                    if (typeof object.partitioningPolicy !== "object")
                        throw TypeError(".Ydb.Table.TableProfile.partitioningPolicy: object expected");
                    message.partitioningPolicy = $root.Ydb.Table.PartitioningPolicy.fromObject(object.partitioningPolicy);
                }
                if (object.executionPolicy != null) {
                    if (typeof object.executionPolicy !== "object")
                        throw TypeError(".Ydb.Table.TableProfile.executionPolicy: object expected");
                    message.executionPolicy = $root.Ydb.Table.ExecutionPolicy.fromObject(object.executionPolicy);
                }
                if (object.replicationPolicy != null) {
                    if (typeof object.replicationPolicy !== "object")
                        throw TypeError(".Ydb.Table.TableProfile.replicationPolicy: object expected");
                    message.replicationPolicy = $root.Ydb.Table.ReplicationPolicy.fromObject(object.replicationPolicy);
                }
                if (object.cachingPolicy != null) {
                    if (typeof object.cachingPolicy !== "object")
                        throw TypeError(".Ydb.Table.TableProfile.cachingPolicy: object expected");
                    message.cachingPolicy = $root.Ydb.Table.CachingPolicy.fromObject(object.cachingPolicy);
                }
                return message;
            };

            /**
             * Creates a plain object from a TableProfile message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.TableProfile
             * @static
             * @param {Ydb.Table.TableProfile} message TableProfile
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            TableProfile.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.presetName = "";
                    object.storagePolicy = null;
                    object.compactionPolicy = null;
                    object.partitioningPolicy = null;
                    object.executionPolicy = null;
                    object.replicationPolicy = null;
                    object.cachingPolicy = null;
                }
                if (message.presetName != null && message.hasOwnProperty("presetName"))
                    object.presetName = message.presetName;
                if (message.storagePolicy != null && message.hasOwnProperty("storagePolicy"))
                    object.storagePolicy = $root.Ydb.Table.StoragePolicy.toObject(message.storagePolicy, options);
                if (message.compactionPolicy != null && message.hasOwnProperty("compactionPolicy"))
                    object.compactionPolicy = $root.Ydb.Table.CompactionPolicy.toObject(message.compactionPolicy, options);
                if (message.partitioningPolicy != null && message.hasOwnProperty("partitioningPolicy"))
                    object.partitioningPolicy = $root.Ydb.Table.PartitioningPolicy.toObject(message.partitioningPolicy, options);
                if (message.executionPolicy != null && message.hasOwnProperty("executionPolicy"))
                    object.executionPolicy = $root.Ydb.Table.ExecutionPolicy.toObject(message.executionPolicy, options);
                if (message.replicationPolicy != null && message.hasOwnProperty("replicationPolicy"))
                    object.replicationPolicy = $root.Ydb.Table.ReplicationPolicy.toObject(message.replicationPolicy, options);
                if (message.cachingPolicy != null && message.hasOwnProperty("cachingPolicy"))
                    object.cachingPolicy = $root.Ydb.Table.CachingPolicy.toObject(message.cachingPolicy, options);
                return object;
            };

            /**
             * Converts this TableProfile to JSON.
             * @function toJSON
             * @memberof Ydb.Table.TableProfile
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            TableProfile.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return TableProfile;
        })();

        Table.ColumnMeta = (function() {

            /**
             * Properties of a ColumnMeta.
             * @memberof Ydb.Table
             * @interface IColumnMeta
             * @property {string|null} [name] ColumnMeta name
             * @property {Ydb.IType|null} [type] ColumnMeta type
             * @property {string|null} [family] ColumnMeta family
             */

            /**
             * Constructs a new ColumnMeta.
             * @memberof Ydb.Table
             * @classdesc Represents a ColumnMeta.
             * @implements IColumnMeta
             * @constructor
             * @param {Ydb.Table.IColumnMeta=} [properties] Properties to set
             */
            function ColumnMeta(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ColumnMeta name.
             * @member {string} name
             * @memberof Ydb.Table.ColumnMeta
             * @instance
             */
            ColumnMeta.prototype.name = "";

            /**
             * ColumnMeta type.
             * @member {Ydb.IType|null|undefined} type
             * @memberof Ydb.Table.ColumnMeta
             * @instance
             */
            ColumnMeta.prototype.type = null;

            /**
             * ColumnMeta family.
             * @member {string} family
             * @memberof Ydb.Table.ColumnMeta
             * @instance
             */
            ColumnMeta.prototype.family = "";

            /**
             * Creates a new ColumnMeta instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.ColumnMeta
             * @static
             * @param {Ydb.Table.IColumnMeta=} [properties] Properties to set
             * @returns {Ydb.Table.ColumnMeta} ColumnMeta instance
             */
            ColumnMeta.create = function create(properties) {
                return new ColumnMeta(properties);
            };

            /**
             * Encodes the specified ColumnMeta message. Does not implicitly {@link Ydb.Table.ColumnMeta.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.ColumnMeta
             * @static
             * @param {Ydb.Table.IColumnMeta} message ColumnMeta message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ColumnMeta.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    $root.Ydb.Type.encode(message.type, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.family != null && Object.hasOwnProperty.call(message, "family"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.family);
                return writer;
            };

            /**
             * Encodes the specified ColumnMeta message, length delimited. Does not implicitly {@link Ydb.Table.ColumnMeta.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.ColumnMeta
             * @static
             * @param {Ydb.Table.IColumnMeta} message ColumnMeta message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ColumnMeta.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ColumnMeta message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.ColumnMeta
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.ColumnMeta} ColumnMeta
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ColumnMeta.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.ColumnMeta();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message.type = $root.Ydb.Type.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.family = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ColumnMeta message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.ColumnMeta
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.ColumnMeta} ColumnMeta
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ColumnMeta.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ColumnMeta message.
             * @function verify
             * @memberof Ydb.Table.ColumnMeta
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ColumnMeta.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.type != null && message.hasOwnProperty("type")) {
                    var error = $root.Ydb.Type.verify(message.type);
                    if (error)
                        return "type." + error;
                }
                if (message.family != null && message.hasOwnProperty("family"))
                    if (!$util.isString(message.family))
                        return "family: string expected";
                return null;
            };

            /**
             * Creates a ColumnMeta message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.ColumnMeta
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.ColumnMeta} ColumnMeta
             */
            ColumnMeta.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.ColumnMeta)
                    return object;
                var message = new $root.Ydb.Table.ColumnMeta();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.type != null) {
                    if (typeof object.type !== "object")
                        throw TypeError(".Ydb.Table.ColumnMeta.type: object expected");
                    message.type = $root.Ydb.Type.fromObject(object.type);
                }
                if (object.family != null)
                    message.family = String(object.family);
                return message;
            };

            /**
             * Creates a plain object from a ColumnMeta message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.ColumnMeta
             * @static
             * @param {Ydb.Table.ColumnMeta} message ColumnMeta
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ColumnMeta.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.name = "";
                    object.type = null;
                    object.family = "";
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = $root.Ydb.Type.toObject(message.type, options);
                if (message.family != null && message.hasOwnProperty("family"))
                    object.family = message.family;
                return object;
            };

            /**
             * Converts this ColumnMeta to JSON.
             * @function toJSON
             * @memberof Ydb.Table.ColumnMeta
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ColumnMeta.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ColumnMeta;
        })();

        Table.DateTypeColumnModeSettings = (function() {

            /**
             * Properties of a DateTypeColumnModeSettings.
             * @memberof Ydb.Table
             * @interface IDateTypeColumnModeSettings
             * @property {string|null} [columnName] DateTypeColumnModeSettings columnName
             * @property {number|null} [expireAfterSeconds] DateTypeColumnModeSettings expireAfterSeconds
             */

            /**
             * Constructs a new DateTypeColumnModeSettings.
             * @memberof Ydb.Table
             * @classdesc Represents a DateTypeColumnModeSettings.
             * @implements IDateTypeColumnModeSettings
             * @constructor
             * @param {Ydb.Table.IDateTypeColumnModeSettings=} [properties] Properties to set
             */
            function DateTypeColumnModeSettings(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DateTypeColumnModeSettings columnName.
             * @member {string} columnName
             * @memberof Ydb.Table.DateTypeColumnModeSettings
             * @instance
             */
            DateTypeColumnModeSettings.prototype.columnName = "";

            /**
             * DateTypeColumnModeSettings expireAfterSeconds.
             * @member {number} expireAfterSeconds
             * @memberof Ydb.Table.DateTypeColumnModeSettings
             * @instance
             */
            DateTypeColumnModeSettings.prototype.expireAfterSeconds = 0;

            /**
             * Creates a new DateTypeColumnModeSettings instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.DateTypeColumnModeSettings
             * @static
             * @param {Ydb.Table.IDateTypeColumnModeSettings=} [properties] Properties to set
             * @returns {Ydb.Table.DateTypeColumnModeSettings} DateTypeColumnModeSettings instance
             */
            DateTypeColumnModeSettings.create = function create(properties) {
                return new DateTypeColumnModeSettings(properties);
            };

            /**
             * Encodes the specified DateTypeColumnModeSettings message. Does not implicitly {@link Ydb.Table.DateTypeColumnModeSettings.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.DateTypeColumnModeSettings
             * @static
             * @param {Ydb.Table.IDateTypeColumnModeSettings} message DateTypeColumnModeSettings message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DateTypeColumnModeSettings.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.columnName != null && Object.hasOwnProperty.call(message, "columnName"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.columnName);
                if (message.expireAfterSeconds != null && Object.hasOwnProperty.call(message, "expireAfterSeconds"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.expireAfterSeconds);
                return writer;
            };

            /**
             * Encodes the specified DateTypeColumnModeSettings message, length delimited. Does not implicitly {@link Ydb.Table.DateTypeColumnModeSettings.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.DateTypeColumnModeSettings
             * @static
             * @param {Ydb.Table.IDateTypeColumnModeSettings} message DateTypeColumnModeSettings message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DateTypeColumnModeSettings.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DateTypeColumnModeSettings message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.DateTypeColumnModeSettings
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.DateTypeColumnModeSettings} DateTypeColumnModeSettings
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DateTypeColumnModeSettings.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.DateTypeColumnModeSettings();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.columnName = reader.string();
                        break;
                    case 2:
                        message.expireAfterSeconds = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DateTypeColumnModeSettings message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.DateTypeColumnModeSettings
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.DateTypeColumnModeSettings} DateTypeColumnModeSettings
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DateTypeColumnModeSettings.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DateTypeColumnModeSettings message.
             * @function verify
             * @memberof Ydb.Table.DateTypeColumnModeSettings
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DateTypeColumnModeSettings.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.columnName != null && message.hasOwnProperty("columnName"))
                    if (!$util.isString(message.columnName))
                        return "columnName: string expected";
                if (message.expireAfterSeconds != null && message.hasOwnProperty("expireAfterSeconds"))
                    if (!$util.isInteger(message.expireAfterSeconds))
                        return "expireAfterSeconds: integer expected";
                return null;
            };

            /**
             * Creates a DateTypeColumnModeSettings message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.DateTypeColumnModeSettings
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.DateTypeColumnModeSettings} DateTypeColumnModeSettings
             */
            DateTypeColumnModeSettings.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.DateTypeColumnModeSettings)
                    return object;
                var message = new $root.Ydb.Table.DateTypeColumnModeSettings();
                if (object.columnName != null)
                    message.columnName = String(object.columnName);
                if (object.expireAfterSeconds != null)
                    message.expireAfterSeconds = object.expireAfterSeconds >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a DateTypeColumnModeSettings message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.DateTypeColumnModeSettings
             * @static
             * @param {Ydb.Table.DateTypeColumnModeSettings} message DateTypeColumnModeSettings
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DateTypeColumnModeSettings.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.columnName = "";
                    object.expireAfterSeconds = 0;
                }
                if (message.columnName != null && message.hasOwnProperty("columnName"))
                    object.columnName = message.columnName;
                if (message.expireAfterSeconds != null && message.hasOwnProperty("expireAfterSeconds"))
                    object.expireAfterSeconds = message.expireAfterSeconds;
                return object;
            };

            /**
             * Converts this DateTypeColumnModeSettings to JSON.
             * @function toJSON
             * @memberof Ydb.Table.DateTypeColumnModeSettings
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DateTypeColumnModeSettings.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DateTypeColumnModeSettings;
        })();

        Table.ValueSinceUnixEpochModeSettings = (function() {

            /**
             * Properties of a ValueSinceUnixEpochModeSettings.
             * @memberof Ydb.Table
             * @interface IValueSinceUnixEpochModeSettings
             * @property {string|null} [columnName] ValueSinceUnixEpochModeSettings columnName
             * @property {Ydb.Table.ValueSinceUnixEpochModeSettings.Unit|null} [columnUnit] ValueSinceUnixEpochModeSettings columnUnit
             * @property {number|null} [expireAfterSeconds] ValueSinceUnixEpochModeSettings expireAfterSeconds
             */

            /**
             * Constructs a new ValueSinceUnixEpochModeSettings.
             * @memberof Ydb.Table
             * @classdesc Represents a ValueSinceUnixEpochModeSettings.
             * @implements IValueSinceUnixEpochModeSettings
             * @constructor
             * @param {Ydb.Table.IValueSinceUnixEpochModeSettings=} [properties] Properties to set
             */
            function ValueSinceUnixEpochModeSettings(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ValueSinceUnixEpochModeSettings columnName.
             * @member {string} columnName
             * @memberof Ydb.Table.ValueSinceUnixEpochModeSettings
             * @instance
             */
            ValueSinceUnixEpochModeSettings.prototype.columnName = "";

            /**
             * ValueSinceUnixEpochModeSettings columnUnit.
             * @member {Ydb.Table.ValueSinceUnixEpochModeSettings.Unit} columnUnit
             * @memberof Ydb.Table.ValueSinceUnixEpochModeSettings
             * @instance
             */
            ValueSinceUnixEpochModeSettings.prototype.columnUnit = 0;

            /**
             * ValueSinceUnixEpochModeSettings expireAfterSeconds.
             * @member {number} expireAfterSeconds
             * @memberof Ydb.Table.ValueSinceUnixEpochModeSettings
             * @instance
             */
            ValueSinceUnixEpochModeSettings.prototype.expireAfterSeconds = 0;

            /**
             * Creates a new ValueSinceUnixEpochModeSettings instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.ValueSinceUnixEpochModeSettings
             * @static
             * @param {Ydb.Table.IValueSinceUnixEpochModeSettings=} [properties] Properties to set
             * @returns {Ydb.Table.ValueSinceUnixEpochModeSettings} ValueSinceUnixEpochModeSettings instance
             */
            ValueSinceUnixEpochModeSettings.create = function create(properties) {
                return new ValueSinceUnixEpochModeSettings(properties);
            };

            /**
             * Encodes the specified ValueSinceUnixEpochModeSettings message. Does not implicitly {@link Ydb.Table.ValueSinceUnixEpochModeSettings.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.ValueSinceUnixEpochModeSettings
             * @static
             * @param {Ydb.Table.IValueSinceUnixEpochModeSettings} message ValueSinceUnixEpochModeSettings message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ValueSinceUnixEpochModeSettings.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.columnName != null && Object.hasOwnProperty.call(message, "columnName"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.columnName);
                if (message.columnUnit != null && Object.hasOwnProperty.call(message, "columnUnit"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.columnUnit);
                if (message.expireAfterSeconds != null && Object.hasOwnProperty.call(message, "expireAfterSeconds"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.expireAfterSeconds);
                return writer;
            };

            /**
             * Encodes the specified ValueSinceUnixEpochModeSettings message, length delimited. Does not implicitly {@link Ydb.Table.ValueSinceUnixEpochModeSettings.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.ValueSinceUnixEpochModeSettings
             * @static
             * @param {Ydb.Table.IValueSinceUnixEpochModeSettings} message ValueSinceUnixEpochModeSettings message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ValueSinceUnixEpochModeSettings.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ValueSinceUnixEpochModeSettings message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.ValueSinceUnixEpochModeSettings
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.ValueSinceUnixEpochModeSettings} ValueSinceUnixEpochModeSettings
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ValueSinceUnixEpochModeSettings.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.ValueSinceUnixEpochModeSettings();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.columnName = reader.string();
                        break;
                    case 2:
                        message.columnUnit = reader.int32();
                        break;
                    case 3:
                        message.expireAfterSeconds = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ValueSinceUnixEpochModeSettings message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.ValueSinceUnixEpochModeSettings
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.ValueSinceUnixEpochModeSettings} ValueSinceUnixEpochModeSettings
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ValueSinceUnixEpochModeSettings.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ValueSinceUnixEpochModeSettings message.
             * @function verify
             * @memberof Ydb.Table.ValueSinceUnixEpochModeSettings
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ValueSinceUnixEpochModeSettings.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.columnName != null && message.hasOwnProperty("columnName"))
                    if (!$util.isString(message.columnName))
                        return "columnName: string expected";
                if (message.columnUnit != null && message.hasOwnProperty("columnUnit"))
                    switch (message.columnUnit) {
                    default:
                        return "columnUnit: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                        break;
                    }
                if (message.expireAfterSeconds != null && message.hasOwnProperty("expireAfterSeconds"))
                    if (!$util.isInteger(message.expireAfterSeconds))
                        return "expireAfterSeconds: integer expected";
                return null;
            };

            /**
             * Creates a ValueSinceUnixEpochModeSettings message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.ValueSinceUnixEpochModeSettings
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.ValueSinceUnixEpochModeSettings} ValueSinceUnixEpochModeSettings
             */
            ValueSinceUnixEpochModeSettings.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.ValueSinceUnixEpochModeSettings)
                    return object;
                var message = new $root.Ydb.Table.ValueSinceUnixEpochModeSettings();
                if (object.columnName != null)
                    message.columnName = String(object.columnName);
                switch (object.columnUnit) {
                case "UNIT_UNSPECIFIED":
                case 0:
                    message.columnUnit = 0;
                    break;
                case "UNIT_SECONDS":
                case 1:
                    message.columnUnit = 1;
                    break;
                case "UNIT_MILLISECONDS":
                case 2:
                    message.columnUnit = 2;
                    break;
                case "UNIT_MICROSECONDS":
                case 3:
                    message.columnUnit = 3;
                    break;
                case "UNIT_NANOSECONDS":
                case 4:
                    message.columnUnit = 4;
                    break;
                }
                if (object.expireAfterSeconds != null)
                    message.expireAfterSeconds = object.expireAfterSeconds >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a ValueSinceUnixEpochModeSettings message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.ValueSinceUnixEpochModeSettings
             * @static
             * @param {Ydb.Table.ValueSinceUnixEpochModeSettings} message ValueSinceUnixEpochModeSettings
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ValueSinceUnixEpochModeSettings.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.columnName = "";
                    object.columnUnit = options.enums === String ? "UNIT_UNSPECIFIED" : 0;
                    object.expireAfterSeconds = 0;
                }
                if (message.columnName != null && message.hasOwnProperty("columnName"))
                    object.columnName = message.columnName;
                if (message.columnUnit != null && message.hasOwnProperty("columnUnit"))
                    object.columnUnit = options.enums === String ? $root.Ydb.Table.ValueSinceUnixEpochModeSettings.Unit[message.columnUnit] : message.columnUnit;
                if (message.expireAfterSeconds != null && message.hasOwnProperty("expireAfterSeconds"))
                    object.expireAfterSeconds = message.expireAfterSeconds;
                return object;
            };

            /**
             * Converts this ValueSinceUnixEpochModeSettings to JSON.
             * @function toJSON
             * @memberof Ydb.Table.ValueSinceUnixEpochModeSettings
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ValueSinceUnixEpochModeSettings.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Unit enum.
             * @name Ydb.Table.ValueSinceUnixEpochModeSettings.Unit
             * @enum {number}
             * @property {number} UNIT_UNSPECIFIED=0 UNIT_UNSPECIFIED value
             * @property {number} UNIT_SECONDS=1 UNIT_SECONDS value
             * @property {number} UNIT_MILLISECONDS=2 UNIT_MILLISECONDS value
             * @property {number} UNIT_MICROSECONDS=3 UNIT_MICROSECONDS value
             * @property {number} UNIT_NANOSECONDS=4 UNIT_NANOSECONDS value
             */
            ValueSinceUnixEpochModeSettings.Unit = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "UNIT_UNSPECIFIED"] = 0;
                values[valuesById[1] = "UNIT_SECONDS"] = 1;
                values[valuesById[2] = "UNIT_MILLISECONDS"] = 2;
                values[valuesById[3] = "UNIT_MICROSECONDS"] = 3;
                values[valuesById[4] = "UNIT_NANOSECONDS"] = 4;
                return values;
            })();

            return ValueSinceUnixEpochModeSettings;
        })();

        Table.TtlSettings = (function() {

            /**
             * Properties of a TtlSettings.
             * @memberof Ydb.Table
             * @interface ITtlSettings
             * @property {Ydb.Table.IDateTypeColumnModeSettings|null} [dateTypeColumn] TtlSettings dateTypeColumn
             * @property {Ydb.Table.IValueSinceUnixEpochModeSettings|null} [valueSinceUnixEpoch] TtlSettings valueSinceUnixEpoch
             */

            /**
             * Constructs a new TtlSettings.
             * @memberof Ydb.Table
             * @classdesc Represents a TtlSettings.
             * @implements ITtlSettings
             * @constructor
             * @param {Ydb.Table.ITtlSettings=} [properties] Properties to set
             */
            function TtlSettings(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * TtlSettings dateTypeColumn.
             * @member {Ydb.Table.IDateTypeColumnModeSettings|null|undefined} dateTypeColumn
             * @memberof Ydb.Table.TtlSettings
             * @instance
             */
            TtlSettings.prototype.dateTypeColumn = null;

            /**
             * TtlSettings valueSinceUnixEpoch.
             * @member {Ydb.Table.IValueSinceUnixEpochModeSettings|null|undefined} valueSinceUnixEpoch
             * @memberof Ydb.Table.TtlSettings
             * @instance
             */
            TtlSettings.prototype.valueSinceUnixEpoch = null;

            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;

            /**
             * TtlSettings mode.
             * @member {"dateTypeColumn"|"valueSinceUnixEpoch"|undefined} mode
             * @memberof Ydb.Table.TtlSettings
             * @instance
             */
            Object.defineProperty(TtlSettings.prototype, "mode", {
                get: $util.oneOfGetter($oneOfFields = ["dateTypeColumn", "valueSinceUnixEpoch"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new TtlSettings instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.TtlSettings
             * @static
             * @param {Ydb.Table.ITtlSettings=} [properties] Properties to set
             * @returns {Ydb.Table.TtlSettings} TtlSettings instance
             */
            TtlSettings.create = function create(properties) {
                return new TtlSettings(properties);
            };

            /**
             * Encodes the specified TtlSettings message. Does not implicitly {@link Ydb.Table.TtlSettings.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.TtlSettings
             * @static
             * @param {Ydb.Table.ITtlSettings} message TtlSettings message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TtlSettings.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.dateTypeColumn != null && Object.hasOwnProperty.call(message, "dateTypeColumn"))
                    $root.Ydb.Table.DateTypeColumnModeSettings.encode(message.dateTypeColumn, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.valueSinceUnixEpoch != null && Object.hasOwnProperty.call(message, "valueSinceUnixEpoch"))
                    $root.Ydb.Table.ValueSinceUnixEpochModeSettings.encode(message.valueSinceUnixEpoch, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified TtlSettings message, length delimited. Does not implicitly {@link Ydb.Table.TtlSettings.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.TtlSettings
             * @static
             * @param {Ydb.Table.ITtlSettings} message TtlSettings message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TtlSettings.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a TtlSettings message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.TtlSettings
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.TtlSettings} TtlSettings
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TtlSettings.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.TtlSettings();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.dateTypeColumn = $root.Ydb.Table.DateTypeColumnModeSettings.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.valueSinceUnixEpoch = $root.Ydb.Table.ValueSinceUnixEpochModeSettings.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a TtlSettings message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.TtlSettings
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.TtlSettings} TtlSettings
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TtlSettings.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a TtlSettings message.
             * @function verify
             * @memberof Ydb.Table.TtlSettings
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TtlSettings.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.dateTypeColumn != null && message.hasOwnProperty("dateTypeColumn")) {
                    properties.mode = 1;
                    {
                        var error = $root.Ydb.Table.DateTypeColumnModeSettings.verify(message.dateTypeColumn);
                        if (error)
                            return "dateTypeColumn." + error;
                    }
                }
                if (message.valueSinceUnixEpoch != null && message.hasOwnProperty("valueSinceUnixEpoch")) {
                    if (properties.mode === 1)
                        return "mode: multiple values";
                    properties.mode = 1;
                    {
                        var error = $root.Ydb.Table.ValueSinceUnixEpochModeSettings.verify(message.valueSinceUnixEpoch);
                        if (error)
                            return "valueSinceUnixEpoch." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a TtlSettings message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.TtlSettings
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.TtlSettings} TtlSettings
             */
            TtlSettings.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.TtlSettings)
                    return object;
                var message = new $root.Ydb.Table.TtlSettings();
                if (object.dateTypeColumn != null) {
                    if (typeof object.dateTypeColumn !== "object")
                        throw TypeError(".Ydb.Table.TtlSettings.dateTypeColumn: object expected");
                    message.dateTypeColumn = $root.Ydb.Table.DateTypeColumnModeSettings.fromObject(object.dateTypeColumn);
                }
                if (object.valueSinceUnixEpoch != null) {
                    if (typeof object.valueSinceUnixEpoch !== "object")
                        throw TypeError(".Ydb.Table.TtlSettings.valueSinceUnixEpoch: object expected");
                    message.valueSinceUnixEpoch = $root.Ydb.Table.ValueSinceUnixEpochModeSettings.fromObject(object.valueSinceUnixEpoch);
                }
                return message;
            };

            /**
             * Creates a plain object from a TtlSettings message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.TtlSettings
             * @static
             * @param {Ydb.Table.TtlSettings} message TtlSettings
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            TtlSettings.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (message.dateTypeColumn != null && message.hasOwnProperty("dateTypeColumn")) {
                    object.dateTypeColumn = $root.Ydb.Table.DateTypeColumnModeSettings.toObject(message.dateTypeColumn, options);
                    if (options.oneofs)
                        object.mode = "dateTypeColumn";
                }
                if (message.valueSinceUnixEpoch != null && message.hasOwnProperty("valueSinceUnixEpoch")) {
                    object.valueSinceUnixEpoch = $root.Ydb.Table.ValueSinceUnixEpochModeSettings.toObject(message.valueSinceUnixEpoch, options);
                    if (options.oneofs)
                        object.mode = "valueSinceUnixEpoch";
                }
                return object;
            };

            /**
             * Converts this TtlSettings to JSON.
             * @function toJSON
             * @memberof Ydb.Table.TtlSettings
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            TtlSettings.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return TtlSettings;
        })();

        Table.StorageSettings = (function() {

            /**
             * Properties of a StorageSettings.
             * @memberof Ydb.Table
             * @interface IStorageSettings
             * @property {Ydb.Table.IStoragePool|null} [tabletCommitLog0] StorageSettings tabletCommitLog0
             * @property {Ydb.Table.IStoragePool|null} [tabletCommitLog1] StorageSettings tabletCommitLog1
             * @property {Ydb.Table.IStoragePool|null} [external] StorageSettings external
             * @property {Ydb.FeatureFlag.Status|null} [storeExternalBlobs] StorageSettings storeExternalBlobs
             */

            /**
             * Constructs a new StorageSettings.
             * @memberof Ydb.Table
             * @classdesc Represents a StorageSettings.
             * @implements IStorageSettings
             * @constructor
             * @param {Ydb.Table.IStorageSettings=} [properties] Properties to set
             */
            function StorageSettings(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * StorageSettings tabletCommitLog0.
             * @member {Ydb.Table.IStoragePool|null|undefined} tabletCommitLog0
             * @memberof Ydb.Table.StorageSettings
             * @instance
             */
            StorageSettings.prototype.tabletCommitLog0 = null;

            /**
             * StorageSettings tabletCommitLog1.
             * @member {Ydb.Table.IStoragePool|null|undefined} tabletCommitLog1
             * @memberof Ydb.Table.StorageSettings
             * @instance
             */
            StorageSettings.prototype.tabletCommitLog1 = null;

            /**
             * StorageSettings external.
             * @member {Ydb.Table.IStoragePool|null|undefined} external
             * @memberof Ydb.Table.StorageSettings
             * @instance
             */
            StorageSettings.prototype.external = null;

            /**
             * StorageSettings storeExternalBlobs.
             * @member {Ydb.FeatureFlag.Status} storeExternalBlobs
             * @memberof Ydb.Table.StorageSettings
             * @instance
             */
            StorageSettings.prototype.storeExternalBlobs = 0;

            /**
             * Creates a new StorageSettings instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.StorageSettings
             * @static
             * @param {Ydb.Table.IStorageSettings=} [properties] Properties to set
             * @returns {Ydb.Table.StorageSettings} StorageSettings instance
             */
            StorageSettings.create = function create(properties) {
                return new StorageSettings(properties);
            };

            /**
             * Encodes the specified StorageSettings message. Does not implicitly {@link Ydb.Table.StorageSettings.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.StorageSettings
             * @static
             * @param {Ydb.Table.IStorageSettings} message StorageSettings message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StorageSettings.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.tabletCommitLog0 != null && Object.hasOwnProperty.call(message, "tabletCommitLog0"))
                    $root.Ydb.Table.StoragePool.encode(message.tabletCommitLog0, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.tabletCommitLog1 != null && Object.hasOwnProperty.call(message, "tabletCommitLog1"))
                    $root.Ydb.Table.StoragePool.encode(message.tabletCommitLog1, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.external != null && Object.hasOwnProperty.call(message, "external"))
                    $root.Ydb.Table.StoragePool.encode(message.external, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.storeExternalBlobs != null && Object.hasOwnProperty.call(message, "storeExternalBlobs"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.storeExternalBlobs);
                return writer;
            };

            /**
             * Encodes the specified StorageSettings message, length delimited. Does not implicitly {@link Ydb.Table.StorageSettings.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.StorageSettings
             * @static
             * @param {Ydb.Table.IStorageSettings} message StorageSettings message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StorageSettings.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a StorageSettings message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.StorageSettings
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.StorageSettings} StorageSettings
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StorageSettings.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.StorageSettings();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.tabletCommitLog0 = $root.Ydb.Table.StoragePool.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.tabletCommitLog1 = $root.Ydb.Table.StoragePool.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.external = $root.Ydb.Table.StoragePool.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.storeExternalBlobs = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a StorageSettings message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.StorageSettings
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.StorageSettings} StorageSettings
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StorageSettings.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a StorageSettings message.
             * @function verify
             * @memberof Ydb.Table.StorageSettings
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            StorageSettings.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.tabletCommitLog0 != null && message.hasOwnProperty("tabletCommitLog0")) {
                    var error = $root.Ydb.Table.StoragePool.verify(message.tabletCommitLog0);
                    if (error)
                        return "tabletCommitLog0." + error;
                }
                if (message.tabletCommitLog1 != null && message.hasOwnProperty("tabletCommitLog1")) {
                    var error = $root.Ydb.Table.StoragePool.verify(message.tabletCommitLog1);
                    if (error)
                        return "tabletCommitLog1." + error;
                }
                if (message.external != null && message.hasOwnProperty("external")) {
                    var error = $root.Ydb.Table.StoragePool.verify(message.external);
                    if (error)
                        return "external." + error;
                }
                if (message.storeExternalBlobs != null && message.hasOwnProperty("storeExternalBlobs"))
                    switch (message.storeExternalBlobs) {
                    default:
                        return "storeExternalBlobs: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                return null;
            };

            /**
             * Creates a StorageSettings message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.StorageSettings
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.StorageSettings} StorageSettings
             */
            StorageSettings.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.StorageSettings)
                    return object;
                var message = new $root.Ydb.Table.StorageSettings();
                if (object.tabletCommitLog0 != null) {
                    if (typeof object.tabletCommitLog0 !== "object")
                        throw TypeError(".Ydb.Table.StorageSettings.tabletCommitLog0: object expected");
                    message.tabletCommitLog0 = $root.Ydb.Table.StoragePool.fromObject(object.tabletCommitLog0);
                }
                if (object.tabletCommitLog1 != null) {
                    if (typeof object.tabletCommitLog1 !== "object")
                        throw TypeError(".Ydb.Table.StorageSettings.tabletCommitLog1: object expected");
                    message.tabletCommitLog1 = $root.Ydb.Table.StoragePool.fromObject(object.tabletCommitLog1);
                }
                if (object.external != null) {
                    if (typeof object.external !== "object")
                        throw TypeError(".Ydb.Table.StorageSettings.external: object expected");
                    message.external = $root.Ydb.Table.StoragePool.fromObject(object.external);
                }
                switch (object.storeExternalBlobs) {
                case "STATUS_UNSPECIFIED":
                case 0:
                    message.storeExternalBlobs = 0;
                    break;
                case "ENABLED":
                case 1:
                    message.storeExternalBlobs = 1;
                    break;
                case "DISABLED":
                case 2:
                    message.storeExternalBlobs = 2;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from a StorageSettings message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.StorageSettings
             * @static
             * @param {Ydb.Table.StorageSettings} message StorageSettings
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            StorageSettings.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.tabletCommitLog0 = null;
                    object.tabletCommitLog1 = null;
                    object.external = null;
                    object.storeExternalBlobs = options.enums === String ? "STATUS_UNSPECIFIED" : 0;
                }
                if (message.tabletCommitLog0 != null && message.hasOwnProperty("tabletCommitLog0"))
                    object.tabletCommitLog0 = $root.Ydb.Table.StoragePool.toObject(message.tabletCommitLog0, options);
                if (message.tabletCommitLog1 != null && message.hasOwnProperty("tabletCommitLog1"))
                    object.tabletCommitLog1 = $root.Ydb.Table.StoragePool.toObject(message.tabletCommitLog1, options);
                if (message.external != null && message.hasOwnProperty("external"))
                    object.external = $root.Ydb.Table.StoragePool.toObject(message.external, options);
                if (message.storeExternalBlobs != null && message.hasOwnProperty("storeExternalBlobs"))
                    object.storeExternalBlobs = options.enums === String ? $root.Ydb.FeatureFlag.Status[message.storeExternalBlobs] : message.storeExternalBlobs;
                return object;
            };

            /**
             * Converts this StorageSettings to JSON.
             * @function toJSON
             * @memberof Ydb.Table.StorageSettings
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            StorageSettings.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return StorageSettings;
        })();

        Table.ColumnFamily = (function() {

            /**
             * Properties of a ColumnFamily.
             * @memberof Ydb.Table
             * @interface IColumnFamily
             * @property {string|null} [name] ColumnFamily name
             * @property {Ydb.Table.IStoragePool|null} [data] ColumnFamily data
             * @property {Ydb.Table.ColumnFamily.Compression|null} [compression] ColumnFamily compression
             * @property {Ydb.FeatureFlag.Status|null} [keepInMemory] ColumnFamily keepInMemory
             */

            /**
             * Constructs a new ColumnFamily.
             * @memberof Ydb.Table
             * @classdesc Represents a ColumnFamily.
             * @implements IColumnFamily
             * @constructor
             * @param {Ydb.Table.IColumnFamily=} [properties] Properties to set
             */
            function ColumnFamily(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ColumnFamily name.
             * @member {string} name
             * @memberof Ydb.Table.ColumnFamily
             * @instance
             */
            ColumnFamily.prototype.name = "";

            /**
             * ColumnFamily data.
             * @member {Ydb.Table.IStoragePool|null|undefined} data
             * @memberof Ydb.Table.ColumnFamily
             * @instance
             */
            ColumnFamily.prototype.data = null;

            /**
             * ColumnFamily compression.
             * @member {Ydb.Table.ColumnFamily.Compression} compression
             * @memberof Ydb.Table.ColumnFamily
             * @instance
             */
            ColumnFamily.prototype.compression = 0;

            /**
             * ColumnFamily keepInMemory.
             * @member {Ydb.FeatureFlag.Status} keepInMemory
             * @memberof Ydb.Table.ColumnFamily
             * @instance
             */
            ColumnFamily.prototype.keepInMemory = 0;

            /**
             * Creates a new ColumnFamily instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.ColumnFamily
             * @static
             * @param {Ydb.Table.IColumnFamily=} [properties] Properties to set
             * @returns {Ydb.Table.ColumnFamily} ColumnFamily instance
             */
            ColumnFamily.create = function create(properties) {
                return new ColumnFamily(properties);
            };

            /**
             * Encodes the specified ColumnFamily message. Does not implicitly {@link Ydb.Table.ColumnFamily.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.ColumnFamily
             * @static
             * @param {Ydb.Table.IColumnFamily} message ColumnFamily message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ColumnFamily.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                    $root.Ydb.Table.StoragePool.encode(message.data, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.compression != null && Object.hasOwnProperty.call(message, "compression"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.compression);
                if (message.keepInMemory != null && Object.hasOwnProperty.call(message, "keepInMemory"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.keepInMemory);
                return writer;
            };

            /**
             * Encodes the specified ColumnFamily message, length delimited. Does not implicitly {@link Ydb.Table.ColumnFamily.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.ColumnFamily
             * @static
             * @param {Ydb.Table.IColumnFamily} message ColumnFamily message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ColumnFamily.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ColumnFamily message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.ColumnFamily
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.ColumnFamily} ColumnFamily
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ColumnFamily.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.ColumnFamily();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message.data = $root.Ydb.Table.StoragePool.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.compression = reader.int32();
                        break;
                    case 4:
                        message.keepInMemory = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ColumnFamily message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.ColumnFamily
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.ColumnFamily} ColumnFamily
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ColumnFamily.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ColumnFamily message.
             * @function verify
             * @memberof Ydb.Table.ColumnFamily
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ColumnFamily.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.data != null && message.hasOwnProperty("data")) {
                    var error = $root.Ydb.Table.StoragePool.verify(message.data);
                    if (error)
                        return "data." + error;
                }
                if (message.compression != null && message.hasOwnProperty("compression"))
                    switch (message.compression) {
                    default:
                        return "compression: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                if (message.keepInMemory != null && message.hasOwnProperty("keepInMemory"))
                    switch (message.keepInMemory) {
                    default:
                        return "keepInMemory: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                return null;
            };

            /**
             * Creates a ColumnFamily message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.ColumnFamily
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.ColumnFamily} ColumnFamily
             */
            ColumnFamily.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.ColumnFamily)
                    return object;
                var message = new $root.Ydb.Table.ColumnFamily();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.data != null) {
                    if (typeof object.data !== "object")
                        throw TypeError(".Ydb.Table.ColumnFamily.data: object expected");
                    message.data = $root.Ydb.Table.StoragePool.fromObject(object.data);
                }
                switch (object.compression) {
                case "COMPRESSION_UNSPECIFIED":
                case 0:
                    message.compression = 0;
                    break;
                case "COMPRESSION_NONE":
                case 1:
                    message.compression = 1;
                    break;
                case "COMPRESSION_LZ4":
                case 2:
                    message.compression = 2;
                    break;
                }
                switch (object.keepInMemory) {
                case "STATUS_UNSPECIFIED":
                case 0:
                    message.keepInMemory = 0;
                    break;
                case "ENABLED":
                case 1:
                    message.keepInMemory = 1;
                    break;
                case "DISABLED":
                case 2:
                    message.keepInMemory = 2;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from a ColumnFamily message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.ColumnFamily
             * @static
             * @param {Ydb.Table.ColumnFamily} message ColumnFamily
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ColumnFamily.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.name = "";
                    object.data = null;
                    object.compression = options.enums === String ? "COMPRESSION_UNSPECIFIED" : 0;
                    object.keepInMemory = options.enums === String ? "STATUS_UNSPECIFIED" : 0;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.data != null && message.hasOwnProperty("data"))
                    object.data = $root.Ydb.Table.StoragePool.toObject(message.data, options);
                if (message.compression != null && message.hasOwnProperty("compression"))
                    object.compression = options.enums === String ? $root.Ydb.Table.ColumnFamily.Compression[message.compression] : message.compression;
                if (message.keepInMemory != null && message.hasOwnProperty("keepInMemory"))
                    object.keepInMemory = options.enums === String ? $root.Ydb.FeatureFlag.Status[message.keepInMemory] : message.keepInMemory;
                return object;
            };

            /**
             * Converts this ColumnFamily to JSON.
             * @function toJSON
             * @memberof Ydb.Table.ColumnFamily
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ColumnFamily.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Compression enum.
             * @name Ydb.Table.ColumnFamily.Compression
             * @enum {number}
             * @property {number} COMPRESSION_UNSPECIFIED=0 COMPRESSION_UNSPECIFIED value
             * @property {number} COMPRESSION_NONE=1 COMPRESSION_NONE value
             * @property {number} COMPRESSION_LZ4=2 COMPRESSION_LZ4 value
             */
            ColumnFamily.Compression = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "COMPRESSION_UNSPECIFIED"] = 0;
                values[valuesById[1] = "COMPRESSION_NONE"] = 1;
                values[valuesById[2] = "COMPRESSION_LZ4"] = 2;
                return values;
            })();

            return ColumnFamily;
        })();

        Table.PartitioningSettings = (function() {

            /**
             * Properties of a PartitioningSettings.
             * @memberof Ydb.Table
             * @interface IPartitioningSettings
             * @property {Ydb.FeatureFlag.Status|null} [partitioningBySize] PartitioningSettings partitioningBySize
             * @property {number|Long|null} [partitionSizeMb] PartitioningSettings partitionSizeMb
             * @property {Ydb.FeatureFlag.Status|null} [partitioningByLoad] PartitioningSettings partitioningByLoad
             * @property {number|Long|null} [minPartitionsCount] PartitioningSettings minPartitionsCount
             * @property {number|Long|null} [maxPartitionsCount] PartitioningSettings maxPartitionsCount
             */

            /**
             * Constructs a new PartitioningSettings.
             * @memberof Ydb.Table
             * @classdesc Represents a PartitioningSettings.
             * @implements IPartitioningSettings
             * @constructor
             * @param {Ydb.Table.IPartitioningSettings=} [properties] Properties to set
             */
            function PartitioningSettings(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PartitioningSettings partitioningBySize.
             * @member {Ydb.FeatureFlag.Status} partitioningBySize
             * @memberof Ydb.Table.PartitioningSettings
             * @instance
             */
            PartitioningSettings.prototype.partitioningBySize = 0;

            /**
             * PartitioningSettings partitionSizeMb.
             * @member {number|Long} partitionSizeMb
             * @memberof Ydb.Table.PartitioningSettings
             * @instance
             */
            PartitioningSettings.prototype.partitionSizeMb = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * PartitioningSettings partitioningByLoad.
             * @member {Ydb.FeatureFlag.Status} partitioningByLoad
             * @memberof Ydb.Table.PartitioningSettings
             * @instance
             */
            PartitioningSettings.prototype.partitioningByLoad = 0;

            /**
             * PartitioningSettings minPartitionsCount.
             * @member {number|Long} minPartitionsCount
             * @memberof Ydb.Table.PartitioningSettings
             * @instance
             */
            PartitioningSettings.prototype.minPartitionsCount = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * PartitioningSettings maxPartitionsCount.
             * @member {number|Long} maxPartitionsCount
             * @memberof Ydb.Table.PartitioningSettings
             * @instance
             */
            PartitioningSettings.prototype.maxPartitionsCount = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Creates a new PartitioningSettings instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.PartitioningSettings
             * @static
             * @param {Ydb.Table.IPartitioningSettings=} [properties] Properties to set
             * @returns {Ydb.Table.PartitioningSettings} PartitioningSettings instance
             */
            PartitioningSettings.create = function create(properties) {
                return new PartitioningSettings(properties);
            };

            /**
             * Encodes the specified PartitioningSettings message. Does not implicitly {@link Ydb.Table.PartitioningSettings.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.PartitioningSettings
             * @static
             * @param {Ydb.Table.IPartitioningSettings} message PartitioningSettings message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PartitioningSettings.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.partitioningBySize != null && Object.hasOwnProperty.call(message, "partitioningBySize"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.partitioningBySize);
                if (message.partitionSizeMb != null && Object.hasOwnProperty.call(message, "partitionSizeMb"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.partitionSizeMb);
                if (message.partitioningByLoad != null && Object.hasOwnProperty.call(message, "partitioningByLoad"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.partitioningByLoad);
                if (message.minPartitionsCount != null && Object.hasOwnProperty.call(message, "minPartitionsCount"))
                    writer.uint32(/* id 6, wireType 0 =*/48).uint64(message.minPartitionsCount);
                if (message.maxPartitionsCount != null && Object.hasOwnProperty.call(message, "maxPartitionsCount"))
                    writer.uint32(/* id 7, wireType 0 =*/56).uint64(message.maxPartitionsCount);
                return writer;
            };

            /**
             * Encodes the specified PartitioningSettings message, length delimited. Does not implicitly {@link Ydb.Table.PartitioningSettings.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.PartitioningSettings
             * @static
             * @param {Ydb.Table.IPartitioningSettings} message PartitioningSettings message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PartitioningSettings.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PartitioningSettings message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.PartitioningSettings
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.PartitioningSettings} PartitioningSettings
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PartitioningSettings.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.PartitioningSettings();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 2:
                        message.partitioningBySize = reader.int32();
                        break;
                    case 3:
                        message.partitionSizeMb = reader.uint64();
                        break;
                    case 4:
                        message.partitioningByLoad = reader.int32();
                        break;
                    case 6:
                        message.minPartitionsCount = reader.uint64();
                        break;
                    case 7:
                        message.maxPartitionsCount = reader.uint64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a PartitioningSettings message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.PartitioningSettings
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.PartitioningSettings} PartitioningSettings
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PartitioningSettings.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PartitioningSettings message.
             * @function verify
             * @memberof Ydb.Table.PartitioningSettings
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PartitioningSettings.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.partitioningBySize != null && message.hasOwnProperty("partitioningBySize"))
                    switch (message.partitioningBySize) {
                    default:
                        return "partitioningBySize: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                if (message.partitionSizeMb != null && message.hasOwnProperty("partitionSizeMb"))
                    if (!$util.isInteger(message.partitionSizeMb) && !(message.partitionSizeMb && $util.isInteger(message.partitionSizeMb.low) && $util.isInteger(message.partitionSizeMb.high)))
                        return "partitionSizeMb: integer|Long expected";
                if (message.partitioningByLoad != null && message.hasOwnProperty("partitioningByLoad"))
                    switch (message.partitioningByLoad) {
                    default:
                        return "partitioningByLoad: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                if (message.minPartitionsCount != null && message.hasOwnProperty("minPartitionsCount"))
                    if (!$util.isInteger(message.minPartitionsCount) && !(message.minPartitionsCount && $util.isInteger(message.minPartitionsCount.low) && $util.isInteger(message.minPartitionsCount.high)))
                        return "minPartitionsCount: integer|Long expected";
                if (message.maxPartitionsCount != null && message.hasOwnProperty("maxPartitionsCount"))
                    if (!$util.isInteger(message.maxPartitionsCount) && !(message.maxPartitionsCount && $util.isInteger(message.maxPartitionsCount.low) && $util.isInteger(message.maxPartitionsCount.high)))
                        return "maxPartitionsCount: integer|Long expected";
                return null;
            };

            /**
             * Creates a PartitioningSettings message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.PartitioningSettings
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.PartitioningSettings} PartitioningSettings
             */
            PartitioningSettings.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.PartitioningSettings)
                    return object;
                var message = new $root.Ydb.Table.PartitioningSettings();
                switch (object.partitioningBySize) {
                case "STATUS_UNSPECIFIED":
                case 0:
                    message.partitioningBySize = 0;
                    break;
                case "ENABLED":
                case 1:
                    message.partitioningBySize = 1;
                    break;
                case "DISABLED":
                case 2:
                    message.partitioningBySize = 2;
                    break;
                }
                if (object.partitionSizeMb != null)
                    if ($util.Long)
                        (message.partitionSizeMb = $util.Long.fromValue(object.partitionSizeMb)).unsigned = true;
                    else if (typeof object.partitionSizeMb === "string")
                        message.partitionSizeMb = parseInt(object.partitionSizeMb, 10);
                    else if (typeof object.partitionSizeMb === "number")
                        message.partitionSizeMb = object.partitionSizeMb;
                    else if (typeof object.partitionSizeMb === "object")
                        message.partitionSizeMb = new $util.LongBits(object.partitionSizeMb.low >>> 0, object.partitionSizeMb.high >>> 0).toNumber(true);
                switch (object.partitioningByLoad) {
                case "STATUS_UNSPECIFIED":
                case 0:
                    message.partitioningByLoad = 0;
                    break;
                case "ENABLED":
                case 1:
                    message.partitioningByLoad = 1;
                    break;
                case "DISABLED":
                case 2:
                    message.partitioningByLoad = 2;
                    break;
                }
                if (object.minPartitionsCount != null)
                    if ($util.Long)
                        (message.minPartitionsCount = $util.Long.fromValue(object.minPartitionsCount)).unsigned = true;
                    else if (typeof object.minPartitionsCount === "string")
                        message.minPartitionsCount = parseInt(object.minPartitionsCount, 10);
                    else if (typeof object.minPartitionsCount === "number")
                        message.minPartitionsCount = object.minPartitionsCount;
                    else if (typeof object.minPartitionsCount === "object")
                        message.minPartitionsCount = new $util.LongBits(object.minPartitionsCount.low >>> 0, object.minPartitionsCount.high >>> 0).toNumber(true);
                if (object.maxPartitionsCount != null)
                    if ($util.Long)
                        (message.maxPartitionsCount = $util.Long.fromValue(object.maxPartitionsCount)).unsigned = true;
                    else if (typeof object.maxPartitionsCount === "string")
                        message.maxPartitionsCount = parseInt(object.maxPartitionsCount, 10);
                    else if (typeof object.maxPartitionsCount === "number")
                        message.maxPartitionsCount = object.maxPartitionsCount;
                    else if (typeof object.maxPartitionsCount === "object")
                        message.maxPartitionsCount = new $util.LongBits(object.maxPartitionsCount.low >>> 0, object.maxPartitionsCount.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a PartitioningSettings message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.PartitioningSettings
             * @static
             * @param {Ydb.Table.PartitioningSettings} message PartitioningSettings
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PartitioningSettings.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.partitioningBySize = options.enums === String ? "STATUS_UNSPECIFIED" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.partitionSizeMb = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.partitionSizeMb = options.longs === String ? "0" : 0;
                    object.partitioningByLoad = options.enums === String ? "STATUS_UNSPECIFIED" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.minPartitionsCount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.minPartitionsCount = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.maxPartitionsCount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.maxPartitionsCount = options.longs === String ? "0" : 0;
                }
                if (message.partitioningBySize != null && message.hasOwnProperty("partitioningBySize"))
                    object.partitioningBySize = options.enums === String ? $root.Ydb.FeatureFlag.Status[message.partitioningBySize] : message.partitioningBySize;
                if (message.partitionSizeMb != null && message.hasOwnProperty("partitionSizeMb"))
                    if (typeof message.partitionSizeMb === "number")
                        object.partitionSizeMb = options.longs === String ? String(message.partitionSizeMb) : message.partitionSizeMb;
                    else
                        object.partitionSizeMb = options.longs === String ? $util.Long.prototype.toString.call(message.partitionSizeMb) : options.longs === Number ? new $util.LongBits(message.partitionSizeMb.low >>> 0, message.partitionSizeMb.high >>> 0).toNumber(true) : message.partitionSizeMb;
                if (message.partitioningByLoad != null && message.hasOwnProperty("partitioningByLoad"))
                    object.partitioningByLoad = options.enums === String ? $root.Ydb.FeatureFlag.Status[message.partitioningByLoad] : message.partitioningByLoad;
                if (message.minPartitionsCount != null && message.hasOwnProperty("minPartitionsCount"))
                    if (typeof message.minPartitionsCount === "number")
                        object.minPartitionsCount = options.longs === String ? String(message.minPartitionsCount) : message.minPartitionsCount;
                    else
                        object.minPartitionsCount = options.longs === String ? $util.Long.prototype.toString.call(message.minPartitionsCount) : options.longs === Number ? new $util.LongBits(message.minPartitionsCount.low >>> 0, message.minPartitionsCount.high >>> 0).toNumber(true) : message.minPartitionsCount;
                if (message.maxPartitionsCount != null && message.hasOwnProperty("maxPartitionsCount"))
                    if (typeof message.maxPartitionsCount === "number")
                        object.maxPartitionsCount = options.longs === String ? String(message.maxPartitionsCount) : message.maxPartitionsCount;
                    else
                        object.maxPartitionsCount = options.longs === String ? $util.Long.prototype.toString.call(message.maxPartitionsCount) : options.longs === Number ? new $util.LongBits(message.maxPartitionsCount.low >>> 0, message.maxPartitionsCount.high >>> 0).toNumber(true) : message.maxPartitionsCount;
                return object;
            };

            /**
             * Converts this PartitioningSettings to JSON.
             * @function toJSON
             * @memberof Ydb.Table.PartitioningSettings
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PartitioningSettings.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return PartitioningSettings;
        })();

        Table.AzReadReplicasSettings = (function() {

            /**
             * Properties of an AzReadReplicasSettings.
             * @memberof Ydb.Table
             * @interface IAzReadReplicasSettings
             * @property {string|null} [name] AzReadReplicasSettings name
             * @property {number|Long|null} [readReplicasCount] AzReadReplicasSettings readReplicasCount
             */

            /**
             * Constructs a new AzReadReplicasSettings.
             * @memberof Ydb.Table
             * @classdesc Represents an AzReadReplicasSettings.
             * @implements IAzReadReplicasSettings
             * @constructor
             * @param {Ydb.Table.IAzReadReplicasSettings=} [properties] Properties to set
             */
            function AzReadReplicasSettings(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AzReadReplicasSettings name.
             * @member {string} name
             * @memberof Ydb.Table.AzReadReplicasSettings
             * @instance
             */
            AzReadReplicasSettings.prototype.name = "";

            /**
             * AzReadReplicasSettings readReplicasCount.
             * @member {number|Long} readReplicasCount
             * @memberof Ydb.Table.AzReadReplicasSettings
             * @instance
             */
            AzReadReplicasSettings.prototype.readReplicasCount = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Creates a new AzReadReplicasSettings instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.AzReadReplicasSettings
             * @static
             * @param {Ydb.Table.IAzReadReplicasSettings=} [properties] Properties to set
             * @returns {Ydb.Table.AzReadReplicasSettings} AzReadReplicasSettings instance
             */
            AzReadReplicasSettings.create = function create(properties) {
                return new AzReadReplicasSettings(properties);
            };

            /**
             * Encodes the specified AzReadReplicasSettings message. Does not implicitly {@link Ydb.Table.AzReadReplicasSettings.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.AzReadReplicasSettings
             * @static
             * @param {Ydb.Table.IAzReadReplicasSettings} message AzReadReplicasSettings message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AzReadReplicasSettings.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.readReplicasCount != null && Object.hasOwnProperty.call(message, "readReplicasCount"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.readReplicasCount);
                return writer;
            };

            /**
             * Encodes the specified AzReadReplicasSettings message, length delimited. Does not implicitly {@link Ydb.Table.AzReadReplicasSettings.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.AzReadReplicasSettings
             * @static
             * @param {Ydb.Table.IAzReadReplicasSettings} message AzReadReplicasSettings message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AzReadReplicasSettings.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AzReadReplicasSettings message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.AzReadReplicasSettings
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.AzReadReplicasSettings} AzReadReplicasSettings
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AzReadReplicasSettings.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.AzReadReplicasSettings();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message.readReplicasCount = reader.uint64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an AzReadReplicasSettings message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.AzReadReplicasSettings
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.AzReadReplicasSettings} AzReadReplicasSettings
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AzReadReplicasSettings.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AzReadReplicasSettings message.
             * @function verify
             * @memberof Ydb.Table.AzReadReplicasSettings
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AzReadReplicasSettings.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.readReplicasCount != null && message.hasOwnProperty("readReplicasCount"))
                    if (!$util.isInteger(message.readReplicasCount) && !(message.readReplicasCount && $util.isInteger(message.readReplicasCount.low) && $util.isInteger(message.readReplicasCount.high)))
                        return "readReplicasCount: integer|Long expected";
                return null;
            };

            /**
             * Creates an AzReadReplicasSettings message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.AzReadReplicasSettings
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.AzReadReplicasSettings} AzReadReplicasSettings
             */
            AzReadReplicasSettings.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.AzReadReplicasSettings)
                    return object;
                var message = new $root.Ydb.Table.AzReadReplicasSettings();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.readReplicasCount != null)
                    if ($util.Long)
                        (message.readReplicasCount = $util.Long.fromValue(object.readReplicasCount)).unsigned = true;
                    else if (typeof object.readReplicasCount === "string")
                        message.readReplicasCount = parseInt(object.readReplicasCount, 10);
                    else if (typeof object.readReplicasCount === "number")
                        message.readReplicasCount = object.readReplicasCount;
                    else if (typeof object.readReplicasCount === "object")
                        message.readReplicasCount = new $util.LongBits(object.readReplicasCount.low >>> 0, object.readReplicasCount.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from an AzReadReplicasSettings message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.AzReadReplicasSettings
             * @static
             * @param {Ydb.Table.AzReadReplicasSettings} message AzReadReplicasSettings
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AzReadReplicasSettings.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.name = "";
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.readReplicasCount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.readReplicasCount = options.longs === String ? "0" : 0;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.readReplicasCount != null && message.hasOwnProperty("readReplicasCount"))
                    if (typeof message.readReplicasCount === "number")
                        object.readReplicasCount = options.longs === String ? String(message.readReplicasCount) : message.readReplicasCount;
                    else
                        object.readReplicasCount = options.longs === String ? $util.Long.prototype.toString.call(message.readReplicasCount) : options.longs === Number ? new $util.LongBits(message.readReplicasCount.low >>> 0, message.readReplicasCount.high >>> 0).toNumber(true) : message.readReplicasCount;
                return object;
            };

            /**
             * Converts this AzReadReplicasSettings to JSON.
             * @function toJSON
             * @memberof Ydb.Table.AzReadReplicasSettings
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AzReadReplicasSettings.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return AzReadReplicasSettings;
        })();

        Table.ClusterReplicasSettings = (function() {

            /**
             * Properties of a ClusterReplicasSettings.
             * @memberof Ydb.Table
             * @interface IClusterReplicasSettings
             * @property {Array.<Ydb.Table.IAzReadReplicasSettings>|null} [azReadReplicasSettings] ClusterReplicasSettings azReadReplicasSettings
             */

            /**
             * Constructs a new ClusterReplicasSettings.
             * @memberof Ydb.Table
             * @classdesc Represents a ClusterReplicasSettings.
             * @implements IClusterReplicasSettings
             * @constructor
             * @param {Ydb.Table.IClusterReplicasSettings=} [properties] Properties to set
             */
            function ClusterReplicasSettings(properties) {
                this.azReadReplicasSettings = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ClusterReplicasSettings azReadReplicasSettings.
             * @member {Array.<Ydb.Table.IAzReadReplicasSettings>} azReadReplicasSettings
             * @memberof Ydb.Table.ClusterReplicasSettings
             * @instance
             */
            ClusterReplicasSettings.prototype.azReadReplicasSettings = $util.emptyArray;

            /**
             * Creates a new ClusterReplicasSettings instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.ClusterReplicasSettings
             * @static
             * @param {Ydb.Table.IClusterReplicasSettings=} [properties] Properties to set
             * @returns {Ydb.Table.ClusterReplicasSettings} ClusterReplicasSettings instance
             */
            ClusterReplicasSettings.create = function create(properties) {
                return new ClusterReplicasSettings(properties);
            };

            /**
             * Encodes the specified ClusterReplicasSettings message. Does not implicitly {@link Ydb.Table.ClusterReplicasSettings.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.ClusterReplicasSettings
             * @static
             * @param {Ydb.Table.IClusterReplicasSettings} message ClusterReplicasSettings message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ClusterReplicasSettings.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.azReadReplicasSettings != null && message.azReadReplicasSettings.length)
                    for (var i = 0; i < message.azReadReplicasSettings.length; ++i)
                        $root.Ydb.Table.AzReadReplicasSettings.encode(message.azReadReplicasSettings[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ClusterReplicasSettings message, length delimited. Does not implicitly {@link Ydb.Table.ClusterReplicasSettings.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.ClusterReplicasSettings
             * @static
             * @param {Ydb.Table.IClusterReplicasSettings} message ClusterReplicasSettings message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ClusterReplicasSettings.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ClusterReplicasSettings message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.ClusterReplicasSettings
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.ClusterReplicasSettings} ClusterReplicasSettings
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ClusterReplicasSettings.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.ClusterReplicasSettings();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 2:
                        if (!(message.azReadReplicasSettings && message.azReadReplicasSettings.length))
                            message.azReadReplicasSettings = [];
                        message.azReadReplicasSettings.push($root.Ydb.Table.AzReadReplicasSettings.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ClusterReplicasSettings message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.ClusterReplicasSettings
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.ClusterReplicasSettings} ClusterReplicasSettings
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ClusterReplicasSettings.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ClusterReplicasSettings message.
             * @function verify
             * @memberof Ydb.Table.ClusterReplicasSettings
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ClusterReplicasSettings.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.azReadReplicasSettings != null && message.hasOwnProperty("azReadReplicasSettings")) {
                    if (!Array.isArray(message.azReadReplicasSettings))
                        return "azReadReplicasSettings: array expected";
                    for (var i = 0; i < message.azReadReplicasSettings.length; ++i) {
                        var error = $root.Ydb.Table.AzReadReplicasSettings.verify(message.azReadReplicasSettings[i]);
                        if (error)
                            return "azReadReplicasSettings." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a ClusterReplicasSettings message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.ClusterReplicasSettings
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.ClusterReplicasSettings} ClusterReplicasSettings
             */
            ClusterReplicasSettings.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.ClusterReplicasSettings)
                    return object;
                var message = new $root.Ydb.Table.ClusterReplicasSettings();
                if (object.azReadReplicasSettings) {
                    if (!Array.isArray(object.azReadReplicasSettings))
                        throw TypeError(".Ydb.Table.ClusterReplicasSettings.azReadReplicasSettings: array expected");
                    message.azReadReplicasSettings = [];
                    for (var i = 0; i < object.azReadReplicasSettings.length; ++i) {
                        if (typeof object.azReadReplicasSettings[i] !== "object")
                            throw TypeError(".Ydb.Table.ClusterReplicasSettings.azReadReplicasSettings: object expected");
                        message.azReadReplicasSettings[i] = $root.Ydb.Table.AzReadReplicasSettings.fromObject(object.azReadReplicasSettings[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a ClusterReplicasSettings message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.ClusterReplicasSettings
             * @static
             * @param {Ydb.Table.ClusterReplicasSettings} message ClusterReplicasSettings
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ClusterReplicasSettings.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.azReadReplicasSettings = [];
                if (message.azReadReplicasSettings && message.azReadReplicasSettings.length) {
                    object.azReadReplicasSettings = [];
                    for (var j = 0; j < message.azReadReplicasSettings.length; ++j)
                        object.azReadReplicasSettings[j] = $root.Ydb.Table.AzReadReplicasSettings.toObject(message.azReadReplicasSettings[j], options);
                }
                return object;
            };

            /**
             * Converts this ClusterReplicasSettings to JSON.
             * @function toJSON
             * @memberof Ydb.Table.ClusterReplicasSettings
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ClusterReplicasSettings.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ClusterReplicasSettings;
        })();

        Table.ReadReplicasSettings = (function() {

            /**
             * Properties of a ReadReplicasSettings.
             * @memberof Ydb.Table
             * @interface IReadReplicasSettings
             * @property {number|Long|null} [perAzReadReplicasCount] ReadReplicasSettings perAzReadReplicasCount
             * @property {number|Long|null} [anyAzReadReplicasCount] ReadReplicasSettings anyAzReadReplicasCount
             */

            /**
             * Constructs a new ReadReplicasSettings.
             * @memberof Ydb.Table
             * @classdesc Represents a ReadReplicasSettings.
             * @implements IReadReplicasSettings
             * @constructor
             * @param {Ydb.Table.IReadReplicasSettings=} [properties] Properties to set
             */
            function ReadReplicasSettings(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ReadReplicasSettings perAzReadReplicasCount.
             * @member {number|Long|null|undefined} perAzReadReplicasCount
             * @memberof Ydb.Table.ReadReplicasSettings
             * @instance
             */
            ReadReplicasSettings.prototype.perAzReadReplicasCount = null;

            /**
             * ReadReplicasSettings anyAzReadReplicasCount.
             * @member {number|Long|null|undefined} anyAzReadReplicasCount
             * @memberof Ydb.Table.ReadReplicasSettings
             * @instance
             */
            ReadReplicasSettings.prototype.anyAzReadReplicasCount = null;

            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;

            /**
             * ReadReplicasSettings settings.
             * @member {"perAzReadReplicasCount"|"anyAzReadReplicasCount"|undefined} settings
             * @memberof Ydb.Table.ReadReplicasSettings
             * @instance
             */
            Object.defineProperty(ReadReplicasSettings.prototype, "settings", {
                get: $util.oneOfGetter($oneOfFields = ["perAzReadReplicasCount", "anyAzReadReplicasCount"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new ReadReplicasSettings instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.ReadReplicasSettings
             * @static
             * @param {Ydb.Table.IReadReplicasSettings=} [properties] Properties to set
             * @returns {Ydb.Table.ReadReplicasSettings} ReadReplicasSettings instance
             */
            ReadReplicasSettings.create = function create(properties) {
                return new ReadReplicasSettings(properties);
            };

            /**
             * Encodes the specified ReadReplicasSettings message. Does not implicitly {@link Ydb.Table.ReadReplicasSettings.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.ReadReplicasSettings
             * @static
             * @param {Ydb.Table.IReadReplicasSettings} message ReadReplicasSettings message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadReplicasSettings.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.perAzReadReplicasCount != null && Object.hasOwnProperty.call(message, "perAzReadReplicasCount"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.perAzReadReplicasCount);
                if (message.anyAzReadReplicasCount != null && Object.hasOwnProperty.call(message, "anyAzReadReplicasCount"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.anyAzReadReplicasCount);
                return writer;
            };

            /**
             * Encodes the specified ReadReplicasSettings message, length delimited. Does not implicitly {@link Ydb.Table.ReadReplicasSettings.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.ReadReplicasSettings
             * @static
             * @param {Ydb.Table.IReadReplicasSettings} message ReadReplicasSettings message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadReplicasSettings.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReadReplicasSettings message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.ReadReplicasSettings
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.ReadReplicasSettings} ReadReplicasSettings
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadReplicasSettings.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.ReadReplicasSettings();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.perAzReadReplicasCount = reader.uint64();
                        break;
                    case 2:
                        message.anyAzReadReplicasCount = reader.uint64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ReadReplicasSettings message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.ReadReplicasSettings
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.ReadReplicasSettings} ReadReplicasSettings
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadReplicasSettings.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReadReplicasSettings message.
             * @function verify
             * @memberof Ydb.Table.ReadReplicasSettings
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReadReplicasSettings.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.perAzReadReplicasCount != null && message.hasOwnProperty("perAzReadReplicasCount")) {
                    properties.settings = 1;
                    if (!$util.isInteger(message.perAzReadReplicasCount) && !(message.perAzReadReplicasCount && $util.isInteger(message.perAzReadReplicasCount.low) && $util.isInteger(message.perAzReadReplicasCount.high)))
                        return "perAzReadReplicasCount: integer|Long expected";
                }
                if (message.anyAzReadReplicasCount != null && message.hasOwnProperty("anyAzReadReplicasCount")) {
                    if (properties.settings === 1)
                        return "settings: multiple values";
                    properties.settings = 1;
                    if (!$util.isInteger(message.anyAzReadReplicasCount) && !(message.anyAzReadReplicasCount && $util.isInteger(message.anyAzReadReplicasCount.low) && $util.isInteger(message.anyAzReadReplicasCount.high)))
                        return "anyAzReadReplicasCount: integer|Long expected";
                }
                return null;
            };

            /**
             * Creates a ReadReplicasSettings message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.ReadReplicasSettings
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.ReadReplicasSettings} ReadReplicasSettings
             */
            ReadReplicasSettings.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.ReadReplicasSettings)
                    return object;
                var message = new $root.Ydb.Table.ReadReplicasSettings();
                if (object.perAzReadReplicasCount != null)
                    if ($util.Long)
                        (message.perAzReadReplicasCount = $util.Long.fromValue(object.perAzReadReplicasCount)).unsigned = true;
                    else if (typeof object.perAzReadReplicasCount === "string")
                        message.perAzReadReplicasCount = parseInt(object.perAzReadReplicasCount, 10);
                    else if (typeof object.perAzReadReplicasCount === "number")
                        message.perAzReadReplicasCount = object.perAzReadReplicasCount;
                    else if (typeof object.perAzReadReplicasCount === "object")
                        message.perAzReadReplicasCount = new $util.LongBits(object.perAzReadReplicasCount.low >>> 0, object.perAzReadReplicasCount.high >>> 0).toNumber(true);
                if (object.anyAzReadReplicasCount != null)
                    if ($util.Long)
                        (message.anyAzReadReplicasCount = $util.Long.fromValue(object.anyAzReadReplicasCount)).unsigned = true;
                    else if (typeof object.anyAzReadReplicasCount === "string")
                        message.anyAzReadReplicasCount = parseInt(object.anyAzReadReplicasCount, 10);
                    else if (typeof object.anyAzReadReplicasCount === "number")
                        message.anyAzReadReplicasCount = object.anyAzReadReplicasCount;
                    else if (typeof object.anyAzReadReplicasCount === "object")
                        message.anyAzReadReplicasCount = new $util.LongBits(object.anyAzReadReplicasCount.low >>> 0, object.anyAzReadReplicasCount.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a ReadReplicasSettings message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.ReadReplicasSettings
             * @static
             * @param {Ydb.Table.ReadReplicasSettings} message ReadReplicasSettings
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReadReplicasSettings.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (message.perAzReadReplicasCount != null && message.hasOwnProperty("perAzReadReplicasCount")) {
                    if (typeof message.perAzReadReplicasCount === "number")
                        object.perAzReadReplicasCount = options.longs === String ? String(message.perAzReadReplicasCount) : message.perAzReadReplicasCount;
                    else
                        object.perAzReadReplicasCount = options.longs === String ? $util.Long.prototype.toString.call(message.perAzReadReplicasCount) : options.longs === Number ? new $util.LongBits(message.perAzReadReplicasCount.low >>> 0, message.perAzReadReplicasCount.high >>> 0).toNumber(true) : message.perAzReadReplicasCount;
                    if (options.oneofs)
                        object.settings = "perAzReadReplicasCount";
                }
                if (message.anyAzReadReplicasCount != null && message.hasOwnProperty("anyAzReadReplicasCount")) {
                    if (typeof message.anyAzReadReplicasCount === "number")
                        object.anyAzReadReplicasCount = options.longs === String ? String(message.anyAzReadReplicasCount) : message.anyAzReadReplicasCount;
                    else
                        object.anyAzReadReplicasCount = options.longs === String ? $util.Long.prototype.toString.call(message.anyAzReadReplicasCount) : options.longs === Number ? new $util.LongBits(message.anyAzReadReplicasCount.low >>> 0, message.anyAzReadReplicasCount.high >>> 0).toNumber(true) : message.anyAzReadReplicasCount;
                    if (options.oneofs)
                        object.settings = "anyAzReadReplicasCount";
                }
                return object;
            };

            /**
             * Converts this ReadReplicasSettings to JSON.
             * @function toJSON
             * @memberof Ydb.Table.ReadReplicasSettings
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReadReplicasSettings.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ReadReplicasSettings;
        })();

        Table.CreateTableRequest = (function() {

            /**
             * Properties of a CreateTableRequest.
             * @memberof Ydb.Table
             * @interface ICreateTableRequest
             * @property {string|null} [sessionId] CreateTableRequest sessionId
             * @property {string|null} [path] CreateTableRequest path
             * @property {Array.<Ydb.Table.IColumnMeta>|null} [columns] CreateTableRequest columns
             * @property {Array.<string>|null} [primaryKey] CreateTableRequest primaryKey
             * @property {Ydb.Table.ITableProfile|null} [profile] CreateTableRequest profile
             * @property {Ydb.Operations.IOperationParams|null} [operationParams] CreateTableRequest operationParams
             * @property {Array.<Ydb.Table.ITableIndex>|null} [indexes] CreateTableRequest indexes
             * @property {Ydb.Table.ITtlSettings|null} [ttlSettings] CreateTableRequest ttlSettings
             * @property {Ydb.Table.IStorageSettings|null} [storageSettings] CreateTableRequest storageSettings
             * @property {Array.<Ydb.Table.IColumnFamily>|null} [columnFamilies] CreateTableRequest columnFamilies
             * @property {Object.<string,string>|null} [attributes] CreateTableRequest attributes
             * @property {string|null} [compactionPolicy] CreateTableRequest compactionPolicy
             * @property {number|Long|null} [uniformPartitions] CreateTableRequest uniformPartitions
             * @property {Ydb.Table.IExplicitPartitions|null} [partitionAtKeys] CreateTableRequest partitionAtKeys
             * @property {Ydb.Table.IPartitioningSettings|null} [partitioningSettings] CreateTableRequest partitioningSettings
             * @property {Ydb.FeatureFlag.Status|null} [keyBloomFilter] CreateTableRequest keyBloomFilter
             * @property {Ydb.Table.IReadReplicasSettings|null} [readReplicasSettings] CreateTableRequest readReplicasSettings
             */

            /**
             * Constructs a new CreateTableRequest.
             * @memberof Ydb.Table
             * @classdesc Represents a CreateTableRequest.
             * @implements ICreateTableRequest
             * @constructor
             * @param {Ydb.Table.ICreateTableRequest=} [properties] Properties to set
             */
            function CreateTableRequest(properties) {
                this.columns = [];
                this.primaryKey = [];
                this.indexes = [];
                this.columnFamilies = [];
                this.attributes = {};
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CreateTableRequest sessionId.
             * @member {string} sessionId
             * @memberof Ydb.Table.CreateTableRequest
             * @instance
             */
            CreateTableRequest.prototype.sessionId = "";

            /**
             * CreateTableRequest path.
             * @member {string} path
             * @memberof Ydb.Table.CreateTableRequest
             * @instance
             */
            CreateTableRequest.prototype.path = "";

            /**
             * CreateTableRequest columns.
             * @member {Array.<Ydb.Table.IColumnMeta>} columns
             * @memberof Ydb.Table.CreateTableRequest
             * @instance
             */
            CreateTableRequest.prototype.columns = $util.emptyArray;

            /**
             * CreateTableRequest primaryKey.
             * @member {Array.<string>} primaryKey
             * @memberof Ydb.Table.CreateTableRequest
             * @instance
             */
            CreateTableRequest.prototype.primaryKey = $util.emptyArray;

            /**
             * CreateTableRequest profile.
             * @member {Ydb.Table.ITableProfile|null|undefined} profile
             * @memberof Ydb.Table.CreateTableRequest
             * @instance
             */
            CreateTableRequest.prototype.profile = null;

            /**
             * CreateTableRequest operationParams.
             * @member {Ydb.Operations.IOperationParams|null|undefined} operationParams
             * @memberof Ydb.Table.CreateTableRequest
             * @instance
             */
            CreateTableRequest.prototype.operationParams = null;

            /**
             * CreateTableRequest indexes.
             * @member {Array.<Ydb.Table.ITableIndex>} indexes
             * @memberof Ydb.Table.CreateTableRequest
             * @instance
             */
            CreateTableRequest.prototype.indexes = $util.emptyArray;

            /**
             * CreateTableRequest ttlSettings.
             * @member {Ydb.Table.ITtlSettings|null|undefined} ttlSettings
             * @memberof Ydb.Table.CreateTableRequest
             * @instance
             */
            CreateTableRequest.prototype.ttlSettings = null;

            /**
             * CreateTableRequest storageSettings.
             * @member {Ydb.Table.IStorageSettings|null|undefined} storageSettings
             * @memberof Ydb.Table.CreateTableRequest
             * @instance
             */
            CreateTableRequest.prototype.storageSettings = null;

            /**
             * CreateTableRequest columnFamilies.
             * @member {Array.<Ydb.Table.IColumnFamily>} columnFamilies
             * @memberof Ydb.Table.CreateTableRequest
             * @instance
             */
            CreateTableRequest.prototype.columnFamilies = $util.emptyArray;

            /**
             * CreateTableRequest attributes.
             * @member {Object.<string,string>} attributes
             * @memberof Ydb.Table.CreateTableRequest
             * @instance
             */
            CreateTableRequest.prototype.attributes = $util.emptyObject;

            /**
             * CreateTableRequest compactionPolicy.
             * @member {string} compactionPolicy
             * @memberof Ydb.Table.CreateTableRequest
             * @instance
             */
            CreateTableRequest.prototype.compactionPolicy = "";

            /**
             * CreateTableRequest uniformPartitions.
             * @member {number|Long|null|undefined} uniformPartitions
             * @memberof Ydb.Table.CreateTableRequest
             * @instance
             */
            CreateTableRequest.prototype.uniformPartitions = null;

            /**
             * CreateTableRequest partitionAtKeys.
             * @member {Ydb.Table.IExplicitPartitions|null|undefined} partitionAtKeys
             * @memberof Ydb.Table.CreateTableRequest
             * @instance
             */
            CreateTableRequest.prototype.partitionAtKeys = null;

            /**
             * CreateTableRequest partitioningSettings.
             * @member {Ydb.Table.IPartitioningSettings|null|undefined} partitioningSettings
             * @memberof Ydb.Table.CreateTableRequest
             * @instance
             */
            CreateTableRequest.prototype.partitioningSettings = null;

            /**
             * CreateTableRequest keyBloomFilter.
             * @member {Ydb.FeatureFlag.Status} keyBloomFilter
             * @memberof Ydb.Table.CreateTableRequest
             * @instance
             */
            CreateTableRequest.prototype.keyBloomFilter = 0;

            /**
             * CreateTableRequest readReplicasSettings.
             * @member {Ydb.Table.IReadReplicasSettings|null|undefined} readReplicasSettings
             * @memberof Ydb.Table.CreateTableRequest
             * @instance
             */
            CreateTableRequest.prototype.readReplicasSettings = null;

            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;

            /**
             * CreateTableRequest partitions.
             * @member {"uniformPartitions"|"partitionAtKeys"|undefined} partitions
             * @memberof Ydb.Table.CreateTableRequest
             * @instance
             */
            Object.defineProperty(CreateTableRequest.prototype, "partitions", {
                get: $util.oneOfGetter($oneOfFields = ["uniformPartitions", "partitionAtKeys"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new CreateTableRequest instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.CreateTableRequest
             * @static
             * @param {Ydb.Table.ICreateTableRequest=} [properties] Properties to set
             * @returns {Ydb.Table.CreateTableRequest} CreateTableRequest instance
             */
            CreateTableRequest.create = function create(properties) {
                return new CreateTableRequest(properties);
            };

            /**
             * Encodes the specified CreateTableRequest message. Does not implicitly {@link Ydb.Table.CreateTableRequest.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.CreateTableRequest
             * @static
             * @param {Ydb.Table.ICreateTableRequest} message CreateTableRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CreateTableRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.sessionId != null && Object.hasOwnProperty.call(message, "sessionId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.sessionId);
                if (message.path != null && Object.hasOwnProperty.call(message, "path"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.path);
                if (message.columns != null && message.columns.length)
                    for (var i = 0; i < message.columns.length; ++i)
                        $root.Ydb.Table.ColumnMeta.encode(message.columns[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.primaryKey != null && message.primaryKey.length)
                    for (var i = 0; i < message.primaryKey.length; ++i)
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.primaryKey[i]);
                if (message.profile != null && Object.hasOwnProperty.call(message, "profile"))
                    $root.Ydb.Table.TableProfile.encode(message.profile, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.operationParams != null && Object.hasOwnProperty.call(message, "operationParams"))
                    $root.Ydb.Operations.OperationParams.encode(message.operationParams, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.indexes != null && message.indexes.length)
                    for (var i = 0; i < message.indexes.length; ++i)
                        $root.Ydb.Table.TableIndex.encode(message.indexes[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.ttlSettings != null && Object.hasOwnProperty.call(message, "ttlSettings"))
                    $root.Ydb.Table.TtlSettings.encode(message.ttlSettings, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                if (message.storageSettings != null && Object.hasOwnProperty.call(message, "storageSettings"))
                    $root.Ydb.Table.StorageSettings.encode(message.storageSettings, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                if (message.columnFamilies != null && message.columnFamilies.length)
                    for (var i = 0; i < message.columnFamilies.length; ++i)
                        $root.Ydb.Table.ColumnFamily.encode(message.columnFamilies[i], writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                if (message.attributes != null && Object.hasOwnProperty.call(message, "attributes"))
                    for (var keys = Object.keys(message.attributes), i = 0; i < keys.length; ++i)
                        writer.uint32(/* id 11, wireType 2 =*/90).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.attributes[keys[i]]).ldelim();
                if (message.compactionPolicy != null && Object.hasOwnProperty.call(message, "compactionPolicy"))
                    writer.uint32(/* id 12, wireType 2 =*/98).string(message.compactionPolicy);
                if (message.uniformPartitions != null && Object.hasOwnProperty.call(message, "uniformPartitions"))
                    writer.uint32(/* id 13, wireType 0 =*/104).uint64(message.uniformPartitions);
                if (message.partitionAtKeys != null && Object.hasOwnProperty.call(message, "partitionAtKeys"))
                    $root.Ydb.Table.ExplicitPartitions.encode(message.partitionAtKeys, writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
                if (message.partitioningSettings != null && Object.hasOwnProperty.call(message, "partitioningSettings"))
                    $root.Ydb.Table.PartitioningSettings.encode(message.partitioningSettings, writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
                if (message.keyBloomFilter != null && Object.hasOwnProperty.call(message, "keyBloomFilter"))
                    writer.uint32(/* id 16, wireType 0 =*/128).int32(message.keyBloomFilter);
                if (message.readReplicasSettings != null && Object.hasOwnProperty.call(message, "readReplicasSettings"))
                    $root.Ydb.Table.ReadReplicasSettings.encode(message.readReplicasSettings, writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified CreateTableRequest message, length delimited. Does not implicitly {@link Ydb.Table.CreateTableRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.CreateTableRequest
             * @static
             * @param {Ydb.Table.ICreateTableRequest} message CreateTableRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CreateTableRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CreateTableRequest message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.CreateTableRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.CreateTableRequest} CreateTableRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CreateTableRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.CreateTableRequest(), key, value;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.sessionId = reader.string();
                        break;
                    case 2:
                        message.path = reader.string();
                        break;
                    case 3:
                        if (!(message.columns && message.columns.length))
                            message.columns = [];
                        message.columns.push($root.Ydb.Table.ColumnMeta.decode(reader, reader.uint32()));
                        break;
                    case 4:
                        if (!(message.primaryKey && message.primaryKey.length))
                            message.primaryKey = [];
                        message.primaryKey.push(reader.string());
                        break;
                    case 5:
                        message.profile = $root.Ydb.Table.TableProfile.decode(reader, reader.uint32());
                        break;
                    case 6:
                        message.operationParams = $root.Ydb.Operations.OperationParams.decode(reader, reader.uint32());
                        break;
                    case 7:
                        if (!(message.indexes && message.indexes.length))
                            message.indexes = [];
                        message.indexes.push($root.Ydb.Table.TableIndex.decode(reader, reader.uint32()));
                        break;
                    case 8:
                        message.ttlSettings = $root.Ydb.Table.TtlSettings.decode(reader, reader.uint32());
                        break;
                    case 9:
                        message.storageSettings = $root.Ydb.Table.StorageSettings.decode(reader, reader.uint32());
                        break;
                    case 10:
                        if (!(message.columnFamilies && message.columnFamilies.length))
                            message.columnFamilies = [];
                        message.columnFamilies.push($root.Ydb.Table.ColumnFamily.decode(reader, reader.uint32()));
                        break;
                    case 11:
                        if (message.attributes === $util.emptyObject)
                            message.attributes = {};
                        var end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = "";
                        while (reader.pos < end2) {
                            var tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = reader.string();
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.attributes[key] = value;
                        break;
                    case 12:
                        message.compactionPolicy = reader.string();
                        break;
                    case 13:
                        message.uniformPartitions = reader.uint64();
                        break;
                    case 14:
                        message.partitionAtKeys = $root.Ydb.Table.ExplicitPartitions.decode(reader, reader.uint32());
                        break;
                    case 15:
                        message.partitioningSettings = $root.Ydb.Table.PartitioningSettings.decode(reader, reader.uint32());
                        break;
                    case 16:
                        message.keyBloomFilter = reader.int32();
                        break;
                    case 17:
                        message.readReplicasSettings = $root.Ydb.Table.ReadReplicasSettings.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a CreateTableRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.CreateTableRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.CreateTableRequest} CreateTableRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CreateTableRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CreateTableRequest message.
             * @function verify
             * @memberof Ydb.Table.CreateTableRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CreateTableRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.sessionId != null && message.hasOwnProperty("sessionId"))
                    if (!$util.isString(message.sessionId))
                        return "sessionId: string expected";
                if (message.path != null && message.hasOwnProperty("path"))
                    if (!$util.isString(message.path))
                        return "path: string expected";
                if (message.columns != null && message.hasOwnProperty("columns")) {
                    if (!Array.isArray(message.columns))
                        return "columns: array expected";
                    for (var i = 0; i < message.columns.length; ++i) {
                        var error = $root.Ydb.Table.ColumnMeta.verify(message.columns[i]);
                        if (error)
                            return "columns." + error;
                    }
                }
                if (message.primaryKey != null && message.hasOwnProperty("primaryKey")) {
                    if (!Array.isArray(message.primaryKey))
                        return "primaryKey: array expected";
                    for (var i = 0; i < message.primaryKey.length; ++i)
                        if (!$util.isString(message.primaryKey[i]))
                            return "primaryKey: string[] expected";
                }
                if (message.profile != null && message.hasOwnProperty("profile")) {
                    var error = $root.Ydb.Table.TableProfile.verify(message.profile);
                    if (error)
                        return "profile." + error;
                }
                if (message.operationParams != null && message.hasOwnProperty("operationParams")) {
                    var error = $root.Ydb.Operations.OperationParams.verify(message.operationParams);
                    if (error)
                        return "operationParams." + error;
                }
                if (message.indexes != null && message.hasOwnProperty("indexes")) {
                    if (!Array.isArray(message.indexes))
                        return "indexes: array expected";
                    for (var i = 0; i < message.indexes.length; ++i) {
                        var error = $root.Ydb.Table.TableIndex.verify(message.indexes[i]);
                        if (error)
                            return "indexes." + error;
                    }
                }
                if (message.ttlSettings != null && message.hasOwnProperty("ttlSettings")) {
                    var error = $root.Ydb.Table.TtlSettings.verify(message.ttlSettings);
                    if (error)
                        return "ttlSettings." + error;
                }
                if (message.storageSettings != null && message.hasOwnProperty("storageSettings")) {
                    var error = $root.Ydb.Table.StorageSettings.verify(message.storageSettings);
                    if (error)
                        return "storageSettings." + error;
                }
                if (message.columnFamilies != null && message.hasOwnProperty("columnFamilies")) {
                    if (!Array.isArray(message.columnFamilies))
                        return "columnFamilies: array expected";
                    for (var i = 0; i < message.columnFamilies.length; ++i) {
                        var error = $root.Ydb.Table.ColumnFamily.verify(message.columnFamilies[i]);
                        if (error)
                            return "columnFamilies." + error;
                    }
                }
                if (message.attributes != null && message.hasOwnProperty("attributes")) {
                    if (!$util.isObject(message.attributes))
                        return "attributes: object expected";
                    var key = Object.keys(message.attributes);
                    for (var i = 0; i < key.length; ++i)
                        if (!$util.isString(message.attributes[key[i]]))
                            return "attributes: string{k:string} expected";
                }
                if (message.compactionPolicy != null && message.hasOwnProperty("compactionPolicy"))
                    if (!$util.isString(message.compactionPolicy))
                        return "compactionPolicy: string expected";
                if (message.uniformPartitions != null && message.hasOwnProperty("uniformPartitions")) {
                    properties.partitions = 1;
                    if (!$util.isInteger(message.uniformPartitions) && !(message.uniformPartitions && $util.isInteger(message.uniformPartitions.low) && $util.isInteger(message.uniformPartitions.high)))
                        return "uniformPartitions: integer|Long expected";
                }
                if (message.partitionAtKeys != null && message.hasOwnProperty("partitionAtKeys")) {
                    if (properties.partitions === 1)
                        return "partitions: multiple values";
                    properties.partitions = 1;
                    {
                        var error = $root.Ydb.Table.ExplicitPartitions.verify(message.partitionAtKeys);
                        if (error)
                            return "partitionAtKeys." + error;
                    }
                }
                if (message.partitioningSettings != null && message.hasOwnProperty("partitioningSettings")) {
                    var error = $root.Ydb.Table.PartitioningSettings.verify(message.partitioningSettings);
                    if (error)
                        return "partitioningSettings." + error;
                }
                if (message.keyBloomFilter != null && message.hasOwnProperty("keyBloomFilter"))
                    switch (message.keyBloomFilter) {
                    default:
                        return "keyBloomFilter: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                if (message.readReplicasSettings != null && message.hasOwnProperty("readReplicasSettings")) {
                    var error = $root.Ydb.Table.ReadReplicasSettings.verify(message.readReplicasSettings);
                    if (error)
                        return "readReplicasSettings." + error;
                }
                return null;
            };

            /**
             * Creates a CreateTableRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.CreateTableRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.CreateTableRequest} CreateTableRequest
             */
            CreateTableRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.CreateTableRequest)
                    return object;
                var message = new $root.Ydb.Table.CreateTableRequest();
                if (object.sessionId != null)
                    message.sessionId = String(object.sessionId);
                if (object.path != null)
                    message.path = String(object.path);
                if (object.columns) {
                    if (!Array.isArray(object.columns))
                        throw TypeError(".Ydb.Table.CreateTableRequest.columns: array expected");
                    message.columns = [];
                    for (var i = 0; i < object.columns.length; ++i) {
                        if (typeof object.columns[i] !== "object")
                            throw TypeError(".Ydb.Table.CreateTableRequest.columns: object expected");
                        message.columns[i] = $root.Ydb.Table.ColumnMeta.fromObject(object.columns[i]);
                    }
                }
                if (object.primaryKey) {
                    if (!Array.isArray(object.primaryKey))
                        throw TypeError(".Ydb.Table.CreateTableRequest.primaryKey: array expected");
                    message.primaryKey = [];
                    for (var i = 0; i < object.primaryKey.length; ++i)
                        message.primaryKey[i] = String(object.primaryKey[i]);
                }
                if (object.profile != null) {
                    if (typeof object.profile !== "object")
                        throw TypeError(".Ydb.Table.CreateTableRequest.profile: object expected");
                    message.profile = $root.Ydb.Table.TableProfile.fromObject(object.profile);
                }
                if (object.operationParams != null) {
                    if (typeof object.operationParams !== "object")
                        throw TypeError(".Ydb.Table.CreateTableRequest.operationParams: object expected");
                    message.operationParams = $root.Ydb.Operations.OperationParams.fromObject(object.operationParams);
                }
                if (object.indexes) {
                    if (!Array.isArray(object.indexes))
                        throw TypeError(".Ydb.Table.CreateTableRequest.indexes: array expected");
                    message.indexes = [];
                    for (var i = 0; i < object.indexes.length; ++i) {
                        if (typeof object.indexes[i] !== "object")
                            throw TypeError(".Ydb.Table.CreateTableRequest.indexes: object expected");
                        message.indexes[i] = $root.Ydb.Table.TableIndex.fromObject(object.indexes[i]);
                    }
                }
                if (object.ttlSettings != null) {
                    if (typeof object.ttlSettings !== "object")
                        throw TypeError(".Ydb.Table.CreateTableRequest.ttlSettings: object expected");
                    message.ttlSettings = $root.Ydb.Table.TtlSettings.fromObject(object.ttlSettings);
                }
                if (object.storageSettings != null) {
                    if (typeof object.storageSettings !== "object")
                        throw TypeError(".Ydb.Table.CreateTableRequest.storageSettings: object expected");
                    message.storageSettings = $root.Ydb.Table.StorageSettings.fromObject(object.storageSettings);
                }
                if (object.columnFamilies) {
                    if (!Array.isArray(object.columnFamilies))
                        throw TypeError(".Ydb.Table.CreateTableRequest.columnFamilies: array expected");
                    message.columnFamilies = [];
                    for (var i = 0; i < object.columnFamilies.length; ++i) {
                        if (typeof object.columnFamilies[i] !== "object")
                            throw TypeError(".Ydb.Table.CreateTableRequest.columnFamilies: object expected");
                        message.columnFamilies[i] = $root.Ydb.Table.ColumnFamily.fromObject(object.columnFamilies[i]);
                    }
                }
                if (object.attributes) {
                    if (typeof object.attributes !== "object")
                        throw TypeError(".Ydb.Table.CreateTableRequest.attributes: object expected");
                    message.attributes = {};
                    for (var keys = Object.keys(object.attributes), i = 0; i < keys.length; ++i)
                        message.attributes[keys[i]] = String(object.attributes[keys[i]]);
                }
                if (object.compactionPolicy != null)
                    message.compactionPolicy = String(object.compactionPolicy);
                if (object.uniformPartitions != null)
                    if ($util.Long)
                        (message.uniformPartitions = $util.Long.fromValue(object.uniformPartitions)).unsigned = true;
                    else if (typeof object.uniformPartitions === "string")
                        message.uniformPartitions = parseInt(object.uniformPartitions, 10);
                    else if (typeof object.uniformPartitions === "number")
                        message.uniformPartitions = object.uniformPartitions;
                    else if (typeof object.uniformPartitions === "object")
                        message.uniformPartitions = new $util.LongBits(object.uniformPartitions.low >>> 0, object.uniformPartitions.high >>> 0).toNumber(true);
                if (object.partitionAtKeys != null) {
                    if (typeof object.partitionAtKeys !== "object")
                        throw TypeError(".Ydb.Table.CreateTableRequest.partitionAtKeys: object expected");
                    message.partitionAtKeys = $root.Ydb.Table.ExplicitPartitions.fromObject(object.partitionAtKeys);
                }
                if (object.partitioningSettings != null) {
                    if (typeof object.partitioningSettings !== "object")
                        throw TypeError(".Ydb.Table.CreateTableRequest.partitioningSettings: object expected");
                    message.partitioningSettings = $root.Ydb.Table.PartitioningSettings.fromObject(object.partitioningSettings);
                }
                switch (object.keyBloomFilter) {
                case "STATUS_UNSPECIFIED":
                case 0:
                    message.keyBloomFilter = 0;
                    break;
                case "ENABLED":
                case 1:
                    message.keyBloomFilter = 1;
                    break;
                case "DISABLED":
                case 2:
                    message.keyBloomFilter = 2;
                    break;
                }
                if (object.readReplicasSettings != null) {
                    if (typeof object.readReplicasSettings !== "object")
                        throw TypeError(".Ydb.Table.CreateTableRequest.readReplicasSettings: object expected");
                    message.readReplicasSettings = $root.Ydb.Table.ReadReplicasSettings.fromObject(object.readReplicasSettings);
                }
                return message;
            };

            /**
             * Creates a plain object from a CreateTableRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.CreateTableRequest
             * @static
             * @param {Ydb.Table.CreateTableRequest} message CreateTableRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CreateTableRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.columns = [];
                    object.primaryKey = [];
                    object.indexes = [];
                    object.columnFamilies = [];
                }
                if (options.objects || options.defaults)
                    object.attributes = {};
                if (options.defaults) {
                    object.sessionId = "";
                    object.path = "";
                    object.profile = null;
                    object.operationParams = null;
                    object.ttlSettings = null;
                    object.storageSettings = null;
                    object.compactionPolicy = "";
                    object.partitioningSettings = null;
                    object.keyBloomFilter = options.enums === String ? "STATUS_UNSPECIFIED" : 0;
                    object.readReplicasSettings = null;
                }
                if (message.sessionId != null && message.hasOwnProperty("sessionId"))
                    object.sessionId = message.sessionId;
                if (message.path != null && message.hasOwnProperty("path"))
                    object.path = message.path;
                if (message.columns && message.columns.length) {
                    object.columns = [];
                    for (var j = 0; j < message.columns.length; ++j)
                        object.columns[j] = $root.Ydb.Table.ColumnMeta.toObject(message.columns[j], options);
                }
                if (message.primaryKey && message.primaryKey.length) {
                    object.primaryKey = [];
                    for (var j = 0; j < message.primaryKey.length; ++j)
                        object.primaryKey[j] = message.primaryKey[j];
                }
                if (message.profile != null && message.hasOwnProperty("profile"))
                    object.profile = $root.Ydb.Table.TableProfile.toObject(message.profile, options);
                if (message.operationParams != null && message.hasOwnProperty("operationParams"))
                    object.operationParams = $root.Ydb.Operations.OperationParams.toObject(message.operationParams, options);
                if (message.indexes && message.indexes.length) {
                    object.indexes = [];
                    for (var j = 0; j < message.indexes.length; ++j)
                        object.indexes[j] = $root.Ydb.Table.TableIndex.toObject(message.indexes[j], options);
                }
                if (message.ttlSettings != null && message.hasOwnProperty("ttlSettings"))
                    object.ttlSettings = $root.Ydb.Table.TtlSettings.toObject(message.ttlSettings, options);
                if (message.storageSettings != null && message.hasOwnProperty("storageSettings"))
                    object.storageSettings = $root.Ydb.Table.StorageSettings.toObject(message.storageSettings, options);
                if (message.columnFamilies && message.columnFamilies.length) {
                    object.columnFamilies = [];
                    for (var j = 0; j < message.columnFamilies.length; ++j)
                        object.columnFamilies[j] = $root.Ydb.Table.ColumnFamily.toObject(message.columnFamilies[j], options);
                }
                var keys2;
                if (message.attributes && (keys2 = Object.keys(message.attributes)).length) {
                    object.attributes = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.attributes[keys2[j]] = message.attributes[keys2[j]];
                }
                if (message.compactionPolicy != null && message.hasOwnProperty("compactionPolicy"))
                    object.compactionPolicy = message.compactionPolicy;
                if (message.uniformPartitions != null && message.hasOwnProperty("uniformPartitions")) {
                    if (typeof message.uniformPartitions === "number")
                        object.uniformPartitions = options.longs === String ? String(message.uniformPartitions) : message.uniformPartitions;
                    else
                        object.uniformPartitions = options.longs === String ? $util.Long.prototype.toString.call(message.uniformPartitions) : options.longs === Number ? new $util.LongBits(message.uniformPartitions.low >>> 0, message.uniformPartitions.high >>> 0).toNumber(true) : message.uniformPartitions;
                    if (options.oneofs)
                        object.partitions = "uniformPartitions";
                }
                if (message.partitionAtKeys != null && message.hasOwnProperty("partitionAtKeys")) {
                    object.partitionAtKeys = $root.Ydb.Table.ExplicitPartitions.toObject(message.partitionAtKeys, options);
                    if (options.oneofs)
                        object.partitions = "partitionAtKeys";
                }
                if (message.partitioningSettings != null && message.hasOwnProperty("partitioningSettings"))
                    object.partitioningSettings = $root.Ydb.Table.PartitioningSettings.toObject(message.partitioningSettings, options);
                if (message.keyBloomFilter != null && message.hasOwnProperty("keyBloomFilter"))
                    object.keyBloomFilter = options.enums === String ? $root.Ydb.FeatureFlag.Status[message.keyBloomFilter] : message.keyBloomFilter;
                if (message.readReplicasSettings != null && message.hasOwnProperty("readReplicasSettings"))
                    object.readReplicasSettings = $root.Ydb.Table.ReadReplicasSettings.toObject(message.readReplicasSettings, options);
                return object;
            };

            /**
             * Converts this CreateTableRequest to JSON.
             * @function toJSON
             * @memberof Ydb.Table.CreateTableRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CreateTableRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return CreateTableRequest;
        })();

        Table.CreateTableResponse = (function() {

            /**
             * Properties of a CreateTableResponse.
             * @memberof Ydb.Table
             * @interface ICreateTableResponse
             * @property {Ydb.Operations.IOperation|null} [operation] CreateTableResponse operation
             */

            /**
             * Constructs a new CreateTableResponse.
             * @memberof Ydb.Table
             * @classdesc Represents a CreateTableResponse.
             * @implements ICreateTableResponse
             * @constructor
             * @param {Ydb.Table.ICreateTableResponse=} [properties] Properties to set
             */
            function CreateTableResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CreateTableResponse operation.
             * @member {Ydb.Operations.IOperation|null|undefined} operation
             * @memberof Ydb.Table.CreateTableResponse
             * @instance
             */
            CreateTableResponse.prototype.operation = null;

            /**
             * Creates a new CreateTableResponse instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.CreateTableResponse
             * @static
             * @param {Ydb.Table.ICreateTableResponse=} [properties] Properties to set
             * @returns {Ydb.Table.CreateTableResponse} CreateTableResponse instance
             */
            CreateTableResponse.create = function create(properties) {
                return new CreateTableResponse(properties);
            };

            /**
             * Encodes the specified CreateTableResponse message. Does not implicitly {@link Ydb.Table.CreateTableResponse.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.CreateTableResponse
             * @static
             * @param {Ydb.Table.ICreateTableResponse} message CreateTableResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CreateTableResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.operation != null && Object.hasOwnProperty.call(message, "operation"))
                    $root.Ydb.Operations.Operation.encode(message.operation, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified CreateTableResponse message, length delimited. Does not implicitly {@link Ydb.Table.CreateTableResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.CreateTableResponse
             * @static
             * @param {Ydb.Table.ICreateTableResponse} message CreateTableResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CreateTableResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CreateTableResponse message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.CreateTableResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.CreateTableResponse} CreateTableResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CreateTableResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.CreateTableResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.operation = $root.Ydb.Operations.Operation.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a CreateTableResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.CreateTableResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.CreateTableResponse} CreateTableResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CreateTableResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CreateTableResponse message.
             * @function verify
             * @memberof Ydb.Table.CreateTableResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CreateTableResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.operation != null && message.hasOwnProperty("operation")) {
                    var error = $root.Ydb.Operations.Operation.verify(message.operation);
                    if (error)
                        return "operation." + error;
                }
                return null;
            };

            /**
             * Creates a CreateTableResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.CreateTableResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.CreateTableResponse} CreateTableResponse
             */
            CreateTableResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.CreateTableResponse)
                    return object;
                var message = new $root.Ydb.Table.CreateTableResponse();
                if (object.operation != null) {
                    if (typeof object.operation !== "object")
                        throw TypeError(".Ydb.Table.CreateTableResponse.operation: object expected");
                    message.operation = $root.Ydb.Operations.Operation.fromObject(object.operation);
                }
                return message;
            };

            /**
             * Creates a plain object from a CreateTableResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.CreateTableResponse
             * @static
             * @param {Ydb.Table.CreateTableResponse} message CreateTableResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CreateTableResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.operation = null;
                if (message.operation != null && message.hasOwnProperty("operation"))
                    object.operation = $root.Ydb.Operations.Operation.toObject(message.operation, options);
                return object;
            };

            /**
             * Converts this CreateTableResponse to JSON.
             * @function toJSON
             * @memberof Ydb.Table.CreateTableResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CreateTableResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return CreateTableResponse;
        })();

        Table.DropTableRequest = (function() {

            /**
             * Properties of a DropTableRequest.
             * @memberof Ydb.Table
             * @interface IDropTableRequest
             * @property {string|null} [sessionId] DropTableRequest sessionId
             * @property {string|null} [path] DropTableRequest path
             * @property {Ydb.Operations.IOperationParams|null} [operationParams] DropTableRequest operationParams
             */

            /**
             * Constructs a new DropTableRequest.
             * @memberof Ydb.Table
             * @classdesc Represents a DropTableRequest.
             * @implements IDropTableRequest
             * @constructor
             * @param {Ydb.Table.IDropTableRequest=} [properties] Properties to set
             */
            function DropTableRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DropTableRequest sessionId.
             * @member {string} sessionId
             * @memberof Ydb.Table.DropTableRequest
             * @instance
             */
            DropTableRequest.prototype.sessionId = "";

            /**
             * DropTableRequest path.
             * @member {string} path
             * @memberof Ydb.Table.DropTableRequest
             * @instance
             */
            DropTableRequest.prototype.path = "";

            /**
             * DropTableRequest operationParams.
             * @member {Ydb.Operations.IOperationParams|null|undefined} operationParams
             * @memberof Ydb.Table.DropTableRequest
             * @instance
             */
            DropTableRequest.prototype.operationParams = null;

            /**
             * Creates a new DropTableRequest instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.DropTableRequest
             * @static
             * @param {Ydb.Table.IDropTableRequest=} [properties] Properties to set
             * @returns {Ydb.Table.DropTableRequest} DropTableRequest instance
             */
            DropTableRequest.create = function create(properties) {
                return new DropTableRequest(properties);
            };

            /**
             * Encodes the specified DropTableRequest message. Does not implicitly {@link Ydb.Table.DropTableRequest.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.DropTableRequest
             * @static
             * @param {Ydb.Table.IDropTableRequest} message DropTableRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DropTableRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.sessionId != null && Object.hasOwnProperty.call(message, "sessionId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.sessionId);
                if (message.path != null && Object.hasOwnProperty.call(message, "path"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.path);
                if (message.operationParams != null && Object.hasOwnProperty.call(message, "operationParams"))
                    $root.Ydb.Operations.OperationParams.encode(message.operationParams, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified DropTableRequest message, length delimited. Does not implicitly {@link Ydb.Table.DropTableRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.DropTableRequest
             * @static
             * @param {Ydb.Table.IDropTableRequest} message DropTableRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DropTableRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DropTableRequest message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.DropTableRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.DropTableRequest} DropTableRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DropTableRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.DropTableRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.sessionId = reader.string();
                        break;
                    case 2:
                        message.path = reader.string();
                        break;
                    case 4:
                        message.operationParams = $root.Ydb.Operations.OperationParams.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DropTableRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.DropTableRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.DropTableRequest} DropTableRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DropTableRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DropTableRequest message.
             * @function verify
             * @memberof Ydb.Table.DropTableRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DropTableRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.sessionId != null && message.hasOwnProperty("sessionId"))
                    if (!$util.isString(message.sessionId))
                        return "sessionId: string expected";
                if (message.path != null && message.hasOwnProperty("path"))
                    if (!$util.isString(message.path))
                        return "path: string expected";
                if (message.operationParams != null && message.hasOwnProperty("operationParams")) {
                    var error = $root.Ydb.Operations.OperationParams.verify(message.operationParams);
                    if (error)
                        return "operationParams." + error;
                }
                return null;
            };

            /**
             * Creates a DropTableRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.DropTableRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.DropTableRequest} DropTableRequest
             */
            DropTableRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.DropTableRequest)
                    return object;
                var message = new $root.Ydb.Table.DropTableRequest();
                if (object.sessionId != null)
                    message.sessionId = String(object.sessionId);
                if (object.path != null)
                    message.path = String(object.path);
                if (object.operationParams != null) {
                    if (typeof object.operationParams !== "object")
                        throw TypeError(".Ydb.Table.DropTableRequest.operationParams: object expected");
                    message.operationParams = $root.Ydb.Operations.OperationParams.fromObject(object.operationParams);
                }
                return message;
            };

            /**
             * Creates a plain object from a DropTableRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.DropTableRequest
             * @static
             * @param {Ydb.Table.DropTableRequest} message DropTableRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DropTableRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.sessionId = "";
                    object.path = "";
                    object.operationParams = null;
                }
                if (message.sessionId != null && message.hasOwnProperty("sessionId"))
                    object.sessionId = message.sessionId;
                if (message.path != null && message.hasOwnProperty("path"))
                    object.path = message.path;
                if (message.operationParams != null && message.hasOwnProperty("operationParams"))
                    object.operationParams = $root.Ydb.Operations.OperationParams.toObject(message.operationParams, options);
                return object;
            };

            /**
             * Converts this DropTableRequest to JSON.
             * @function toJSON
             * @memberof Ydb.Table.DropTableRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DropTableRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DropTableRequest;
        })();

        Table.DropTableResponse = (function() {

            /**
             * Properties of a DropTableResponse.
             * @memberof Ydb.Table
             * @interface IDropTableResponse
             * @property {Ydb.Operations.IOperation|null} [operation] DropTableResponse operation
             */

            /**
             * Constructs a new DropTableResponse.
             * @memberof Ydb.Table
             * @classdesc Represents a DropTableResponse.
             * @implements IDropTableResponse
             * @constructor
             * @param {Ydb.Table.IDropTableResponse=} [properties] Properties to set
             */
            function DropTableResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DropTableResponse operation.
             * @member {Ydb.Operations.IOperation|null|undefined} operation
             * @memberof Ydb.Table.DropTableResponse
             * @instance
             */
            DropTableResponse.prototype.operation = null;

            /**
             * Creates a new DropTableResponse instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.DropTableResponse
             * @static
             * @param {Ydb.Table.IDropTableResponse=} [properties] Properties to set
             * @returns {Ydb.Table.DropTableResponse} DropTableResponse instance
             */
            DropTableResponse.create = function create(properties) {
                return new DropTableResponse(properties);
            };

            /**
             * Encodes the specified DropTableResponse message. Does not implicitly {@link Ydb.Table.DropTableResponse.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.DropTableResponse
             * @static
             * @param {Ydb.Table.IDropTableResponse} message DropTableResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DropTableResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.operation != null && Object.hasOwnProperty.call(message, "operation"))
                    $root.Ydb.Operations.Operation.encode(message.operation, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified DropTableResponse message, length delimited. Does not implicitly {@link Ydb.Table.DropTableResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.DropTableResponse
             * @static
             * @param {Ydb.Table.IDropTableResponse} message DropTableResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DropTableResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DropTableResponse message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.DropTableResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.DropTableResponse} DropTableResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DropTableResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.DropTableResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.operation = $root.Ydb.Operations.Operation.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DropTableResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.DropTableResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.DropTableResponse} DropTableResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DropTableResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DropTableResponse message.
             * @function verify
             * @memberof Ydb.Table.DropTableResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DropTableResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.operation != null && message.hasOwnProperty("operation")) {
                    var error = $root.Ydb.Operations.Operation.verify(message.operation);
                    if (error)
                        return "operation." + error;
                }
                return null;
            };

            /**
             * Creates a DropTableResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.DropTableResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.DropTableResponse} DropTableResponse
             */
            DropTableResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.DropTableResponse)
                    return object;
                var message = new $root.Ydb.Table.DropTableResponse();
                if (object.operation != null) {
                    if (typeof object.operation !== "object")
                        throw TypeError(".Ydb.Table.DropTableResponse.operation: object expected");
                    message.operation = $root.Ydb.Operations.Operation.fromObject(object.operation);
                }
                return message;
            };

            /**
             * Creates a plain object from a DropTableResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.DropTableResponse
             * @static
             * @param {Ydb.Table.DropTableResponse} message DropTableResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DropTableResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.operation = null;
                if (message.operation != null && message.hasOwnProperty("operation"))
                    object.operation = $root.Ydb.Operations.Operation.toObject(message.operation, options);
                return object;
            };

            /**
             * Converts this DropTableResponse to JSON.
             * @function toJSON
             * @memberof Ydb.Table.DropTableResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DropTableResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DropTableResponse;
        })();

        Table.AlterTableRequest = (function() {

            /**
             * Properties of an AlterTableRequest.
             * @memberof Ydb.Table
             * @interface IAlterTableRequest
             * @property {string|null} [sessionId] AlterTableRequest sessionId
             * @property {string|null} [path] AlterTableRequest path
             * @property {Array.<Ydb.Table.IColumnMeta>|null} [addColumns] AlterTableRequest addColumns
             * @property {Array.<string>|null} [dropColumns] AlterTableRequest dropColumns
             * @property {Ydb.Operations.IOperationParams|null} [operationParams] AlterTableRequest operationParams
             * @property {Array.<Ydb.Table.IColumnMeta>|null} [alterColumns] AlterTableRequest alterColumns
             * @property {Ydb.Table.ITtlSettings|null} [setTtlSettings] AlterTableRequest setTtlSettings
             * @property {google.protobuf.IEmpty|null} [dropTtlSettings] AlterTableRequest dropTtlSettings
             * @property {Array.<Ydb.Table.ITableIndex>|null} [addIndexes] AlterTableRequest addIndexes
             * @property {Array.<string>|null} [dropIndexes] AlterTableRequest dropIndexes
             * @property {Ydb.Table.IStorageSettings|null} [alterStorageSettings] AlterTableRequest alterStorageSettings
             * @property {Array.<Ydb.Table.IColumnFamily>|null} [addColumnFamilies] AlterTableRequest addColumnFamilies
             * @property {Array.<Ydb.Table.IColumnFamily>|null} [alterColumnFamilies] AlterTableRequest alterColumnFamilies
             * @property {Object.<string,string>|null} [alterAttributes] AlterTableRequest alterAttributes
             * @property {string|null} [setCompactionPolicy] AlterTableRequest setCompactionPolicy
             * @property {Ydb.Table.IPartitioningSettings|null} [alterPartitioningSettings] AlterTableRequest alterPartitioningSettings
             * @property {Ydb.FeatureFlag.Status|null} [setKeyBloomFilter] AlterTableRequest setKeyBloomFilter
             * @property {Ydb.Table.IReadReplicasSettings|null} [setReadReplicasSettings] AlterTableRequest setReadReplicasSettings
             */

            /**
             * Constructs a new AlterTableRequest.
             * @memberof Ydb.Table
             * @classdesc Represents an AlterTableRequest.
             * @implements IAlterTableRequest
             * @constructor
             * @param {Ydb.Table.IAlterTableRequest=} [properties] Properties to set
             */
            function AlterTableRequest(properties) {
                this.addColumns = [];
                this.dropColumns = [];
                this.alterColumns = [];
                this.addIndexes = [];
                this.dropIndexes = [];
                this.addColumnFamilies = [];
                this.alterColumnFamilies = [];
                this.alterAttributes = {};
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AlterTableRequest sessionId.
             * @member {string} sessionId
             * @memberof Ydb.Table.AlterTableRequest
             * @instance
             */
            AlterTableRequest.prototype.sessionId = "";

            /**
             * AlterTableRequest path.
             * @member {string} path
             * @memberof Ydb.Table.AlterTableRequest
             * @instance
             */
            AlterTableRequest.prototype.path = "";

            /**
             * AlterTableRequest addColumns.
             * @member {Array.<Ydb.Table.IColumnMeta>} addColumns
             * @memberof Ydb.Table.AlterTableRequest
             * @instance
             */
            AlterTableRequest.prototype.addColumns = $util.emptyArray;

            /**
             * AlterTableRequest dropColumns.
             * @member {Array.<string>} dropColumns
             * @memberof Ydb.Table.AlterTableRequest
             * @instance
             */
            AlterTableRequest.prototype.dropColumns = $util.emptyArray;

            /**
             * AlterTableRequest operationParams.
             * @member {Ydb.Operations.IOperationParams|null|undefined} operationParams
             * @memberof Ydb.Table.AlterTableRequest
             * @instance
             */
            AlterTableRequest.prototype.operationParams = null;

            /**
             * AlterTableRequest alterColumns.
             * @member {Array.<Ydb.Table.IColumnMeta>} alterColumns
             * @memberof Ydb.Table.AlterTableRequest
             * @instance
             */
            AlterTableRequest.prototype.alterColumns = $util.emptyArray;

            /**
             * AlterTableRequest setTtlSettings.
             * @member {Ydb.Table.ITtlSettings|null|undefined} setTtlSettings
             * @memberof Ydb.Table.AlterTableRequest
             * @instance
             */
            AlterTableRequest.prototype.setTtlSettings = null;

            /**
             * AlterTableRequest dropTtlSettings.
             * @member {google.protobuf.IEmpty|null|undefined} dropTtlSettings
             * @memberof Ydb.Table.AlterTableRequest
             * @instance
             */
            AlterTableRequest.prototype.dropTtlSettings = null;

            /**
             * AlterTableRequest addIndexes.
             * @member {Array.<Ydb.Table.ITableIndex>} addIndexes
             * @memberof Ydb.Table.AlterTableRequest
             * @instance
             */
            AlterTableRequest.prototype.addIndexes = $util.emptyArray;

            /**
             * AlterTableRequest dropIndexes.
             * @member {Array.<string>} dropIndexes
             * @memberof Ydb.Table.AlterTableRequest
             * @instance
             */
            AlterTableRequest.prototype.dropIndexes = $util.emptyArray;

            /**
             * AlterTableRequest alterStorageSettings.
             * @member {Ydb.Table.IStorageSettings|null|undefined} alterStorageSettings
             * @memberof Ydb.Table.AlterTableRequest
             * @instance
             */
            AlterTableRequest.prototype.alterStorageSettings = null;

            /**
             * AlterTableRequest addColumnFamilies.
             * @member {Array.<Ydb.Table.IColumnFamily>} addColumnFamilies
             * @memberof Ydb.Table.AlterTableRequest
             * @instance
             */
            AlterTableRequest.prototype.addColumnFamilies = $util.emptyArray;

            /**
             * AlterTableRequest alterColumnFamilies.
             * @member {Array.<Ydb.Table.IColumnFamily>} alterColumnFamilies
             * @memberof Ydb.Table.AlterTableRequest
             * @instance
             */
            AlterTableRequest.prototype.alterColumnFamilies = $util.emptyArray;

            /**
             * AlterTableRequest alterAttributes.
             * @member {Object.<string,string>} alterAttributes
             * @memberof Ydb.Table.AlterTableRequest
             * @instance
             */
            AlterTableRequest.prototype.alterAttributes = $util.emptyObject;

            /**
             * AlterTableRequest setCompactionPolicy.
             * @member {string} setCompactionPolicy
             * @memberof Ydb.Table.AlterTableRequest
             * @instance
             */
            AlterTableRequest.prototype.setCompactionPolicy = "";

            /**
             * AlterTableRequest alterPartitioningSettings.
             * @member {Ydb.Table.IPartitioningSettings|null|undefined} alterPartitioningSettings
             * @memberof Ydb.Table.AlterTableRequest
             * @instance
             */
            AlterTableRequest.prototype.alterPartitioningSettings = null;

            /**
             * AlterTableRequest setKeyBloomFilter.
             * @member {Ydb.FeatureFlag.Status} setKeyBloomFilter
             * @memberof Ydb.Table.AlterTableRequest
             * @instance
             */
            AlterTableRequest.prototype.setKeyBloomFilter = 0;

            /**
             * AlterTableRequest setReadReplicasSettings.
             * @member {Ydb.Table.IReadReplicasSettings|null|undefined} setReadReplicasSettings
             * @memberof Ydb.Table.AlterTableRequest
             * @instance
             */
            AlterTableRequest.prototype.setReadReplicasSettings = null;

            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;

            /**
             * AlterTableRequest ttlAction.
             * @member {"setTtlSettings"|"dropTtlSettings"|undefined} ttlAction
             * @memberof Ydb.Table.AlterTableRequest
             * @instance
             */
            Object.defineProperty(AlterTableRequest.prototype, "ttlAction", {
                get: $util.oneOfGetter($oneOfFields = ["setTtlSettings", "dropTtlSettings"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new AlterTableRequest instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.AlterTableRequest
             * @static
             * @param {Ydb.Table.IAlterTableRequest=} [properties] Properties to set
             * @returns {Ydb.Table.AlterTableRequest} AlterTableRequest instance
             */
            AlterTableRequest.create = function create(properties) {
                return new AlterTableRequest(properties);
            };

            /**
             * Encodes the specified AlterTableRequest message. Does not implicitly {@link Ydb.Table.AlterTableRequest.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.AlterTableRequest
             * @static
             * @param {Ydb.Table.IAlterTableRequest} message AlterTableRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AlterTableRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.sessionId != null && Object.hasOwnProperty.call(message, "sessionId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.sessionId);
                if (message.path != null && Object.hasOwnProperty.call(message, "path"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.path);
                if (message.addColumns != null && message.addColumns.length)
                    for (var i = 0; i < message.addColumns.length; ++i)
                        $root.Ydb.Table.ColumnMeta.encode(message.addColumns[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.dropColumns != null && message.dropColumns.length)
                    for (var i = 0; i < message.dropColumns.length; ++i)
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.dropColumns[i]);
                if (message.operationParams != null && Object.hasOwnProperty.call(message, "operationParams"))
                    $root.Ydb.Operations.OperationParams.encode(message.operationParams, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.alterColumns != null && message.alterColumns.length)
                    for (var i = 0; i < message.alterColumns.length; ++i)
                        $root.Ydb.Table.ColumnMeta.encode(message.alterColumns[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.setTtlSettings != null && Object.hasOwnProperty.call(message, "setTtlSettings"))
                    $root.Ydb.Table.TtlSettings.encode(message.setTtlSettings, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.dropTtlSettings != null && Object.hasOwnProperty.call(message, "dropTtlSettings"))
                    $root.google.protobuf.Empty.encode(message.dropTtlSettings, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                if (message.addIndexes != null && message.addIndexes.length)
                    for (var i = 0; i < message.addIndexes.length; ++i)
                        $root.Ydb.Table.TableIndex.encode(message.addIndexes[i], writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                if (message.dropIndexes != null && message.dropIndexes.length)
                    for (var i = 0; i < message.dropIndexes.length; ++i)
                        writer.uint32(/* id 10, wireType 2 =*/82).string(message.dropIndexes[i]);
                if (message.alterStorageSettings != null && Object.hasOwnProperty.call(message, "alterStorageSettings"))
                    $root.Ydb.Table.StorageSettings.encode(message.alterStorageSettings, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                if (message.addColumnFamilies != null && message.addColumnFamilies.length)
                    for (var i = 0; i < message.addColumnFamilies.length; ++i)
                        $root.Ydb.Table.ColumnFamily.encode(message.addColumnFamilies[i], writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
                if (message.alterColumnFamilies != null && message.alterColumnFamilies.length)
                    for (var i = 0; i < message.alterColumnFamilies.length; ++i)
                        $root.Ydb.Table.ColumnFamily.encode(message.alterColumnFamilies[i], writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
                if (message.alterAttributes != null && Object.hasOwnProperty.call(message, "alterAttributes"))
                    for (var keys = Object.keys(message.alterAttributes), i = 0; i < keys.length; ++i)
                        writer.uint32(/* id 14, wireType 2 =*/114).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.alterAttributes[keys[i]]).ldelim();
                if (message.setCompactionPolicy != null && Object.hasOwnProperty.call(message, "setCompactionPolicy"))
                    writer.uint32(/* id 15, wireType 2 =*/122).string(message.setCompactionPolicy);
                if (message.alterPartitioningSettings != null && Object.hasOwnProperty.call(message, "alterPartitioningSettings"))
                    $root.Ydb.Table.PartitioningSettings.encode(message.alterPartitioningSettings, writer.uint32(/* id 16, wireType 2 =*/130).fork()).ldelim();
                if (message.setKeyBloomFilter != null && Object.hasOwnProperty.call(message, "setKeyBloomFilter"))
                    writer.uint32(/* id 17, wireType 0 =*/136).int32(message.setKeyBloomFilter);
                if (message.setReadReplicasSettings != null && Object.hasOwnProperty.call(message, "setReadReplicasSettings"))
                    $root.Ydb.Table.ReadReplicasSettings.encode(message.setReadReplicasSettings, writer.uint32(/* id 18, wireType 2 =*/146).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified AlterTableRequest message, length delimited. Does not implicitly {@link Ydb.Table.AlterTableRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.AlterTableRequest
             * @static
             * @param {Ydb.Table.IAlterTableRequest} message AlterTableRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AlterTableRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AlterTableRequest message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.AlterTableRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.AlterTableRequest} AlterTableRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AlterTableRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.AlterTableRequest(), key, value;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.sessionId = reader.string();
                        break;
                    case 2:
                        message.path = reader.string();
                        break;
                    case 3:
                        if (!(message.addColumns && message.addColumns.length))
                            message.addColumns = [];
                        message.addColumns.push($root.Ydb.Table.ColumnMeta.decode(reader, reader.uint32()));
                        break;
                    case 4:
                        if (!(message.dropColumns && message.dropColumns.length))
                            message.dropColumns = [];
                        message.dropColumns.push(reader.string());
                        break;
                    case 5:
                        message.operationParams = $root.Ydb.Operations.OperationParams.decode(reader, reader.uint32());
                        break;
                    case 6:
                        if (!(message.alterColumns && message.alterColumns.length))
                            message.alterColumns = [];
                        message.alterColumns.push($root.Ydb.Table.ColumnMeta.decode(reader, reader.uint32()));
                        break;
                    case 7:
                        message.setTtlSettings = $root.Ydb.Table.TtlSettings.decode(reader, reader.uint32());
                        break;
                    case 8:
                        message.dropTtlSettings = $root.google.protobuf.Empty.decode(reader, reader.uint32());
                        break;
                    case 9:
                        if (!(message.addIndexes && message.addIndexes.length))
                            message.addIndexes = [];
                        message.addIndexes.push($root.Ydb.Table.TableIndex.decode(reader, reader.uint32()));
                        break;
                    case 10:
                        if (!(message.dropIndexes && message.dropIndexes.length))
                            message.dropIndexes = [];
                        message.dropIndexes.push(reader.string());
                        break;
                    case 11:
                        message.alterStorageSettings = $root.Ydb.Table.StorageSettings.decode(reader, reader.uint32());
                        break;
                    case 12:
                        if (!(message.addColumnFamilies && message.addColumnFamilies.length))
                            message.addColumnFamilies = [];
                        message.addColumnFamilies.push($root.Ydb.Table.ColumnFamily.decode(reader, reader.uint32()));
                        break;
                    case 13:
                        if (!(message.alterColumnFamilies && message.alterColumnFamilies.length))
                            message.alterColumnFamilies = [];
                        message.alterColumnFamilies.push($root.Ydb.Table.ColumnFamily.decode(reader, reader.uint32()));
                        break;
                    case 14:
                        if (message.alterAttributes === $util.emptyObject)
                            message.alterAttributes = {};
                        var end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = "";
                        while (reader.pos < end2) {
                            var tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = reader.string();
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.alterAttributes[key] = value;
                        break;
                    case 15:
                        message.setCompactionPolicy = reader.string();
                        break;
                    case 16:
                        message.alterPartitioningSettings = $root.Ydb.Table.PartitioningSettings.decode(reader, reader.uint32());
                        break;
                    case 17:
                        message.setKeyBloomFilter = reader.int32();
                        break;
                    case 18:
                        message.setReadReplicasSettings = $root.Ydb.Table.ReadReplicasSettings.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an AlterTableRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.AlterTableRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.AlterTableRequest} AlterTableRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AlterTableRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AlterTableRequest message.
             * @function verify
             * @memberof Ydb.Table.AlterTableRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AlterTableRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.sessionId != null && message.hasOwnProperty("sessionId"))
                    if (!$util.isString(message.sessionId))
                        return "sessionId: string expected";
                if (message.path != null && message.hasOwnProperty("path"))
                    if (!$util.isString(message.path))
                        return "path: string expected";
                if (message.addColumns != null && message.hasOwnProperty("addColumns")) {
                    if (!Array.isArray(message.addColumns))
                        return "addColumns: array expected";
                    for (var i = 0; i < message.addColumns.length; ++i) {
                        var error = $root.Ydb.Table.ColumnMeta.verify(message.addColumns[i]);
                        if (error)
                            return "addColumns." + error;
                    }
                }
                if (message.dropColumns != null && message.hasOwnProperty("dropColumns")) {
                    if (!Array.isArray(message.dropColumns))
                        return "dropColumns: array expected";
                    for (var i = 0; i < message.dropColumns.length; ++i)
                        if (!$util.isString(message.dropColumns[i]))
                            return "dropColumns: string[] expected";
                }
                if (message.operationParams != null && message.hasOwnProperty("operationParams")) {
                    var error = $root.Ydb.Operations.OperationParams.verify(message.operationParams);
                    if (error)
                        return "operationParams." + error;
                }
                if (message.alterColumns != null && message.hasOwnProperty("alterColumns")) {
                    if (!Array.isArray(message.alterColumns))
                        return "alterColumns: array expected";
                    for (var i = 0; i < message.alterColumns.length; ++i) {
                        var error = $root.Ydb.Table.ColumnMeta.verify(message.alterColumns[i]);
                        if (error)
                            return "alterColumns." + error;
                    }
                }
                if (message.setTtlSettings != null && message.hasOwnProperty("setTtlSettings")) {
                    properties.ttlAction = 1;
                    {
                        var error = $root.Ydb.Table.TtlSettings.verify(message.setTtlSettings);
                        if (error)
                            return "setTtlSettings." + error;
                    }
                }
                if (message.dropTtlSettings != null && message.hasOwnProperty("dropTtlSettings")) {
                    if (properties.ttlAction === 1)
                        return "ttlAction: multiple values";
                    properties.ttlAction = 1;
                    {
                        var error = $root.google.protobuf.Empty.verify(message.dropTtlSettings);
                        if (error)
                            return "dropTtlSettings." + error;
                    }
                }
                if (message.addIndexes != null && message.hasOwnProperty("addIndexes")) {
                    if (!Array.isArray(message.addIndexes))
                        return "addIndexes: array expected";
                    for (var i = 0; i < message.addIndexes.length; ++i) {
                        var error = $root.Ydb.Table.TableIndex.verify(message.addIndexes[i]);
                        if (error)
                            return "addIndexes." + error;
                    }
                }
                if (message.dropIndexes != null && message.hasOwnProperty("dropIndexes")) {
                    if (!Array.isArray(message.dropIndexes))
                        return "dropIndexes: array expected";
                    for (var i = 0; i < message.dropIndexes.length; ++i)
                        if (!$util.isString(message.dropIndexes[i]))
                            return "dropIndexes: string[] expected";
                }
                if (message.alterStorageSettings != null && message.hasOwnProperty("alterStorageSettings")) {
                    var error = $root.Ydb.Table.StorageSettings.verify(message.alterStorageSettings);
                    if (error)
                        return "alterStorageSettings." + error;
                }
                if (message.addColumnFamilies != null && message.hasOwnProperty("addColumnFamilies")) {
                    if (!Array.isArray(message.addColumnFamilies))
                        return "addColumnFamilies: array expected";
                    for (var i = 0; i < message.addColumnFamilies.length; ++i) {
                        var error = $root.Ydb.Table.ColumnFamily.verify(message.addColumnFamilies[i]);
                        if (error)
                            return "addColumnFamilies." + error;
                    }
                }
                if (message.alterColumnFamilies != null && message.hasOwnProperty("alterColumnFamilies")) {
                    if (!Array.isArray(message.alterColumnFamilies))
                        return "alterColumnFamilies: array expected";
                    for (var i = 0; i < message.alterColumnFamilies.length; ++i) {
                        var error = $root.Ydb.Table.ColumnFamily.verify(message.alterColumnFamilies[i]);
                        if (error)
                            return "alterColumnFamilies." + error;
                    }
                }
                if (message.alterAttributes != null && message.hasOwnProperty("alterAttributes")) {
                    if (!$util.isObject(message.alterAttributes))
                        return "alterAttributes: object expected";
                    var key = Object.keys(message.alterAttributes);
                    for (var i = 0; i < key.length; ++i)
                        if (!$util.isString(message.alterAttributes[key[i]]))
                            return "alterAttributes: string{k:string} expected";
                }
                if (message.setCompactionPolicy != null && message.hasOwnProperty("setCompactionPolicy"))
                    if (!$util.isString(message.setCompactionPolicy))
                        return "setCompactionPolicy: string expected";
                if (message.alterPartitioningSettings != null && message.hasOwnProperty("alterPartitioningSettings")) {
                    var error = $root.Ydb.Table.PartitioningSettings.verify(message.alterPartitioningSettings);
                    if (error)
                        return "alterPartitioningSettings." + error;
                }
                if (message.setKeyBloomFilter != null && message.hasOwnProperty("setKeyBloomFilter"))
                    switch (message.setKeyBloomFilter) {
                    default:
                        return "setKeyBloomFilter: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                if (message.setReadReplicasSettings != null && message.hasOwnProperty("setReadReplicasSettings")) {
                    var error = $root.Ydb.Table.ReadReplicasSettings.verify(message.setReadReplicasSettings);
                    if (error)
                        return "setReadReplicasSettings." + error;
                }
                return null;
            };

            /**
             * Creates an AlterTableRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.AlterTableRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.AlterTableRequest} AlterTableRequest
             */
            AlterTableRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.AlterTableRequest)
                    return object;
                var message = new $root.Ydb.Table.AlterTableRequest();
                if (object.sessionId != null)
                    message.sessionId = String(object.sessionId);
                if (object.path != null)
                    message.path = String(object.path);
                if (object.addColumns) {
                    if (!Array.isArray(object.addColumns))
                        throw TypeError(".Ydb.Table.AlterTableRequest.addColumns: array expected");
                    message.addColumns = [];
                    for (var i = 0; i < object.addColumns.length; ++i) {
                        if (typeof object.addColumns[i] !== "object")
                            throw TypeError(".Ydb.Table.AlterTableRequest.addColumns: object expected");
                        message.addColumns[i] = $root.Ydb.Table.ColumnMeta.fromObject(object.addColumns[i]);
                    }
                }
                if (object.dropColumns) {
                    if (!Array.isArray(object.dropColumns))
                        throw TypeError(".Ydb.Table.AlterTableRequest.dropColumns: array expected");
                    message.dropColumns = [];
                    for (var i = 0; i < object.dropColumns.length; ++i)
                        message.dropColumns[i] = String(object.dropColumns[i]);
                }
                if (object.operationParams != null) {
                    if (typeof object.operationParams !== "object")
                        throw TypeError(".Ydb.Table.AlterTableRequest.operationParams: object expected");
                    message.operationParams = $root.Ydb.Operations.OperationParams.fromObject(object.operationParams);
                }
                if (object.alterColumns) {
                    if (!Array.isArray(object.alterColumns))
                        throw TypeError(".Ydb.Table.AlterTableRequest.alterColumns: array expected");
                    message.alterColumns = [];
                    for (var i = 0; i < object.alterColumns.length; ++i) {
                        if (typeof object.alterColumns[i] !== "object")
                            throw TypeError(".Ydb.Table.AlterTableRequest.alterColumns: object expected");
                        message.alterColumns[i] = $root.Ydb.Table.ColumnMeta.fromObject(object.alterColumns[i]);
                    }
                }
                if (object.setTtlSettings != null) {
                    if (typeof object.setTtlSettings !== "object")
                        throw TypeError(".Ydb.Table.AlterTableRequest.setTtlSettings: object expected");
                    message.setTtlSettings = $root.Ydb.Table.TtlSettings.fromObject(object.setTtlSettings);
                }
                if (object.dropTtlSettings != null) {
                    if (typeof object.dropTtlSettings !== "object")
                        throw TypeError(".Ydb.Table.AlterTableRequest.dropTtlSettings: object expected");
                    message.dropTtlSettings = $root.google.protobuf.Empty.fromObject(object.dropTtlSettings);
                }
                if (object.addIndexes) {
                    if (!Array.isArray(object.addIndexes))
                        throw TypeError(".Ydb.Table.AlterTableRequest.addIndexes: array expected");
                    message.addIndexes = [];
                    for (var i = 0; i < object.addIndexes.length; ++i) {
                        if (typeof object.addIndexes[i] !== "object")
                            throw TypeError(".Ydb.Table.AlterTableRequest.addIndexes: object expected");
                        message.addIndexes[i] = $root.Ydb.Table.TableIndex.fromObject(object.addIndexes[i]);
                    }
                }
                if (object.dropIndexes) {
                    if (!Array.isArray(object.dropIndexes))
                        throw TypeError(".Ydb.Table.AlterTableRequest.dropIndexes: array expected");
                    message.dropIndexes = [];
                    for (var i = 0; i < object.dropIndexes.length; ++i)
                        message.dropIndexes[i] = String(object.dropIndexes[i]);
                }
                if (object.alterStorageSettings != null) {
                    if (typeof object.alterStorageSettings !== "object")
                        throw TypeError(".Ydb.Table.AlterTableRequest.alterStorageSettings: object expected");
                    message.alterStorageSettings = $root.Ydb.Table.StorageSettings.fromObject(object.alterStorageSettings);
                }
                if (object.addColumnFamilies) {
                    if (!Array.isArray(object.addColumnFamilies))
                        throw TypeError(".Ydb.Table.AlterTableRequest.addColumnFamilies: array expected");
                    message.addColumnFamilies = [];
                    for (var i = 0; i < object.addColumnFamilies.length; ++i) {
                        if (typeof object.addColumnFamilies[i] !== "object")
                            throw TypeError(".Ydb.Table.AlterTableRequest.addColumnFamilies: object expected");
                        message.addColumnFamilies[i] = $root.Ydb.Table.ColumnFamily.fromObject(object.addColumnFamilies[i]);
                    }
                }
                if (object.alterColumnFamilies) {
                    if (!Array.isArray(object.alterColumnFamilies))
                        throw TypeError(".Ydb.Table.AlterTableRequest.alterColumnFamilies: array expected");
                    message.alterColumnFamilies = [];
                    for (var i = 0; i < object.alterColumnFamilies.length; ++i) {
                        if (typeof object.alterColumnFamilies[i] !== "object")
                            throw TypeError(".Ydb.Table.AlterTableRequest.alterColumnFamilies: object expected");
                        message.alterColumnFamilies[i] = $root.Ydb.Table.ColumnFamily.fromObject(object.alterColumnFamilies[i]);
                    }
                }
                if (object.alterAttributes) {
                    if (typeof object.alterAttributes !== "object")
                        throw TypeError(".Ydb.Table.AlterTableRequest.alterAttributes: object expected");
                    message.alterAttributes = {};
                    for (var keys = Object.keys(object.alterAttributes), i = 0; i < keys.length; ++i)
                        message.alterAttributes[keys[i]] = String(object.alterAttributes[keys[i]]);
                }
                if (object.setCompactionPolicy != null)
                    message.setCompactionPolicy = String(object.setCompactionPolicy);
                if (object.alterPartitioningSettings != null) {
                    if (typeof object.alterPartitioningSettings !== "object")
                        throw TypeError(".Ydb.Table.AlterTableRequest.alterPartitioningSettings: object expected");
                    message.alterPartitioningSettings = $root.Ydb.Table.PartitioningSettings.fromObject(object.alterPartitioningSettings);
                }
                switch (object.setKeyBloomFilter) {
                case "STATUS_UNSPECIFIED":
                case 0:
                    message.setKeyBloomFilter = 0;
                    break;
                case "ENABLED":
                case 1:
                    message.setKeyBloomFilter = 1;
                    break;
                case "DISABLED":
                case 2:
                    message.setKeyBloomFilter = 2;
                    break;
                }
                if (object.setReadReplicasSettings != null) {
                    if (typeof object.setReadReplicasSettings !== "object")
                        throw TypeError(".Ydb.Table.AlterTableRequest.setReadReplicasSettings: object expected");
                    message.setReadReplicasSettings = $root.Ydb.Table.ReadReplicasSettings.fromObject(object.setReadReplicasSettings);
                }
                return message;
            };

            /**
             * Creates a plain object from an AlterTableRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.AlterTableRequest
             * @static
             * @param {Ydb.Table.AlterTableRequest} message AlterTableRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AlterTableRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.addColumns = [];
                    object.dropColumns = [];
                    object.alterColumns = [];
                    object.addIndexes = [];
                    object.dropIndexes = [];
                    object.addColumnFamilies = [];
                    object.alterColumnFamilies = [];
                }
                if (options.objects || options.defaults)
                    object.alterAttributes = {};
                if (options.defaults) {
                    object.sessionId = "";
                    object.path = "";
                    object.operationParams = null;
                    object.alterStorageSettings = null;
                    object.setCompactionPolicy = "";
                    object.alterPartitioningSettings = null;
                    object.setKeyBloomFilter = options.enums === String ? "STATUS_UNSPECIFIED" : 0;
                    object.setReadReplicasSettings = null;
                }
                if (message.sessionId != null && message.hasOwnProperty("sessionId"))
                    object.sessionId = message.sessionId;
                if (message.path != null && message.hasOwnProperty("path"))
                    object.path = message.path;
                if (message.addColumns && message.addColumns.length) {
                    object.addColumns = [];
                    for (var j = 0; j < message.addColumns.length; ++j)
                        object.addColumns[j] = $root.Ydb.Table.ColumnMeta.toObject(message.addColumns[j], options);
                }
                if (message.dropColumns && message.dropColumns.length) {
                    object.dropColumns = [];
                    for (var j = 0; j < message.dropColumns.length; ++j)
                        object.dropColumns[j] = message.dropColumns[j];
                }
                if (message.operationParams != null && message.hasOwnProperty("operationParams"))
                    object.operationParams = $root.Ydb.Operations.OperationParams.toObject(message.operationParams, options);
                if (message.alterColumns && message.alterColumns.length) {
                    object.alterColumns = [];
                    for (var j = 0; j < message.alterColumns.length; ++j)
                        object.alterColumns[j] = $root.Ydb.Table.ColumnMeta.toObject(message.alterColumns[j], options);
                }
                if (message.setTtlSettings != null && message.hasOwnProperty("setTtlSettings")) {
                    object.setTtlSettings = $root.Ydb.Table.TtlSettings.toObject(message.setTtlSettings, options);
                    if (options.oneofs)
                        object.ttlAction = "setTtlSettings";
                }
                if (message.dropTtlSettings != null && message.hasOwnProperty("dropTtlSettings")) {
                    object.dropTtlSettings = $root.google.protobuf.Empty.toObject(message.dropTtlSettings, options);
                    if (options.oneofs)
                        object.ttlAction = "dropTtlSettings";
                }
                if (message.addIndexes && message.addIndexes.length) {
                    object.addIndexes = [];
                    for (var j = 0; j < message.addIndexes.length; ++j)
                        object.addIndexes[j] = $root.Ydb.Table.TableIndex.toObject(message.addIndexes[j], options);
                }
                if (message.dropIndexes && message.dropIndexes.length) {
                    object.dropIndexes = [];
                    for (var j = 0; j < message.dropIndexes.length; ++j)
                        object.dropIndexes[j] = message.dropIndexes[j];
                }
                if (message.alterStorageSettings != null && message.hasOwnProperty("alterStorageSettings"))
                    object.alterStorageSettings = $root.Ydb.Table.StorageSettings.toObject(message.alterStorageSettings, options);
                if (message.addColumnFamilies && message.addColumnFamilies.length) {
                    object.addColumnFamilies = [];
                    for (var j = 0; j < message.addColumnFamilies.length; ++j)
                        object.addColumnFamilies[j] = $root.Ydb.Table.ColumnFamily.toObject(message.addColumnFamilies[j], options);
                }
                if (message.alterColumnFamilies && message.alterColumnFamilies.length) {
                    object.alterColumnFamilies = [];
                    for (var j = 0; j < message.alterColumnFamilies.length; ++j)
                        object.alterColumnFamilies[j] = $root.Ydb.Table.ColumnFamily.toObject(message.alterColumnFamilies[j], options);
                }
                var keys2;
                if (message.alterAttributes && (keys2 = Object.keys(message.alterAttributes)).length) {
                    object.alterAttributes = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.alterAttributes[keys2[j]] = message.alterAttributes[keys2[j]];
                }
                if (message.setCompactionPolicy != null && message.hasOwnProperty("setCompactionPolicy"))
                    object.setCompactionPolicy = message.setCompactionPolicy;
                if (message.alterPartitioningSettings != null && message.hasOwnProperty("alterPartitioningSettings"))
                    object.alterPartitioningSettings = $root.Ydb.Table.PartitioningSettings.toObject(message.alterPartitioningSettings, options);
                if (message.setKeyBloomFilter != null && message.hasOwnProperty("setKeyBloomFilter"))
                    object.setKeyBloomFilter = options.enums === String ? $root.Ydb.FeatureFlag.Status[message.setKeyBloomFilter] : message.setKeyBloomFilter;
                if (message.setReadReplicasSettings != null && message.hasOwnProperty("setReadReplicasSettings"))
                    object.setReadReplicasSettings = $root.Ydb.Table.ReadReplicasSettings.toObject(message.setReadReplicasSettings, options);
                return object;
            };

            /**
             * Converts this AlterTableRequest to JSON.
             * @function toJSON
             * @memberof Ydb.Table.AlterTableRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AlterTableRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return AlterTableRequest;
        })();

        Table.AlterTableResponse = (function() {

            /**
             * Properties of an AlterTableResponse.
             * @memberof Ydb.Table
             * @interface IAlterTableResponse
             * @property {Ydb.Operations.IOperation|null} [operation] AlterTableResponse operation
             */

            /**
             * Constructs a new AlterTableResponse.
             * @memberof Ydb.Table
             * @classdesc Represents an AlterTableResponse.
             * @implements IAlterTableResponse
             * @constructor
             * @param {Ydb.Table.IAlterTableResponse=} [properties] Properties to set
             */
            function AlterTableResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AlterTableResponse operation.
             * @member {Ydb.Operations.IOperation|null|undefined} operation
             * @memberof Ydb.Table.AlterTableResponse
             * @instance
             */
            AlterTableResponse.prototype.operation = null;

            /**
             * Creates a new AlterTableResponse instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.AlterTableResponse
             * @static
             * @param {Ydb.Table.IAlterTableResponse=} [properties] Properties to set
             * @returns {Ydb.Table.AlterTableResponse} AlterTableResponse instance
             */
            AlterTableResponse.create = function create(properties) {
                return new AlterTableResponse(properties);
            };

            /**
             * Encodes the specified AlterTableResponse message. Does not implicitly {@link Ydb.Table.AlterTableResponse.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.AlterTableResponse
             * @static
             * @param {Ydb.Table.IAlterTableResponse} message AlterTableResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AlterTableResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.operation != null && Object.hasOwnProperty.call(message, "operation"))
                    $root.Ydb.Operations.Operation.encode(message.operation, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified AlterTableResponse message, length delimited. Does not implicitly {@link Ydb.Table.AlterTableResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.AlterTableResponse
             * @static
             * @param {Ydb.Table.IAlterTableResponse} message AlterTableResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AlterTableResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AlterTableResponse message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.AlterTableResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.AlterTableResponse} AlterTableResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AlterTableResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.AlterTableResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.operation = $root.Ydb.Operations.Operation.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an AlterTableResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.AlterTableResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.AlterTableResponse} AlterTableResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AlterTableResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AlterTableResponse message.
             * @function verify
             * @memberof Ydb.Table.AlterTableResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AlterTableResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.operation != null && message.hasOwnProperty("operation")) {
                    var error = $root.Ydb.Operations.Operation.verify(message.operation);
                    if (error)
                        return "operation." + error;
                }
                return null;
            };

            /**
             * Creates an AlterTableResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.AlterTableResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.AlterTableResponse} AlterTableResponse
             */
            AlterTableResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.AlterTableResponse)
                    return object;
                var message = new $root.Ydb.Table.AlterTableResponse();
                if (object.operation != null) {
                    if (typeof object.operation !== "object")
                        throw TypeError(".Ydb.Table.AlterTableResponse.operation: object expected");
                    message.operation = $root.Ydb.Operations.Operation.fromObject(object.operation);
                }
                return message;
            };

            /**
             * Creates a plain object from an AlterTableResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.AlterTableResponse
             * @static
             * @param {Ydb.Table.AlterTableResponse} message AlterTableResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AlterTableResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.operation = null;
                if (message.operation != null && message.hasOwnProperty("operation"))
                    object.operation = $root.Ydb.Operations.Operation.toObject(message.operation, options);
                return object;
            };

            /**
             * Converts this AlterTableResponse to JSON.
             * @function toJSON
             * @memberof Ydb.Table.AlterTableResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AlterTableResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return AlterTableResponse;
        })();

        Table.CopyTableRequest = (function() {

            /**
             * Properties of a CopyTableRequest.
             * @memberof Ydb.Table
             * @interface ICopyTableRequest
             * @property {string|null} [sessionId] CopyTableRequest sessionId
             * @property {string|null} [sourcePath] CopyTableRequest sourcePath
             * @property {string|null} [destinationPath] CopyTableRequest destinationPath
             * @property {Ydb.Operations.IOperationParams|null} [operationParams] CopyTableRequest operationParams
             */

            /**
             * Constructs a new CopyTableRequest.
             * @memberof Ydb.Table
             * @classdesc Represents a CopyTableRequest.
             * @implements ICopyTableRequest
             * @constructor
             * @param {Ydb.Table.ICopyTableRequest=} [properties] Properties to set
             */
            function CopyTableRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CopyTableRequest sessionId.
             * @member {string} sessionId
             * @memberof Ydb.Table.CopyTableRequest
             * @instance
             */
            CopyTableRequest.prototype.sessionId = "";

            /**
             * CopyTableRequest sourcePath.
             * @member {string} sourcePath
             * @memberof Ydb.Table.CopyTableRequest
             * @instance
             */
            CopyTableRequest.prototype.sourcePath = "";

            /**
             * CopyTableRequest destinationPath.
             * @member {string} destinationPath
             * @memberof Ydb.Table.CopyTableRequest
             * @instance
             */
            CopyTableRequest.prototype.destinationPath = "";

            /**
             * CopyTableRequest operationParams.
             * @member {Ydb.Operations.IOperationParams|null|undefined} operationParams
             * @memberof Ydb.Table.CopyTableRequest
             * @instance
             */
            CopyTableRequest.prototype.operationParams = null;

            /**
             * Creates a new CopyTableRequest instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.CopyTableRequest
             * @static
             * @param {Ydb.Table.ICopyTableRequest=} [properties] Properties to set
             * @returns {Ydb.Table.CopyTableRequest} CopyTableRequest instance
             */
            CopyTableRequest.create = function create(properties) {
                return new CopyTableRequest(properties);
            };

            /**
             * Encodes the specified CopyTableRequest message. Does not implicitly {@link Ydb.Table.CopyTableRequest.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.CopyTableRequest
             * @static
             * @param {Ydb.Table.ICopyTableRequest} message CopyTableRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CopyTableRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.sessionId != null && Object.hasOwnProperty.call(message, "sessionId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.sessionId);
                if (message.sourcePath != null && Object.hasOwnProperty.call(message, "sourcePath"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.sourcePath);
                if (message.destinationPath != null && Object.hasOwnProperty.call(message, "destinationPath"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.destinationPath);
                if (message.operationParams != null && Object.hasOwnProperty.call(message, "operationParams"))
                    $root.Ydb.Operations.OperationParams.encode(message.operationParams, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified CopyTableRequest message, length delimited. Does not implicitly {@link Ydb.Table.CopyTableRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.CopyTableRequest
             * @static
             * @param {Ydb.Table.ICopyTableRequest} message CopyTableRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CopyTableRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CopyTableRequest message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.CopyTableRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.CopyTableRequest} CopyTableRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CopyTableRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.CopyTableRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.sessionId = reader.string();
                        break;
                    case 2:
                        message.sourcePath = reader.string();
                        break;
                    case 3:
                        message.destinationPath = reader.string();
                        break;
                    case 4:
                        message.operationParams = $root.Ydb.Operations.OperationParams.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a CopyTableRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.CopyTableRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.CopyTableRequest} CopyTableRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CopyTableRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CopyTableRequest message.
             * @function verify
             * @memberof Ydb.Table.CopyTableRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CopyTableRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.sessionId != null && message.hasOwnProperty("sessionId"))
                    if (!$util.isString(message.sessionId))
                        return "sessionId: string expected";
                if (message.sourcePath != null && message.hasOwnProperty("sourcePath"))
                    if (!$util.isString(message.sourcePath))
                        return "sourcePath: string expected";
                if (message.destinationPath != null && message.hasOwnProperty("destinationPath"))
                    if (!$util.isString(message.destinationPath))
                        return "destinationPath: string expected";
                if (message.operationParams != null && message.hasOwnProperty("operationParams")) {
                    var error = $root.Ydb.Operations.OperationParams.verify(message.operationParams);
                    if (error)
                        return "operationParams." + error;
                }
                return null;
            };

            /**
             * Creates a CopyTableRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.CopyTableRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.CopyTableRequest} CopyTableRequest
             */
            CopyTableRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.CopyTableRequest)
                    return object;
                var message = new $root.Ydb.Table.CopyTableRequest();
                if (object.sessionId != null)
                    message.sessionId = String(object.sessionId);
                if (object.sourcePath != null)
                    message.sourcePath = String(object.sourcePath);
                if (object.destinationPath != null)
                    message.destinationPath = String(object.destinationPath);
                if (object.operationParams != null) {
                    if (typeof object.operationParams !== "object")
                        throw TypeError(".Ydb.Table.CopyTableRequest.operationParams: object expected");
                    message.operationParams = $root.Ydb.Operations.OperationParams.fromObject(object.operationParams);
                }
                return message;
            };

            /**
             * Creates a plain object from a CopyTableRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.CopyTableRequest
             * @static
             * @param {Ydb.Table.CopyTableRequest} message CopyTableRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CopyTableRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.sessionId = "";
                    object.sourcePath = "";
                    object.destinationPath = "";
                    object.operationParams = null;
                }
                if (message.sessionId != null && message.hasOwnProperty("sessionId"))
                    object.sessionId = message.sessionId;
                if (message.sourcePath != null && message.hasOwnProperty("sourcePath"))
                    object.sourcePath = message.sourcePath;
                if (message.destinationPath != null && message.hasOwnProperty("destinationPath"))
                    object.destinationPath = message.destinationPath;
                if (message.operationParams != null && message.hasOwnProperty("operationParams"))
                    object.operationParams = $root.Ydb.Operations.OperationParams.toObject(message.operationParams, options);
                return object;
            };

            /**
             * Converts this CopyTableRequest to JSON.
             * @function toJSON
             * @memberof Ydb.Table.CopyTableRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CopyTableRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return CopyTableRequest;
        })();

        Table.CopyTableResponse = (function() {

            /**
             * Properties of a CopyTableResponse.
             * @memberof Ydb.Table
             * @interface ICopyTableResponse
             * @property {Ydb.Operations.IOperation|null} [operation] CopyTableResponse operation
             */

            /**
             * Constructs a new CopyTableResponse.
             * @memberof Ydb.Table
             * @classdesc Represents a CopyTableResponse.
             * @implements ICopyTableResponse
             * @constructor
             * @param {Ydb.Table.ICopyTableResponse=} [properties] Properties to set
             */
            function CopyTableResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CopyTableResponse operation.
             * @member {Ydb.Operations.IOperation|null|undefined} operation
             * @memberof Ydb.Table.CopyTableResponse
             * @instance
             */
            CopyTableResponse.prototype.operation = null;

            /**
             * Creates a new CopyTableResponse instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.CopyTableResponse
             * @static
             * @param {Ydb.Table.ICopyTableResponse=} [properties] Properties to set
             * @returns {Ydb.Table.CopyTableResponse} CopyTableResponse instance
             */
            CopyTableResponse.create = function create(properties) {
                return new CopyTableResponse(properties);
            };

            /**
             * Encodes the specified CopyTableResponse message. Does not implicitly {@link Ydb.Table.CopyTableResponse.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.CopyTableResponse
             * @static
             * @param {Ydb.Table.ICopyTableResponse} message CopyTableResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CopyTableResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.operation != null && Object.hasOwnProperty.call(message, "operation"))
                    $root.Ydb.Operations.Operation.encode(message.operation, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified CopyTableResponse message, length delimited. Does not implicitly {@link Ydb.Table.CopyTableResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.CopyTableResponse
             * @static
             * @param {Ydb.Table.ICopyTableResponse} message CopyTableResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CopyTableResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CopyTableResponse message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.CopyTableResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.CopyTableResponse} CopyTableResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CopyTableResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.CopyTableResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.operation = $root.Ydb.Operations.Operation.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a CopyTableResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.CopyTableResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.CopyTableResponse} CopyTableResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CopyTableResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CopyTableResponse message.
             * @function verify
             * @memberof Ydb.Table.CopyTableResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CopyTableResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.operation != null && message.hasOwnProperty("operation")) {
                    var error = $root.Ydb.Operations.Operation.verify(message.operation);
                    if (error)
                        return "operation." + error;
                }
                return null;
            };

            /**
             * Creates a CopyTableResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.CopyTableResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.CopyTableResponse} CopyTableResponse
             */
            CopyTableResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.CopyTableResponse)
                    return object;
                var message = new $root.Ydb.Table.CopyTableResponse();
                if (object.operation != null) {
                    if (typeof object.operation !== "object")
                        throw TypeError(".Ydb.Table.CopyTableResponse.operation: object expected");
                    message.operation = $root.Ydb.Operations.Operation.fromObject(object.operation);
                }
                return message;
            };

            /**
             * Creates a plain object from a CopyTableResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.CopyTableResponse
             * @static
             * @param {Ydb.Table.CopyTableResponse} message CopyTableResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CopyTableResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.operation = null;
                if (message.operation != null && message.hasOwnProperty("operation"))
                    object.operation = $root.Ydb.Operations.Operation.toObject(message.operation, options);
                return object;
            };

            /**
             * Converts this CopyTableResponse to JSON.
             * @function toJSON
             * @memberof Ydb.Table.CopyTableResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CopyTableResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return CopyTableResponse;
        })();

        Table.CopyTableItem = (function() {

            /**
             * Properties of a CopyTableItem.
             * @memberof Ydb.Table
             * @interface ICopyTableItem
             * @property {string|null} [sourcePath] CopyTableItem sourcePath
             * @property {string|null} [destinationPath] CopyTableItem destinationPath
             * @property {boolean|null} [omitIndexes] CopyTableItem omitIndexes
             */

            /**
             * Constructs a new CopyTableItem.
             * @memberof Ydb.Table
             * @classdesc Represents a CopyTableItem.
             * @implements ICopyTableItem
             * @constructor
             * @param {Ydb.Table.ICopyTableItem=} [properties] Properties to set
             */
            function CopyTableItem(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CopyTableItem sourcePath.
             * @member {string} sourcePath
             * @memberof Ydb.Table.CopyTableItem
             * @instance
             */
            CopyTableItem.prototype.sourcePath = "";

            /**
             * CopyTableItem destinationPath.
             * @member {string} destinationPath
             * @memberof Ydb.Table.CopyTableItem
             * @instance
             */
            CopyTableItem.prototype.destinationPath = "";

            /**
             * CopyTableItem omitIndexes.
             * @member {boolean} omitIndexes
             * @memberof Ydb.Table.CopyTableItem
             * @instance
             */
            CopyTableItem.prototype.omitIndexes = false;

            /**
             * Creates a new CopyTableItem instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.CopyTableItem
             * @static
             * @param {Ydb.Table.ICopyTableItem=} [properties] Properties to set
             * @returns {Ydb.Table.CopyTableItem} CopyTableItem instance
             */
            CopyTableItem.create = function create(properties) {
                return new CopyTableItem(properties);
            };

            /**
             * Encodes the specified CopyTableItem message. Does not implicitly {@link Ydb.Table.CopyTableItem.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.CopyTableItem
             * @static
             * @param {Ydb.Table.ICopyTableItem} message CopyTableItem message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CopyTableItem.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.sourcePath != null && Object.hasOwnProperty.call(message, "sourcePath"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.sourcePath);
                if (message.destinationPath != null && Object.hasOwnProperty.call(message, "destinationPath"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.destinationPath);
                if (message.omitIndexes != null && Object.hasOwnProperty.call(message, "omitIndexes"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.omitIndexes);
                return writer;
            };

            /**
             * Encodes the specified CopyTableItem message, length delimited. Does not implicitly {@link Ydb.Table.CopyTableItem.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.CopyTableItem
             * @static
             * @param {Ydb.Table.ICopyTableItem} message CopyTableItem message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CopyTableItem.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CopyTableItem message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.CopyTableItem
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.CopyTableItem} CopyTableItem
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CopyTableItem.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.CopyTableItem();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.sourcePath = reader.string();
                        break;
                    case 2:
                        message.destinationPath = reader.string();
                        break;
                    case 3:
                        message.omitIndexes = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a CopyTableItem message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.CopyTableItem
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.CopyTableItem} CopyTableItem
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CopyTableItem.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CopyTableItem message.
             * @function verify
             * @memberof Ydb.Table.CopyTableItem
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CopyTableItem.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.sourcePath != null && message.hasOwnProperty("sourcePath"))
                    if (!$util.isString(message.sourcePath))
                        return "sourcePath: string expected";
                if (message.destinationPath != null && message.hasOwnProperty("destinationPath"))
                    if (!$util.isString(message.destinationPath))
                        return "destinationPath: string expected";
                if (message.omitIndexes != null && message.hasOwnProperty("omitIndexes"))
                    if (typeof message.omitIndexes !== "boolean")
                        return "omitIndexes: boolean expected";
                return null;
            };

            /**
             * Creates a CopyTableItem message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.CopyTableItem
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.CopyTableItem} CopyTableItem
             */
            CopyTableItem.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.CopyTableItem)
                    return object;
                var message = new $root.Ydb.Table.CopyTableItem();
                if (object.sourcePath != null)
                    message.sourcePath = String(object.sourcePath);
                if (object.destinationPath != null)
                    message.destinationPath = String(object.destinationPath);
                if (object.omitIndexes != null)
                    message.omitIndexes = Boolean(object.omitIndexes);
                return message;
            };

            /**
             * Creates a plain object from a CopyTableItem message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.CopyTableItem
             * @static
             * @param {Ydb.Table.CopyTableItem} message CopyTableItem
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CopyTableItem.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.sourcePath = "";
                    object.destinationPath = "";
                    object.omitIndexes = false;
                }
                if (message.sourcePath != null && message.hasOwnProperty("sourcePath"))
                    object.sourcePath = message.sourcePath;
                if (message.destinationPath != null && message.hasOwnProperty("destinationPath"))
                    object.destinationPath = message.destinationPath;
                if (message.omitIndexes != null && message.hasOwnProperty("omitIndexes"))
                    object.omitIndexes = message.omitIndexes;
                return object;
            };

            /**
             * Converts this CopyTableItem to JSON.
             * @function toJSON
             * @memberof Ydb.Table.CopyTableItem
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CopyTableItem.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return CopyTableItem;
        })();

        Table.CopyTablesRequest = (function() {

            /**
             * Properties of a CopyTablesRequest.
             * @memberof Ydb.Table
             * @interface ICopyTablesRequest
             * @property {Ydb.Operations.IOperationParams|null} [operationParams] CopyTablesRequest operationParams
             * @property {string|null} [sessionId] CopyTablesRequest sessionId
             * @property {Array.<Ydb.Table.ICopyTableItem>|null} [tables] CopyTablesRequest tables
             */

            /**
             * Constructs a new CopyTablesRequest.
             * @memberof Ydb.Table
             * @classdesc Represents a CopyTablesRequest.
             * @implements ICopyTablesRequest
             * @constructor
             * @param {Ydb.Table.ICopyTablesRequest=} [properties] Properties to set
             */
            function CopyTablesRequest(properties) {
                this.tables = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CopyTablesRequest operationParams.
             * @member {Ydb.Operations.IOperationParams|null|undefined} operationParams
             * @memberof Ydb.Table.CopyTablesRequest
             * @instance
             */
            CopyTablesRequest.prototype.operationParams = null;

            /**
             * CopyTablesRequest sessionId.
             * @member {string} sessionId
             * @memberof Ydb.Table.CopyTablesRequest
             * @instance
             */
            CopyTablesRequest.prototype.sessionId = "";

            /**
             * CopyTablesRequest tables.
             * @member {Array.<Ydb.Table.ICopyTableItem>} tables
             * @memberof Ydb.Table.CopyTablesRequest
             * @instance
             */
            CopyTablesRequest.prototype.tables = $util.emptyArray;

            /**
             * Creates a new CopyTablesRequest instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.CopyTablesRequest
             * @static
             * @param {Ydb.Table.ICopyTablesRequest=} [properties] Properties to set
             * @returns {Ydb.Table.CopyTablesRequest} CopyTablesRequest instance
             */
            CopyTablesRequest.create = function create(properties) {
                return new CopyTablesRequest(properties);
            };

            /**
             * Encodes the specified CopyTablesRequest message. Does not implicitly {@link Ydb.Table.CopyTablesRequest.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.CopyTablesRequest
             * @static
             * @param {Ydb.Table.ICopyTablesRequest} message CopyTablesRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CopyTablesRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.operationParams != null && Object.hasOwnProperty.call(message, "operationParams"))
                    $root.Ydb.Operations.OperationParams.encode(message.operationParams, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.sessionId != null && Object.hasOwnProperty.call(message, "sessionId"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.sessionId);
                if (message.tables != null && message.tables.length)
                    for (var i = 0; i < message.tables.length; ++i)
                        $root.Ydb.Table.CopyTableItem.encode(message.tables[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified CopyTablesRequest message, length delimited. Does not implicitly {@link Ydb.Table.CopyTablesRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.CopyTablesRequest
             * @static
             * @param {Ydb.Table.ICopyTablesRequest} message CopyTablesRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CopyTablesRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CopyTablesRequest message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.CopyTablesRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.CopyTablesRequest} CopyTablesRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CopyTablesRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.CopyTablesRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.operationParams = $root.Ydb.Operations.OperationParams.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.sessionId = reader.string();
                        break;
                    case 3:
                        if (!(message.tables && message.tables.length))
                            message.tables = [];
                        message.tables.push($root.Ydb.Table.CopyTableItem.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a CopyTablesRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.CopyTablesRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.CopyTablesRequest} CopyTablesRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CopyTablesRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CopyTablesRequest message.
             * @function verify
             * @memberof Ydb.Table.CopyTablesRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CopyTablesRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.operationParams != null && message.hasOwnProperty("operationParams")) {
                    var error = $root.Ydb.Operations.OperationParams.verify(message.operationParams);
                    if (error)
                        return "operationParams." + error;
                }
                if (message.sessionId != null && message.hasOwnProperty("sessionId"))
                    if (!$util.isString(message.sessionId))
                        return "sessionId: string expected";
                if (message.tables != null && message.hasOwnProperty("tables")) {
                    if (!Array.isArray(message.tables))
                        return "tables: array expected";
                    for (var i = 0; i < message.tables.length; ++i) {
                        var error = $root.Ydb.Table.CopyTableItem.verify(message.tables[i]);
                        if (error)
                            return "tables." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a CopyTablesRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.CopyTablesRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.CopyTablesRequest} CopyTablesRequest
             */
            CopyTablesRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.CopyTablesRequest)
                    return object;
                var message = new $root.Ydb.Table.CopyTablesRequest();
                if (object.operationParams != null) {
                    if (typeof object.operationParams !== "object")
                        throw TypeError(".Ydb.Table.CopyTablesRequest.operationParams: object expected");
                    message.operationParams = $root.Ydb.Operations.OperationParams.fromObject(object.operationParams);
                }
                if (object.sessionId != null)
                    message.sessionId = String(object.sessionId);
                if (object.tables) {
                    if (!Array.isArray(object.tables))
                        throw TypeError(".Ydb.Table.CopyTablesRequest.tables: array expected");
                    message.tables = [];
                    for (var i = 0; i < object.tables.length; ++i) {
                        if (typeof object.tables[i] !== "object")
                            throw TypeError(".Ydb.Table.CopyTablesRequest.tables: object expected");
                        message.tables[i] = $root.Ydb.Table.CopyTableItem.fromObject(object.tables[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a CopyTablesRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.CopyTablesRequest
             * @static
             * @param {Ydb.Table.CopyTablesRequest} message CopyTablesRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CopyTablesRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.tables = [];
                if (options.defaults) {
                    object.operationParams = null;
                    object.sessionId = "";
                }
                if (message.operationParams != null && message.hasOwnProperty("operationParams"))
                    object.operationParams = $root.Ydb.Operations.OperationParams.toObject(message.operationParams, options);
                if (message.sessionId != null && message.hasOwnProperty("sessionId"))
                    object.sessionId = message.sessionId;
                if (message.tables && message.tables.length) {
                    object.tables = [];
                    for (var j = 0; j < message.tables.length; ++j)
                        object.tables[j] = $root.Ydb.Table.CopyTableItem.toObject(message.tables[j], options);
                }
                return object;
            };

            /**
             * Converts this CopyTablesRequest to JSON.
             * @function toJSON
             * @memberof Ydb.Table.CopyTablesRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CopyTablesRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return CopyTablesRequest;
        })();

        Table.CopyTablesResponse = (function() {

            /**
             * Properties of a CopyTablesResponse.
             * @memberof Ydb.Table
             * @interface ICopyTablesResponse
             * @property {Ydb.Operations.IOperation|null} [operation] CopyTablesResponse operation
             */

            /**
             * Constructs a new CopyTablesResponse.
             * @memberof Ydb.Table
             * @classdesc Represents a CopyTablesResponse.
             * @implements ICopyTablesResponse
             * @constructor
             * @param {Ydb.Table.ICopyTablesResponse=} [properties] Properties to set
             */
            function CopyTablesResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CopyTablesResponse operation.
             * @member {Ydb.Operations.IOperation|null|undefined} operation
             * @memberof Ydb.Table.CopyTablesResponse
             * @instance
             */
            CopyTablesResponse.prototype.operation = null;

            /**
             * Creates a new CopyTablesResponse instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.CopyTablesResponse
             * @static
             * @param {Ydb.Table.ICopyTablesResponse=} [properties] Properties to set
             * @returns {Ydb.Table.CopyTablesResponse} CopyTablesResponse instance
             */
            CopyTablesResponse.create = function create(properties) {
                return new CopyTablesResponse(properties);
            };

            /**
             * Encodes the specified CopyTablesResponse message. Does not implicitly {@link Ydb.Table.CopyTablesResponse.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.CopyTablesResponse
             * @static
             * @param {Ydb.Table.ICopyTablesResponse} message CopyTablesResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CopyTablesResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.operation != null && Object.hasOwnProperty.call(message, "operation"))
                    $root.Ydb.Operations.Operation.encode(message.operation, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified CopyTablesResponse message, length delimited. Does not implicitly {@link Ydb.Table.CopyTablesResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.CopyTablesResponse
             * @static
             * @param {Ydb.Table.ICopyTablesResponse} message CopyTablesResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CopyTablesResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CopyTablesResponse message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.CopyTablesResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.CopyTablesResponse} CopyTablesResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CopyTablesResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.CopyTablesResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.operation = $root.Ydb.Operations.Operation.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a CopyTablesResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.CopyTablesResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.CopyTablesResponse} CopyTablesResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CopyTablesResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CopyTablesResponse message.
             * @function verify
             * @memberof Ydb.Table.CopyTablesResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CopyTablesResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.operation != null && message.hasOwnProperty("operation")) {
                    var error = $root.Ydb.Operations.Operation.verify(message.operation);
                    if (error)
                        return "operation." + error;
                }
                return null;
            };

            /**
             * Creates a CopyTablesResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.CopyTablesResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.CopyTablesResponse} CopyTablesResponse
             */
            CopyTablesResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.CopyTablesResponse)
                    return object;
                var message = new $root.Ydb.Table.CopyTablesResponse();
                if (object.operation != null) {
                    if (typeof object.operation !== "object")
                        throw TypeError(".Ydb.Table.CopyTablesResponse.operation: object expected");
                    message.operation = $root.Ydb.Operations.Operation.fromObject(object.operation);
                }
                return message;
            };

            /**
             * Creates a plain object from a CopyTablesResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.CopyTablesResponse
             * @static
             * @param {Ydb.Table.CopyTablesResponse} message CopyTablesResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CopyTablesResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.operation = null;
                if (message.operation != null && message.hasOwnProperty("operation"))
                    object.operation = $root.Ydb.Operations.Operation.toObject(message.operation, options);
                return object;
            };

            /**
             * Converts this CopyTablesResponse to JSON.
             * @function toJSON
             * @memberof Ydb.Table.CopyTablesResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CopyTablesResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return CopyTablesResponse;
        })();

        Table.RenameTableItem = (function() {

            /**
             * Properties of a RenameTableItem.
             * @memberof Ydb.Table
             * @interface IRenameTableItem
             * @property {string|null} [sourcePath] RenameTableItem sourcePath
             * @property {string|null} [destinationPath] RenameTableItem destinationPath
             * @property {boolean|null} [replaceDestination] RenameTableItem replaceDestination
             */

            /**
             * Constructs a new RenameTableItem.
             * @memberof Ydb.Table
             * @classdesc Represents a RenameTableItem.
             * @implements IRenameTableItem
             * @constructor
             * @param {Ydb.Table.IRenameTableItem=} [properties] Properties to set
             */
            function RenameTableItem(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RenameTableItem sourcePath.
             * @member {string} sourcePath
             * @memberof Ydb.Table.RenameTableItem
             * @instance
             */
            RenameTableItem.prototype.sourcePath = "";

            /**
             * RenameTableItem destinationPath.
             * @member {string} destinationPath
             * @memberof Ydb.Table.RenameTableItem
             * @instance
             */
            RenameTableItem.prototype.destinationPath = "";

            /**
             * RenameTableItem replaceDestination.
             * @member {boolean} replaceDestination
             * @memberof Ydb.Table.RenameTableItem
             * @instance
             */
            RenameTableItem.prototype.replaceDestination = false;

            /**
             * Creates a new RenameTableItem instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.RenameTableItem
             * @static
             * @param {Ydb.Table.IRenameTableItem=} [properties] Properties to set
             * @returns {Ydb.Table.RenameTableItem} RenameTableItem instance
             */
            RenameTableItem.create = function create(properties) {
                return new RenameTableItem(properties);
            };

            /**
             * Encodes the specified RenameTableItem message. Does not implicitly {@link Ydb.Table.RenameTableItem.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.RenameTableItem
             * @static
             * @param {Ydb.Table.IRenameTableItem} message RenameTableItem message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RenameTableItem.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.sourcePath != null && Object.hasOwnProperty.call(message, "sourcePath"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.sourcePath);
                if (message.destinationPath != null && Object.hasOwnProperty.call(message, "destinationPath"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.destinationPath);
                if (message.replaceDestination != null && Object.hasOwnProperty.call(message, "replaceDestination"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.replaceDestination);
                return writer;
            };

            /**
             * Encodes the specified RenameTableItem message, length delimited. Does not implicitly {@link Ydb.Table.RenameTableItem.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.RenameTableItem
             * @static
             * @param {Ydb.Table.IRenameTableItem} message RenameTableItem message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RenameTableItem.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RenameTableItem message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.RenameTableItem
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.RenameTableItem} RenameTableItem
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RenameTableItem.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.RenameTableItem();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.sourcePath = reader.string();
                        break;
                    case 2:
                        message.destinationPath = reader.string();
                        break;
                    case 3:
                        message.replaceDestination = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RenameTableItem message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.RenameTableItem
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.RenameTableItem} RenameTableItem
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RenameTableItem.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RenameTableItem message.
             * @function verify
             * @memberof Ydb.Table.RenameTableItem
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RenameTableItem.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.sourcePath != null && message.hasOwnProperty("sourcePath"))
                    if (!$util.isString(message.sourcePath))
                        return "sourcePath: string expected";
                if (message.destinationPath != null && message.hasOwnProperty("destinationPath"))
                    if (!$util.isString(message.destinationPath))
                        return "destinationPath: string expected";
                if (message.replaceDestination != null && message.hasOwnProperty("replaceDestination"))
                    if (typeof message.replaceDestination !== "boolean")
                        return "replaceDestination: boolean expected";
                return null;
            };

            /**
             * Creates a RenameTableItem message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.RenameTableItem
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.RenameTableItem} RenameTableItem
             */
            RenameTableItem.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.RenameTableItem)
                    return object;
                var message = new $root.Ydb.Table.RenameTableItem();
                if (object.sourcePath != null)
                    message.sourcePath = String(object.sourcePath);
                if (object.destinationPath != null)
                    message.destinationPath = String(object.destinationPath);
                if (object.replaceDestination != null)
                    message.replaceDestination = Boolean(object.replaceDestination);
                return message;
            };

            /**
             * Creates a plain object from a RenameTableItem message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.RenameTableItem
             * @static
             * @param {Ydb.Table.RenameTableItem} message RenameTableItem
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RenameTableItem.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.sourcePath = "";
                    object.destinationPath = "";
                    object.replaceDestination = false;
                }
                if (message.sourcePath != null && message.hasOwnProperty("sourcePath"))
                    object.sourcePath = message.sourcePath;
                if (message.destinationPath != null && message.hasOwnProperty("destinationPath"))
                    object.destinationPath = message.destinationPath;
                if (message.replaceDestination != null && message.hasOwnProperty("replaceDestination"))
                    object.replaceDestination = message.replaceDestination;
                return object;
            };

            /**
             * Converts this RenameTableItem to JSON.
             * @function toJSON
             * @memberof Ydb.Table.RenameTableItem
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RenameTableItem.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RenameTableItem;
        })();

        Table.RenameTablesRequest = (function() {

            /**
             * Properties of a RenameTablesRequest.
             * @memberof Ydb.Table
             * @interface IRenameTablesRequest
             * @property {Ydb.Operations.IOperationParams|null} [operationParams] RenameTablesRequest operationParams
             * @property {string|null} [sessionId] RenameTablesRequest sessionId
             * @property {Array.<Ydb.Table.IRenameTableItem>|null} [tables] RenameTablesRequest tables
             */

            /**
             * Constructs a new RenameTablesRequest.
             * @memberof Ydb.Table
             * @classdesc Represents a RenameTablesRequest.
             * @implements IRenameTablesRequest
             * @constructor
             * @param {Ydb.Table.IRenameTablesRequest=} [properties] Properties to set
             */
            function RenameTablesRequest(properties) {
                this.tables = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RenameTablesRequest operationParams.
             * @member {Ydb.Operations.IOperationParams|null|undefined} operationParams
             * @memberof Ydb.Table.RenameTablesRequest
             * @instance
             */
            RenameTablesRequest.prototype.operationParams = null;

            /**
             * RenameTablesRequest sessionId.
             * @member {string} sessionId
             * @memberof Ydb.Table.RenameTablesRequest
             * @instance
             */
            RenameTablesRequest.prototype.sessionId = "";

            /**
             * RenameTablesRequest tables.
             * @member {Array.<Ydb.Table.IRenameTableItem>} tables
             * @memberof Ydb.Table.RenameTablesRequest
             * @instance
             */
            RenameTablesRequest.prototype.tables = $util.emptyArray;

            /**
             * Creates a new RenameTablesRequest instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.RenameTablesRequest
             * @static
             * @param {Ydb.Table.IRenameTablesRequest=} [properties] Properties to set
             * @returns {Ydb.Table.RenameTablesRequest} RenameTablesRequest instance
             */
            RenameTablesRequest.create = function create(properties) {
                return new RenameTablesRequest(properties);
            };

            /**
             * Encodes the specified RenameTablesRequest message. Does not implicitly {@link Ydb.Table.RenameTablesRequest.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.RenameTablesRequest
             * @static
             * @param {Ydb.Table.IRenameTablesRequest} message RenameTablesRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RenameTablesRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.operationParams != null && Object.hasOwnProperty.call(message, "operationParams"))
                    $root.Ydb.Operations.OperationParams.encode(message.operationParams, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.sessionId != null && Object.hasOwnProperty.call(message, "sessionId"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.sessionId);
                if (message.tables != null && message.tables.length)
                    for (var i = 0; i < message.tables.length; ++i)
                        $root.Ydb.Table.RenameTableItem.encode(message.tables[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified RenameTablesRequest message, length delimited. Does not implicitly {@link Ydb.Table.RenameTablesRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.RenameTablesRequest
             * @static
             * @param {Ydb.Table.IRenameTablesRequest} message RenameTablesRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RenameTablesRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RenameTablesRequest message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.RenameTablesRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.RenameTablesRequest} RenameTablesRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RenameTablesRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.RenameTablesRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.operationParams = $root.Ydb.Operations.OperationParams.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.sessionId = reader.string();
                        break;
                    case 3:
                        if (!(message.tables && message.tables.length))
                            message.tables = [];
                        message.tables.push($root.Ydb.Table.RenameTableItem.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RenameTablesRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.RenameTablesRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.RenameTablesRequest} RenameTablesRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RenameTablesRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RenameTablesRequest message.
             * @function verify
             * @memberof Ydb.Table.RenameTablesRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RenameTablesRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.operationParams != null && message.hasOwnProperty("operationParams")) {
                    var error = $root.Ydb.Operations.OperationParams.verify(message.operationParams);
                    if (error)
                        return "operationParams." + error;
                }
                if (message.sessionId != null && message.hasOwnProperty("sessionId"))
                    if (!$util.isString(message.sessionId))
                        return "sessionId: string expected";
                if (message.tables != null && message.hasOwnProperty("tables")) {
                    if (!Array.isArray(message.tables))
                        return "tables: array expected";
                    for (var i = 0; i < message.tables.length; ++i) {
                        var error = $root.Ydb.Table.RenameTableItem.verify(message.tables[i]);
                        if (error)
                            return "tables." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a RenameTablesRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.RenameTablesRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.RenameTablesRequest} RenameTablesRequest
             */
            RenameTablesRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.RenameTablesRequest)
                    return object;
                var message = new $root.Ydb.Table.RenameTablesRequest();
                if (object.operationParams != null) {
                    if (typeof object.operationParams !== "object")
                        throw TypeError(".Ydb.Table.RenameTablesRequest.operationParams: object expected");
                    message.operationParams = $root.Ydb.Operations.OperationParams.fromObject(object.operationParams);
                }
                if (object.sessionId != null)
                    message.sessionId = String(object.sessionId);
                if (object.tables) {
                    if (!Array.isArray(object.tables))
                        throw TypeError(".Ydb.Table.RenameTablesRequest.tables: array expected");
                    message.tables = [];
                    for (var i = 0; i < object.tables.length; ++i) {
                        if (typeof object.tables[i] !== "object")
                            throw TypeError(".Ydb.Table.RenameTablesRequest.tables: object expected");
                        message.tables[i] = $root.Ydb.Table.RenameTableItem.fromObject(object.tables[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a RenameTablesRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.RenameTablesRequest
             * @static
             * @param {Ydb.Table.RenameTablesRequest} message RenameTablesRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RenameTablesRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.tables = [];
                if (options.defaults) {
                    object.operationParams = null;
                    object.sessionId = "";
                }
                if (message.operationParams != null && message.hasOwnProperty("operationParams"))
                    object.operationParams = $root.Ydb.Operations.OperationParams.toObject(message.operationParams, options);
                if (message.sessionId != null && message.hasOwnProperty("sessionId"))
                    object.sessionId = message.sessionId;
                if (message.tables && message.tables.length) {
                    object.tables = [];
                    for (var j = 0; j < message.tables.length; ++j)
                        object.tables[j] = $root.Ydb.Table.RenameTableItem.toObject(message.tables[j], options);
                }
                return object;
            };

            /**
             * Converts this RenameTablesRequest to JSON.
             * @function toJSON
             * @memberof Ydb.Table.RenameTablesRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RenameTablesRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RenameTablesRequest;
        })();

        Table.RenameTablesResponse = (function() {

            /**
             * Properties of a RenameTablesResponse.
             * @memberof Ydb.Table
             * @interface IRenameTablesResponse
             * @property {Ydb.Operations.IOperation|null} [operation] RenameTablesResponse operation
             */

            /**
             * Constructs a new RenameTablesResponse.
             * @memberof Ydb.Table
             * @classdesc Represents a RenameTablesResponse.
             * @implements IRenameTablesResponse
             * @constructor
             * @param {Ydb.Table.IRenameTablesResponse=} [properties] Properties to set
             */
            function RenameTablesResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RenameTablesResponse operation.
             * @member {Ydb.Operations.IOperation|null|undefined} operation
             * @memberof Ydb.Table.RenameTablesResponse
             * @instance
             */
            RenameTablesResponse.prototype.operation = null;

            /**
             * Creates a new RenameTablesResponse instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.RenameTablesResponse
             * @static
             * @param {Ydb.Table.IRenameTablesResponse=} [properties] Properties to set
             * @returns {Ydb.Table.RenameTablesResponse} RenameTablesResponse instance
             */
            RenameTablesResponse.create = function create(properties) {
                return new RenameTablesResponse(properties);
            };

            /**
             * Encodes the specified RenameTablesResponse message. Does not implicitly {@link Ydb.Table.RenameTablesResponse.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.RenameTablesResponse
             * @static
             * @param {Ydb.Table.IRenameTablesResponse} message RenameTablesResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RenameTablesResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.operation != null && Object.hasOwnProperty.call(message, "operation"))
                    $root.Ydb.Operations.Operation.encode(message.operation, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified RenameTablesResponse message, length delimited. Does not implicitly {@link Ydb.Table.RenameTablesResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.RenameTablesResponse
             * @static
             * @param {Ydb.Table.IRenameTablesResponse} message RenameTablesResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RenameTablesResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RenameTablesResponse message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.RenameTablesResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.RenameTablesResponse} RenameTablesResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RenameTablesResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.RenameTablesResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.operation = $root.Ydb.Operations.Operation.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RenameTablesResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.RenameTablesResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.RenameTablesResponse} RenameTablesResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RenameTablesResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RenameTablesResponse message.
             * @function verify
             * @memberof Ydb.Table.RenameTablesResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RenameTablesResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.operation != null && message.hasOwnProperty("operation")) {
                    var error = $root.Ydb.Operations.Operation.verify(message.operation);
                    if (error)
                        return "operation." + error;
                }
                return null;
            };

            /**
             * Creates a RenameTablesResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.RenameTablesResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.RenameTablesResponse} RenameTablesResponse
             */
            RenameTablesResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.RenameTablesResponse)
                    return object;
                var message = new $root.Ydb.Table.RenameTablesResponse();
                if (object.operation != null) {
                    if (typeof object.operation !== "object")
                        throw TypeError(".Ydb.Table.RenameTablesResponse.operation: object expected");
                    message.operation = $root.Ydb.Operations.Operation.fromObject(object.operation);
                }
                return message;
            };

            /**
             * Creates a plain object from a RenameTablesResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.RenameTablesResponse
             * @static
             * @param {Ydb.Table.RenameTablesResponse} message RenameTablesResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RenameTablesResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.operation = null;
                if (message.operation != null && message.hasOwnProperty("operation"))
                    object.operation = $root.Ydb.Operations.Operation.toObject(message.operation, options);
                return object;
            };

            /**
             * Converts this RenameTablesResponse to JSON.
             * @function toJSON
             * @memberof Ydb.Table.RenameTablesResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RenameTablesResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RenameTablesResponse;
        })();

        Table.DescribeTableRequest = (function() {

            /**
             * Properties of a DescribeTableRequest.
             * @memberof Ydb.Table
             * @interface IDescribeTableRequest
             * @property {string|null} [sessionId] DescribeTableRequest sessionId
             * @property {string|null} [path] DescribeTableRequest path
             * @property {Ydb.Operations.IOperationParams|null} [operationParams] DescribeTableRequest operationParams
             * @property {boolean|null} [includeShardKeyBounds] DescribeTableRequest includeShardKeyBounds
             * @property {boolean|null} [includeTableStats] DescribeTableRequest includeTableStats
             * @property {boolean|null} [includePartitionStats] DescribeTableRequest includePartitionStats
             */

            /**
             * Constructs a new DescribeTableRequest.
             * @memberof Ydb.Table
             * @classdesc Represents a DescribeTableRequest.
             * @implements IDescribeTableRequest
             * @constructor
             * @param {Ydb.Table.IDescribeTableRequest=} [properties] Properties to set
             */
            function DescribeTableRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DescribeTableRequest sessionId.
             * @member {string} sessionId
             * @memberof Ydb.Table.DescribeTableRequest
             * @instance
             */
            DescribeTableRequest.prototype.sessionId = "";

            /**
             * DescribeTableRequest path.
             * @member {string} path
             * @memberof Ydb.Table.DescribeTableRequest
             * @instance
             */
            DescribeTableRequest.prototype.path = "";

            /**
             * DescribeTableRequest operationParams.
             * @member {Ydb.Operations.IOperationParams|null|undefined} operationParams
             * @memberof Ydb.Table.DescribeTableRequest
             * @instance
             */
            DescribeTableRequest.prototype.operationParams = null;

            /**
             * DescribeTableRequest includeShardKeyBounds.
             * @member {boolean} includeShardKeyBounds
             * @memberof Ydb.Table.DescribeTableRequest
             * @instance
             */
            DescribeTableRequest.prototype.includeShardKeyBounds = false;

            /**
             * DescribeTableRequest includeTableStats.
             * @member {boolean} includeTableStats
             * @memberof Ydb.Table.DescribeTableRequest
             * @instance
             */
            DescribeTableRequest.prototype.includeTableStats = false;

            /**
             * DescribeTableRequest includePartitionStats.
             * @member {boolean} includePartitionStats
             * @memberof Ydb.Table.DescribeTableRequest
             * @instance
             */
            DescribeTableRequest.prototype.includePartitionStats = false;

            /**
             * Creates a new DescribeTableRequest instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.DescribeTableRequest
             * @static
             * @param {Ydb.Table.IDescribeTableRequest=} [properties] Properties to set
             * @returns {Ydb.Table.DescribeTableRequest} DescribeTableRequest instance
             */
            DescribeTableRequest.create = function create(properties) {
                return new DescribeTableRequest(properties);
            };

            /**
             * Encodes the specified DescribeTableRequest message. Does not implicitly {@link Ydb.Table.DescribeTableRequest.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.DescribeTableRequest
             * @static
             * @param {Ydb.Table.IDescribeTableRequest} message DescribeTableRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DescribeTableRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.sessionId != null && Object.hasOwnProperty.call(message, "sessionId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.sessionId);
                if (message.path != null && Object.hasOwnProperty.call(message, "path"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.path);
                if (message.operationParams != null && Object.hasOwnProperty.call(message, "operationParams"))
                    $root.Ydb.Operations.OperationParams.encode(message.operationParams, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.includeShardKeyBounds != null && Object.hasOwnProperty.call(message, "includeShardKeyBounds"))
                    writer.uint32(/* id 5, wireType 0 =*/40).bool(message.includeShardKeyBounds);
                if (message.includeTableStats != null && Object.hasOwnProperty.call(message, "includeTableStats"))
                    writer.uint32(/* id 6, wireType 0 =*/48).bool(message.includeTableStats);
                if (message.includePartitionStats != null && Object.hasOwnProperty.call(message, "includePartitionStats"))
                    writer.uint32(/* id 7, wireType 0 =*/56).bool(message.includePartitionStats);
                return writer;
            };

            /**
             * Encodes the specified DescribeTableRequest message, length delimited. Does not implicitly {@link Ydb.Table.DescribeTableRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.DescribeTableRequest
             * @static
             * @param {Ydb.Table.IDescribeTableRequest} message DescribeTableRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DescribeTableRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DescribeTableRequest message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.DescribeTableRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.DescribeTableRequest} DescribeTableRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DescribeTableRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.DescribeTableRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.sessionId = reader.string();
                        break;
                    case 2:
                        message.path = reader.string();
                        break;
                    case 4:
                        message.operationParams = $root.Ydb.Operations.OperationParams.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.includeShardKeyBounds = reader.bool();
                        break;
                    case 6:
                        message.includeTableStats = reader.bool();
                        break;
                    case 7:
                        message.includePartitionStats = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DescribeTableRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.DescribeTableRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.DescribeTableRequest} DescribeTableRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DescribeTableRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DescribeTableRequest message.
             * @function verify
             * @memberof Ydb.Table.DescribeTableRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DescribeTableRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.sessionId != null && message.hasOwnProperty("sessionId"))
                    if (!$util.isString(message.sessionId))
                        return "sessionId: string expected";
                if (message.path != null && message.hasOwnProperty("path"))
                    if (!$util.isString(message.path))
                        return "path: string expected";
                if (message.operationParams != null && message.hasOwnProperty("operationParams")) {
                    var error = $root.Ydb.Operations.OperationParams.verify(message.operationParams);
                    if (error)
                        return "operationParams." + error;
                }
                if (message.includeShardKeyBounds != null && message.hasOwnProperty("includeShardKeyBounds"))
                    if (typeof message.includeShardKeyBounds !== "boolean")
                        return "includeShardKeyBounds: boolean expected";
                if (message.includeTableStats != null && message.hasOwnProperty("includeTableStats"))
                    if (typeof message.includeTableStats !== "boolean")
                        return "includeTableStats: boolean expected";
                if (message.includePartitionStats != null && message.hasOwnProperty("includePartitionStats"))
                    if (typeof message.includePartitionStats !== "boolean")
                        return "includePartitionStats: boolean expected";
                return null;
            };

            /**
             * Creates a DescribeTableRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.DescribeTableRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.DescribeTableRequest} DescribeTableRequest
             */
            DescribeTableRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.DescribeTableRequest)
                    return object;
                var message = new $root.Ydb.Table.DescribeTableRequest();
                if (object.sessionId != null)
                    message.sessionId = String(object.sessionId);
                if (object.path != null)
                    message.path = String(object.path);
                if (object.operationParams != null) {
                    if (typeof object.operationParams !== "object")
                        throw TypeError(".Ydb.Table.DescribeTableRequest.operationParams: object expected");
                    message.operationParams = $root.Ydb.Operations.OperationParams.fromObject(object.operationParams);
                }
                if (object.includeShardKeyBounds != null)
                    message.includeShardKeyBounds = Boolean(object.includeShardKeyBounds);
                if (object.includeTableStats != null)
                    message.includeTableStats = Boolean(object.includeTableStats);
                if (object.includePartitionStats != null)
                    message.includePartitionStats = Boolean(object.includePartitionStats);
                return message;
            };

            /**
             * Creates a plain object from a DescribeTableRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.DescribeTableRequest
             * @static
             * @param {Ydb.Table.DescribeTableRequest} message DescribeTableRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DescribeTableRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.sessionId = "";
                    object.path = "";
                    object.operationParams = null;
                    object.includeShardKeyBounds = false;
                    object.includeTableStats = false;
                    object.includePartitionStats = false;
                }
                if (message.sessionId != null && message.hasOwnProperty("sessionId"))
                    object.sessionId = message.sessionId;
                if (message.path != null && message.hasOwnProperty("path"))
                    object.path = message.path;
                if (message.operationParams != null && message.hasOwnProperty("operationParams"))
                    object.operationParams = $root.Ydb.Operations.OperationParams.toObject(message.operationParams, options);
                if (message.includeShardKeyBounds != null && message.hasOwnProperty("includeShardKeyBounds"))
                    object.includeShardKeyBounds = message.includeShardKeyBounds;
                if (message.includeTableStats != null && message.hasOwnProperty("includeTableStats"))
                    object.includeTableStats = message.includeTableStats;
                if (message.includePartitionStats != null && message.hasOwnProperty("includePartitionStats"))
                    object.includePartitionStats = message.includePartitionStats;
                return object;
            };

            /**
             * Converts this DescribeTableRequest to JSON.
             * @function toJSON
             * @memberof Ydb.Table.DescribeTableRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DescribeTableRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DescribeTableRequest;
        })();

        Table.DescribeTableResponse = (function() {

            /**
             * Properties of a DescribeTableResponse.
             * @memberof Ydb.Table
             * @interface IDescribeTableResponse
             * @property {Ydb.Operations.IOperation|null} [operation] DescribeTableResponse operation
             */

            /**
             * Constructs a new DescribeTableResponse.
             * @memberof Ydb.Table
             * @classdesc Represents a DescribeTableResponse.
             * @implements IDescribeTableResponse
             * @constructor
             * @param {Ydb.Table.IDescribeTableResponse=} [properties] Properties to set
             */
            function DescribeTableResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DescribeTableResponse operation.
             * @member {Ydb.Operations.IOperation|null|undefined} operation
             * @memberof Ydb.Table.DescribeTableResponse
             * @instance
             */
            DescribeTableResponse.prototype.operation = null;

            /**
             * Creates a new DescribeTableResponse instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.DescribeTableResponse
             * @static
             * @param {Ydb.Table.IDescribeTableResponse=} [properties] Properties to set
             * @returns {Ydb.Table.DescribeTableResponse} DescribeTableResponse instance
             */
            DescribeTableResponse.create = function create(properties) {
                return new DescribeTableResponse(properties);
            };

            /**
             * Encodes the specified DescribeTableResponse message. Does not implicitly {@link Ydb.Table.DescribeTableResponse.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.DescribeTableResponse
             * @static
             * @param {Ydb.Table.IDescribeTableResponse} message DescribeTableResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DescribeTableResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.operation != null && Object.hasOwnProperty.call(message, "operation"))
                    $root.Ydb.Operations.Operation.encode(message.operation, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified DescribeTableResponse message, length delimited. Does not implicitly {@link Ydb.Table.DescribeTableResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.DescribeTableResponse
             * @static
             * @param {Ydb.Table.IDescribeTableResponse} message DescribeTableResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DescribeTableResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DescribeTableResponse message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.DescribeTableResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.DescribeTableResponse} DescribeTableResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DescribeTableResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.DescribeTableResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.operation = $root.Ydb.Operations.Operation.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DescribeTableResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.DescribeTableResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.DescribeTableResponse} DescribeTableResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DescribeTableResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DescribeTableResponse message.
             * @function verify
             * @memberof Ydb.Table.DescribeTableResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DescribeTableResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.operation != null && message.hasOwnProperty("operation")) {
                    var error = $root.Ydb.Operations.Operation.verify(message.operation);
                    if (error)
                        return "operation." + error;
                }
                return null;
            };

            /**
             * Creates a DescribeTableResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.DescribeTableResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.DescribeTableResponse} DescribeTableResponse
             */
            DescribeTableResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.DescribeTableResponse)
                    return object;
                var message = new $root.Ydb.Table.DescribeTableResponse();
                if (object.operation != null) {
                    if (typeof object.operation !== "object")
                        throw TypeError(".Ydb.Table.DescribeTableResponse.operation: object expected");
                    message.operation = $root.Ydb.Operations.Operation.fromObject(object.operation);
                }
                return message;
            };

            /**
             * Creates a plain object from a DescribeTableResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.DescribeTableResponse
             * @static
             * @param {Ydb.Table.DescribeTableResponse} message DescribeTableResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DescribeTableResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.operation = null;
                if (message.operation != null && message.hasOwnProperty("operation"))
                    object.operation = $root.Ydb.Operations.Operation.toObject(message.operation, options);
                return object;
            };

            /**
             * Converts this DescribeTableResponse to JSON.
             * @function toJSON
             * @memberof Ydb.Table.DescribeTableResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DescribeTableResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DescribeTableResponse;
        })();

        Table.DescribeTableResult = (function() {

            /**
             * Properties of a DescribeTableResult.
             * @memberof Ydb.Table
             * @interface IDescribeTableResult
             * @property {Ydb.Scheme.IEntry|null} [self] DescribeTableResult self
             * @property {Array.<Ydb.Table.IColumnMeta>|null} [columns] DescribeTableResult columns
             * @property {Array.<string>|null} [primaryKey] DescribeTableResult primaryKey
             * @property {Array.<Ydb.ITypedValue>|null} [shardKeyBounds] DescribeTableResult shardKeyBounds
             * @property {Array.<Ydb.Table.ITableIndexDescription>|null} [indexes] DescribeTableResult indexes
             * @property {Ydb.Table.ITableStats|null} [tableStats] DescribeTableResult tableStats
             * @property {Ydb.Table.ITtlSettings|null} [ttlSettings] DescribeTableResult ttlSettings
             * @property {Ydb.Table.IStorageSettings|null} [storageSettings] DescribeTableResult storageSettings
             * @property {Array.<Ydb.Table.IColumnFamily>|null} [columnFamilies] DescribeTableResult columnFamilies
             * @property {Object.<string,string>|null} [attributes] DescribeTableResult attributes
             * @property {Ydb.Table.IPartitioningSettings|null} [partitioningSettings] DescribeTableResult partitioningSettings
             * @property {Ydb.FeatureFlag.Status|null} [keyBloomFilter] DescribeTableResult keyBloomFilter
             * @property {Ydb.Table.IReadReplicasSettings|null} [readReplicasSettings] DescribeTableResult readReplicasSettings
             */

            /**
             * Constructs a new DescribeTableResult.
             * @memberof Ydb.Table
             * @classdesc Represents a DescribeTableResult.
             * @implements IDescribeTableResult
             * @constructor
             * @param {Ydb.Table.IDescribeTableResult=} [properties] Properties to set
             */
            function DescribeTableResult(properties) {
                this.columns = [];
                this.primaryKey = [];
                this.shardKeyBounds = [];
                this.indexes = [];
                this.columnFamilies = [];
                this.attributes = {};
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DescribeTableResult self.
             * @member {Ydb.Scheme.IEntry|null|undefined} self
             * @memberof Ydb.Table.DescribeTableResult
             * @instance
             */
            DescribeTableResult.prototype.self = null;

            /**
             * DescribeTableResult columns.
             * @member {Array.<Ydb.Table.IColumnMeta>} columns
             * @memberof Ydb.Table.DescribeTableResult
             * @instance
             */
            DescribeTableResult.prototype.columns = $util.emptyArray;

            /**
             * DescribeTableResult primaryKey.
             * @member {Array.<string>} primaryKey
             * @memberof Ydb.Table.DescribeTableResult
             * @instance
             */
            DescribeTableResult.prototype.primaryKey = $util.emptyArray;

            /**
             * DescribeTableResult shardKeyBounds.
             * @member {Array.<Ydb.ITypedValue>} shardKeyBounds
             * @memberof Ydb.Table.DescribeTableResult
             * @instance
             */
            DescribeTableResult.prototype.shardKeyBounds = $util.emptyArray;

            /**
             * DescribeTableResult indexes.
             * @member {Array.<Ydb.Table.ITableIndexDescription>} indexes
             * @memberof Ydb.Table.DescribeTableResult
             * @instance
             */
            DescribeTableResult.prototype.indexes = $util.emptyArray;

            /**
             * DescribeTableResult tableStats.
             * @member {Ydb.Table.ITableStats|null|undefined} tableStats
             * @memberof Ydb.Table.DescribeTableResult
             * @instance
             */
            DescribeTableResult.prototype.tableStats = null;

            /**
             * DescribeTableResult ttlSettings.
             * @member {Ydb.Table.ITtlSettings|null|undefined} ttlSettings
             * @memberof Ydb.Table.DescribeTableResult
             * @instance
             */
            DescribeTableResult.prototype.ttlSettings = null;

            /**
             * DescribeTableResult storageSettings.
             * @member {Ydb.Table.IStorageSettings|null|undefined} storageSettings
             * @memberof Ydb.Table.DescribeTableResult
             * @instance
             */
            DescribeTableResult.prototype.storageSettings = null;

            /**
             * DescribeTableResult columnFamilies.
             * @member {Array.<Ydb.Table.IColumnFamily>} columnFamilies
             * @memberof Ydb.Table.DescribeTableResult
             * @instance
             */
            DescribeTableResult.prototype.columnFamilies = $util.emptyArray;

            /**
             * DescribeTableResult attributes.
             * @member {Object.<string,string>} attributes
             * @memberof Ydb.Table.DescribeTableResult
             * @instance
             */
            DescribeTableResult.prototype.attributes = $util.emptyObject;

            /**
             * DescribeTableResult partitioningSettings.
             * @member {Ydb.Table.IPartitioningSettings|null|undefined} partitioningSettings
             * @memberof Ydb.Table.DescribeTableResult
             * @instance
             */
            DescribeTableResult.prototype.partitioningSettings = null;

            /**
             * DescribeTableResult keyBloomFilter.
             * @member {Ydb.FeatureFlag.Status} keyBloomFilter
             * @memberof Ydb.Table.DescribeTableResult
             * @instance
             */
            DescribeTableResult.prototype.keyBloomFilter = 0;

            /**
             * DescribeTableResult readReplicasSettings.
             * @member {Ydb.Table.IReadReplicasSettings|null|undefined} readReplicasSettings
             * @memberof Ydb.Table.DescribeTableResult
             * @instance
             */
            DescribeTableResult.prototype.readReplicasSettings = null;

            /**
             * Creates a new DescribeTableResult instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.DescribeTableResult
             * @static
             * @param {Ydb.Table.IDescribeTableResult=} [properties] Properties to set
             * @returns {Ydb.Table.DescribeTableResult} DescribeTableResult instance
             */
            DescribeTableResult.create = function create(properties) {
                return new DescribeTableResult(properties);
            };

            /**
             * Encodes the specified DescribeTableResult message. Does not implicitly {@link Ydb.Table.DescribeTableResult.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.DescribeTableResult
             * @static
             * @param {Ydb.Table.IDescribeTableResult} message DescribeTableResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DescribeTableResult.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.self != null && Object.hasOwnProperty.call(message, "self"))
                    $root.Ydb.Scheme.Entry.encode(message.self, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.columns != null && message.columns.length)
                    for (var i = 0; i < message.columns.length; ++i)
                        $root.Ydb.Table.ColumnMeta.encode(message.columns[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.primaryKey != null && message.primaryKey.length)
                    for (var i = 0; i < message.primaryKey.length; ++i)
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.primaryKey[i]);
                if (message.shardKeyBounds != null && message.shardKeyBounds.length)
                    for (var i = 0; i < message.shardKeyBounds.length; ++i)
                        $root.Ydb.TypedValue.encode(message.shardKeyBounds[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.indexes != null && message.indexes.length)
                    for (var i = 0; i < message.indexes.length; ++i)
                        $root.Ydb.Table.TableIndexDescription.encode(message.indexes[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.tableStats != null && Object.hasOwnProperty.call(message, "tableStats"))
                    $root.Ydb.Table.TableStats.encode(message.tableStats, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.ttlSettings != null && Object.hasOwnProperty.call(message, "ttlSettings"))
                    $root.Ydb.Table.TtlSettings.encode(message.ttlSettings, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.storageSettings != null && Object.hasOwnProperty.call(message, "storageSettings"))
                    $root.Ydb.Table.StorageSettings.encode(message.storageSettings, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                if (message.columnFamilies != null && message.columnFamilies.length)
                    for (var i = 0; i < message.columnFamilies.length; ++i)
                        $root.Ydb.Table.ColumnFamily.encode(message.columnFamilies[i], writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                if (message.attributes != null && Object.hasOwnProperty.call(message, "attributes"))
                    for (var keys = Object.keys(message.attributes), i = 0; i < keys.length; ++i)
                        writer.uint32(/* id 10, wireType 2 =*/82).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.attributes[keys[i]]).ldelim();
                if (message.partitioningSettings != null && Object.hasOwnProperty.call(message, "partitioningSettings"))
                    $root.Ydb.Table.PartitioningSettings.encode(message.partitioningSettings, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
                if (message.keyBloomFilter != null && Object.hasOwnProperty.call(message, "keyBloomFilter"))
                    writer.uint32(/* id 13, wireType 0 =*/104).int32(message.keyBloomFilter);
                if (message.readReplicasSettings != null && Object.hasOwnProperty.call(message, "readReplicasSettings"))
                    $root.Ydb.Table.ReadReplicasSettings.encode(message.readReplicasSettings, writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified DescribeTableResult message, length delimited. Does not implicitly {@link Ydb.Table.DescribeTableResult.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.DescribeTableResult
             * @static
             * @param {Ydb.Table.IDescribeTableResult} message DescribeTableResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DescribeTableResult.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DescribeTableResult message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.DescribeTableResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.DescribeTableResult} DescribeTableResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DescribeTableResult.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.DescribeTableResult(), key, value;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.self = $root.Ydb.Scheme.Entry.decode(reader, reader.uint32());
                        break;
                    case 2:
                        if (!(message.columns && message.columns.length))
                            message.columns = [];
                        message.columns.push($root.Ydb.Table.ColumnMeta.decode(reader, reader.uint32()));
                        break;
                    case 3:
                        if (!(message.primaryKey && message.primaryKey.length))
                            message.primaryKey = [];
                        message.primaryKey.push(reader.string());
                        break;
                    case 4:
                        if (!(message.shardKeyBounds && message.shardKeyBounds.length))
                            message.shardKeyBounds = [];
                        message.shardKeyBounds.push($root.Ydb.TypedValue.decode(reader, reader.uint32()));
                        break;
                    case 5:
                        if (!(message.indexes && message.indexes.length))
                            message.indexes = [];
                        message.indexes.push($root.Ydb.Table.TableIndexDescription.decode(reader, reader.uint32()));
                        break;
                    case 6:
                        message.tableStats = $root.Ydb.Table.TableStats.decode(reader, reader.uint32());
                        break;
                    case 7:
                        message.ttlSettings = $root.Ydb.Table.TtlSettings.decode(reader, reader.uint32());
                        break;
                    case 8:
                        message.storageSettings = $root.Ydb.Table.StorageSettings.decode(reader, reader.uint32());
                        break;
                    case 9:
                        if (!(message.columnFamilies && message.columnFamilies.length))
                            message.columnFamilies = [];
                        message.columnFamilies.push($root.Ydb.Table.ColumnFamily.decode(reader, reader.uint32()));
                        break;
                    case 10:
                        if (message.attributes === $util.emptyObject)
                            message.attributes = {};
                        var end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = "";
                        while (reader.pos < end2) {
                            var tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = reader.string();
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.attributes[key] = value;
                        break;
                    case 12:
                        message.partitioningSettings = $root.Ydb.Table.PartitioningSettings.decode(reader, reader.uint32());
                        break;
                    case 13:
                        message.keyBloomFilter = reader.int32();
                        break;
                    case 14:
                        message.readReplicasSettings = $root.Ydb.Table.ReadReplicasSettings.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DescribeTableResult message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.DescribeTableResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.DescribeTableResult} DescribeTableResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DescribeTableResult.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DescribeTableResult message.
             * @function verify
             * @memberof Ydb.Table.DescribeTableResult
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DescribeTableResult.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.self != null && message.hasOwnProperty("self")) {
                    var error = $root.Ydb.Scheme.Entry.verify(message.self);
                    if (error)
                        return "self." + error;
                }
                if (message.columns != null && message.hasOwnProperty("columns")) {
                    if (!Array.isArray(message.columns))
                        return "columns: array expected";
                    for (var i = 0; i < message.columns.length; ++i) {
                        var error = $root.Ydb.Table.ColumnMeta.verify(message.columns[i]);
                        if (error)
                            return "columns." + error;
                    }
                }
                if (message.primaryKey != null && message.hasOwnProperty("primaryKey")) {
                    if (!Array.isArray(message.primaryKey))
                        return "primaryKey: array expected";
                    for (var i = 0; i < message.primaryKey.length; ++i)
                        if (!$util.isString(message.primaryKey[i]))
                            return "primaryKey: string[] expected";
                }
                if (message.shardKeyBounds != null && message.hasOwnProperty("shardKeyBounds")) {
                    if (!Array.isArray(message.shardKeyBounds))
                        return "shardKeyBounds: array expected";
                    for (var i = 0; i < message.shardKeyBounds.length; ++i) {
                        var error = $root.Ydb.TypedValue.verify(message.shardKeyBounds[i]);
                        if (error)
                            return "shardKeyBounds." + error;
                    }
                }
                if (message.indexes != null && message.hasOwnProperty("indexes")) {
                    if (!Array.isArray(message.indexes))
                        return "indexes: array expected";
                    for (var i = 0; i < message.indexes.length; ++i) {
                        var error = $root.Ydb.Table.TableIndexDescription.verify(message.indexes[i]);
                        if (error)
                            return "indexes." + error;
                    }
                }
                if (message.tableStats != null && message.hasOwnProperty("tableStats")) {
                    var error = $root.Ydb.Table.TableStats.verify(message.tableStats);
                    if (error)
                        return "tableStats." + error;
                }
                if (message.ttlSettings != null && message.hasOwnProperty("ttlSettings")) {
                    var error = $root.Ydb.Table.TtlSettings.verify(message.ttlSettings);
                    if (error)
                        return "ttlSettings." + error;
                }
                if (message.storageSettings != null && message.hasOwnProperty("storageSettings")) {
                    var error = $root.Ydb.Table.StorageSettings.verify(message.storageSettings);
                    if (error)
                        return "storageSettings." + error;
                }
                if (message.columnFamilies != null && message.hasOwnProperty("columnFamilies")) {
                    if (!Array.isArray(message.columnFamilies))
                        return "columnFamilies: array expected";
                    for (var i = 0; i < message.columnFamilies.length; ++i) {
                        var error = $root.Ydb.Table.ColumnFamily.verify(message.columnFamilies[i]);
                        if (error)
                            return "columnFamilies." + error;
                    }
                }
                if (message.attributes != null && message.hasOwnProperty("attributes")) {
                    if (!$util.isObject(message.attributes))
                        return "attributes: object expected";
                    var key = Object.keys(message.attributes);
                    for (var i = 0; i < key.length; ++i)
                        if (!$util.isString(message.attributes[key[i]]))
                            return "attributes: string{k:string} expected";
                }
                if (message.partitioningSettings != null && message.hasOwnProperty("partitioningSettings")) {
                    var error = $root.Ydb.Table.PartitioningSettings.verify(message.partitioningSettings);
                    if (error)
                        return "partitioningSettings." + error;
                }
                if (message.keyBloomFilter != null && message.hasOwnProperty("keyBloomFilter"))
                    switch (message.keyBloomFilter) {
                    default:
                        return "keyBloomFilter: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                if (message.readReplicasSettings != null && message.hasOwnProperty("readReplicasSettings")) {
                    var error = $root.Ydb.Table.ReadReplicasSettings.verify(message.readReplicasSettings);
                    if (error)
                        return "readReplicasSettings." + error;
                }
                return null;
            };

            /**
             * Creates a DescribeTableResult message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.DescribeTableResult
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.DescribeTableResult} DescribeTableResult
             */
            DescribeTableResult.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.DescribeTableResult)
                    return object;
                var message = new $root.Ydb.Table.DescribeTableResult();
                if (object.self != null) {
                    if (typeof object.self !== "object")
                        throw TypeError(".Ydb.Table.DescribeTableResult.self: object expected");
                    message.self = $root.Ydb.Scheme.Entry.fromObject(object.self);
                }
                if (object.columns) {
                    if (!Array.isArray(object.columns))
                        throw TypeError(".Ydb.Table.DescribeTableResult.columns: array expected");
                    message.columns = [];
                    for (var i = 0; i < object.columns.length; ++i) {
                        if (typeof object.columns[i] !== "object")
                            throw TypeError(".Ydb.Table.DescribeTableResult.columns: object expected");
                        message.columns[i] = $root.Ydb.Table.ColumnMeta.fromObject(object.columns[i]);
                    }
                }
                if (object.primaryKey) {
                    if (!Array.isArray(object.primaryKey))
                        throw TypeError(".Ydb.Table.DescribeTableResult.primaryKey: array expected");
                    message.primaryKey = [];
                    for (var i = 0; i < object.primaryKey.length; ++i)
                        message.primaryKey[i] = String(object.primaryKey[i]);
                }
                if (object.shardKeyBounds) {
                    if (!Array.isArray(object.shardKeyBounds))
                        throw TypeError(".Ydb.Table.DescribeTableResult.shardKeyBounds: array expected");
                    message.shardKeyBounds = [];
                    for (var i = 0; i < object.shardKeyBounds.length; ++i) {
                        if (typeof object.shardKeyBounds[i] !== "object")
                            throw TypeError(".Ydb.Table.DescribeTableResult.shardKeyBounds: object expected");
                        message.shardKeyBounds[i] = $root.Ydb.TypedValue.fromObject(object.shardKeyBounds[i]);
                    }
                }
                if (object.indexes) {
                    if (!Array.isArray(object.indexes))
                        throw TypeError(".Ydb.Table.DescribeTableResult.indexes: array expected");
                    message.indexes = [];
                    for (var i = 0; i < object.indexes.length; ++i) {
                        if (typeof object.indexes[i] !== "object")
                            throw TypeError(".Ydb.Table.DescribeTableResult.indexes: object expected");
                        message.indexes[i] = $root.Ydb.Table.TableIndexDescription.fromObject(object.indexes[i]);
                    }
                }
                if (object.tableStats != null) {
                    if (typeof object.tableStats !== "object")
                        throw TypeError(".Ydb.Table.DescribeTableResult.tableStats: object expected");
                    message.tableStats = $root.Ydb.Table.TableStats.fromObject(object.tableStats);
                }
                if (object.ttlSettings != null) {
                    if (typeof object.ttlSettings !== "object")
                        throw TypeError(".Ydb.Table.DescribeTableResult.ttlSettings: object expected");
                    message.ttlSettings = $root.Ydb.Table.TtlSettings.fromObject(object.ttlSettings);
                }
                if (object.storageSettings != null) {
                    if (typeof object.storageSettings !== "object")
                        throw TypeError(".Ydb.Table.DescribeTableResult.storageSettings: object expected");
                    message.storageSettings = $root.Ydb.Table.StorageSettings.fromObject(object.storageSettings);
                }
                if (object.columnFamilies) {
                    if (!Array.isArray(object.columnFamilies))
                        throw TypeError(".Ydb.Table.DescribeTableResult.columnFamilies: array expected");
                    message.columnFamilies = [];
                    for (var i = 0; i < object.columnFamilies.length; ++i) {
                        if (typeof object.columnFamilies[i] !== "object")
                            throw TypeError(".Ydb.Table.DescribeTableResult.columnFamilies: object expected");
                        message.columnFamilies[i] = $root.Ydb.Table.ColumnFamily.fromObject(object.columnFamilies[i]);
                    }
                }
                if (object.attributes) {
                    if (typeof object.attributes !== "object")
                        throw TypeError(".Ydb.Table.DescribeTableResult.attributes: object expected");
                    message.attributes = {};
                    for (var keys = Object.keys(object.attributes), i = 0; i < keys.length; ++i)
                        message.attributes[keys[i]] = String(object.attributes[keys[i]]);
                }
                if (object.partitioningSettings != null) {
                    if (typeof object.partitioningSettings !== "object")
                        throw TypeError(".Ydb.Table.DescribeTableResult.partitioningSettings: object expected");
                    message.partitioningSettings = $root.Ydb.Table.PartitioningSettings.fromObject(object.partitioningSettings);
                }
                switch (object.keyBloomFilter) {
                case "STATUS_UNSPECIFIED":
                case 0:
                    message.keyBloomFilter = 0;
                    break;
                case "ENABLED":
                case 1:
                    message.keyBloomFilter = 1;
                    break;
                case "DISABLED":
                case 2:
                    message.keyBloomFilter = 2;
                    break;
                }
                if (object.readReplicasSettings != null) {
                    if (typeof object.readReplicasSettings !== "object")
                        throw TypeError(".Ydb.Table.DescribeTableResult.readReplicasSettings: object expected");
                    message.readReplicasSettings = $root.Ydb.Table.ReadReplicasSettings.fromObject(object.readReplicasSettings);
                }
                return message;
            };

            /**
             * Creates a plain object from a DescribeTableResult message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.DescribeTableResult
             * @static
             * @param {Ydb.Table.DescribeTableResult} message DescribeTableResult
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DescribeTableResult.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.columns = [];
                    object.primaryKey = [];
                    object.shardKeyBounds = [];
                    object.indexes = [];
                    object.columnFamilies = [];
                }
                if (options.objects || options.defaults)
                    object.attributes = {};
                if (options.defaults) {
                    object.self = null;
                    object.tableStats = null;
                    object.ttlSettings = null;
                    object.storageSettings = null;
                    object.partitioningSettings = null;
                    object.keyBloomFilter = options.enums === String ? "STATUS_UNSPECIFIED" : 0;
                    object.readReplicasSettings = null;
                }
                if (message.self != null && message.hasOwnProperty("self"))
                    object.self = $root.Ydb.Scheme.Entry.toObject(message.self, options);
                if (message.columns && message.columns.length) {
                    object.columns = [];
                    for (var j = 0; j < message.columns.length; ++j)
                        object.columns[j] = $root.Ydb.Table.ColumnMeta.toObject(message.columns[j], options);
                }
                if (message.primaryKey && message.primaryKey.length) {
                    object.primaryKey = [];
                    for (var j = 0; j < message.primaryKey.length; ++j)
                        object.primaryKey[j] = message.primaryKey[j];
                }
                if (message.shardKeyBounds && message.shardKeyBounds.length) {
                    object.shardKeyBounds = [];
                    for (var j = 0; j < message.shardKeyBounds.length; ++j)
                        object.shardKeyBounds[j] = $root.Ydb.TypedValue.toObject(message.shardKeyBounds[j], options);
                }
                if (message.indexes && message.indexes.length) {
                    object.indexes = [];
                    for (var j = 0; j < message.indexes.length; ++j)
                        object.indexes[j] = $root.Ydb.Table.TableIndexDescription.toObject(message.indexes[j], options);
                }
                if (message.tableStats != null && message.hasOwnProperty("tableStats"))
                    object.tableStats = $root.Ydb.Table.TableStats.toObject(message.tableStats, options);
                if (message.ttlSettings != null && message.hasOwnProperty("ttlSettings"))
                    object.ttlSettings = $root.Ydb.Table.TtlSettings.toObject(message.ttlSettings, options);
                if (message.storageSettings != null && message.hasOwnProperty("storageSettings"))
                    object.storageSettings = $root.Ydb.Table.StorageSettings.toObject(message.storageSettings, options);
                if (message.columnFamilies && message.columnFamilies.length) {
                    object.columnFamilies = [];
                    for (var j = 0; j < message.columnFamilies.length; ++j)
                        object.columnFamilies[j] = $root.Ydb.Table.ColumnFamily.toObject(message.columnFamilies[j], options);
                }
                var keys2;
                if (message.attributes && (keys2 = Object.keys(message.attributes)).length) {
                    object.attributes = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.attributes[keys2[j]] = message.attributes[keys2[j]];
                }
                if (message.partitioningSettings != null && message.hasOwnProperty("partitioningSettings"))
                    object.partitioningSettings = $root.Ydb.Table.PartitioningSettings.toObject(message.partitioningSettings, options);
                if (message.keyBloomFilter != null && message.hasOwnProperty("keyBloomFilter"))
                    object.keyBloomFilter = options.enums === String ? $root.Ydb.FeatureFlag.Status[message.keyBloomFilter] : message.keyBloomFilter;
                if (message.readReplicasSettings != null && message.hasOwnProperty("readReplicasSettings"))
                    object.readReplicasSettings = $root.Ydb.Table.ReadReplicasSettings.toObject(message.readReplicasSettings, options);
                return object;
            };

            /**
             * Converts this DescribeTableResult to JSON.
             * @function toJSON
             * @memberof Ydb.Table.DescribeTableResult
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DescribeTableResult.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DescribeTableResult;
        })();

        Table.Query = (function() {

            /**
             * Properties of a Query.
             * @memberof Ydb.Table
             * @interface IQuery
             * @property {string|null} [yqlText] Query yqlText
             * @property {string|null} [id] Query id
             */

            /**
             * Constructs a new Query.
             * @memberof Ydb.Table
             * @classdesc Represents a Query.
             * @implements IQuery
             * @constructor
             * @param {Ydb.Table.IQuery=} [properties] Properties to set
             */
            function Query(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Query yqlText.
             * @member {string|null|undefined} yqlText
             * @memberof Ydb.Table.Query
             * @instance
             */
            Query.prototype.yqlText = null;

            /**
             * Query id.
             * @member {string|null|undefined} id
             * @memberof Ydb.Table.Query
             * @instance
             */
            Query.prototype.id = null;

            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;

            /**
             * Query query.
             * @member {"yqlText"|"id"|undefined} query
             * @memberof Ydb.Table.Query
             * @instance
             */
            Object.defineProperty(Query.prototype, "query", {
                get: $util.oneOfGetter($oneOfFields = ["yqlText", "id"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new Query instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.Query
             * @static
             * @param {Ydb.Table.IQuery=} [properties] Properties to set
             * @returns {Ydb.Table.Query} Query instance
             */
            Query.create = function create(properties) {
                return new Query(properties);
            };

            /**
             * Encodes the specified Query message. Does not implicitly {@link Ydb.Table.Query.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.Query
             * @static
             * @param {Ydb.Table.IQuery} message Query message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Query.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.yqlText != null && Object.hasOwnProperty.call(message, "yqlText"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.yqlText);
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.id);
                return writer;
            };

            /**
             * Encodes the specified Query message, length delimited. Does not implicitly {@link Ydb.Table.Query.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.Query
             * @static
             * @param {Ydb.Table.IQuery} message Query message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Query.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Query message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.Query
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.Query} Query
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Query.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.Query();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.yqlText = reader.string();
                        break;
                    case 2:
                        message.id = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Query message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.Query
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.Query} Query
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Query.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Query message.
             * @function verify
             * @memberof Ydb.Table.Query
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Query.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.yqlText != null && message.hasOwnProperty("yqlText")) {
                    properties.query = 1;
                    if (!$util.isString(message.yqlText))
                        return "yqlText: string expected";
                }
                if (message.id != null && message.hasOwnProperty("id")) {
                    if (properties.query === 1)
                        return "query: multiple values";
                    properties.query = 1;
                    if (!$util.isString(message.id))
                        return "id: string expected";
                }
                return null;
            };

            /**
             * Creates a Query message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.Query
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.Query} Query
             */
            Query.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.Query)
                    return object;
                var message = new $root.Ydb.Table.Query();
                if (object.yqlText != null)
                    message.yqlText = String(object.yqlText);
                if (object.id != null)
                    message.id = String(object.id);
                return message;
            };

            /**
             * Creates a plain object from a Query message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.Query
             * @static
             * @param {Ydb.Table.Query} message Query
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Query.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (message.yqlText != null && message.hasOwnProperty("yqlText")) {
                    object.yqlText = message.yqlText;
                    if (options.oneofs)
                        object.query = "yqlText";
                }
                if (message.id != null && message.hasOwnProperty("id")) {
                    object.id = message.id;
                    if (options.oneofs)
                        object.query = "id";
                }
                return object;
            };

            /**
             * Converts this Query to JSON.
             * @function toJSON
             * @memberof Ydb.Table.Query
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Query.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Query;
        })();

        Table.SerializableModeSettings = (function() {

            /**
             * Properties of a SerializableModeSettings.
             * @memberof Ydb.Table
             * @interface ISerializableModeSettings
             */

            /**
             * Constructs a new SerializableModeSettings.
             * @memberof Ydb.Table
             * @classdesc Represents a SerializableModeSettings.
             * @implements ISerializableModeSettings
             * @constructor
             * @param {Ydb.Table.ISerializableModeSettings=} [properties] Properties to set
             */
            function SerializableModeSettings(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new SerializableModeSettings instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.SerializableModeSettings
             * @static
             * @param {Ydb.Table.ISerializableModeSettings=} [properties] Properties to set
             * @returns {Ydb.Table.SerializableModeSettings} SerializableModeSettings instance
             */
            SerializableModeSettings.create = function create(properties) {
                return new SerializableModeSettings(properties);
            };

            /**
             * Encodes the specified SerializableModeSettings message. Does not implicitly {@link Ydb.Table.SerializableModeSettings.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.SerializableModeSettings
             * @static
             * @param {Ydb.Table.ISerializableModeSettings} message SerializableModeSettings message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SerializableModeSettings.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified SerializableModeSettings message, length delimited. Does not implicitly {@link Ydb.Table.SerializableModeSettings.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.SerializableModeSettings
             * @static
             * @param {Ydb.Table.ISerializableModeSettings} message SerializableModeSettings message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SerializableModeSettings.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SerializableModeSettings message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.SerializableModeSettings
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.SerializableModeSettings} SerializableModeSettings
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SerializableModeSettings.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.SerializableModeSettings();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SerializableModeSettings message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.SerializableModeSettings
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.SerializableModeSettings} SerializableModeSettings
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SerializableModeSettings.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SerializableModeSettings message.
             * @function verify
             * @memberof Ydb.Table.SerializableModeSettings
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SerializableModeSettings.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a SerializableModeSettings message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.SerializableModeSettings
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.SerializableModeSettings} SerializableModeSettings
             */
            SerializableModeSettings.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.SerializableModeSettings)
                    return object;
                return new $root.Ydb.Table.SerializableModeSettings();
            };

            /**
             * Creates a plain object from a SerializableModeSettings message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.SerializableModeSettings
             * @static
             * @param {Ydb.Table.SerializableModeSettings} message SerializableModeSettings
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SerializableModeSettings.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this SerializableModeSettings to JSON.
             * @function toJSON
             * @memberof Ydb.Table.SerializableModeSettings
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SerializableModeSettings.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return SerializableModeSettings;
        })();

        Table.OnlineModeSettings = (function() {

            /**
             * Properties of an OnlineModeSettings.
             * @memberof Ydb.Table
             * @interface IOnlineModeSettings
             * @property {boolean|null} [allowInconsistentReads] OnlineModeSettings allowInconsistentReads
             */

            /**
             * Constructs a new OnlineModeSettings.
             * @memberof Ydb.Table
             * @classdesc Represents an OnlineModeSettings.
             * @implements IOnlineModeSettings
             * @constructor
             * @param {Ydb.Table.IOnlineModeSettings=} [properties] Properties to set
             */
            function OnlineModeSettings(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * OnlineModeSettings allowInconsistentReads.
             * @member {boolean} allowInconsistentReads
             * @memberof Ydb.Table.OnlineModeSettings
             * @instance
             */
            OnlineModeSettings.prototype.allowInconsistentReads = false;

            /**
             * Creates a new OnlineModeSettings instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.OnlineModeSettings
             * @static
             * @param {Ydb.Table.IOnlineModeSettings=} [properties] Properties to set
             * @returns {Ydb.Table.OnlineModeSettings} OnlineModeSettings instance
             */
            OnlineModeSettings.create = function create(properties) {
                return new OnlineModeSettings(properties);
            };

            /**
             * Encodes the specified OnlineModeSettings message. Does not implicitly {@link Ydb.Table.OnlineModeSettings.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.OnlineModeSettings
             * @static
             * @param {Ydb.Table.IOnlineModeSettings} message OnlineModeSettings message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OnlineModeSettings.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.allowInconsistentReads != null && Object.hasOwnProperty.call(message, "allowInconsistentReads"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.allowInconsistentReads);
                return writer;
            };

            /**
             * Encodes the specified OnlineModeSettings message, length delimited. Does not implicitly {@link Ydb.Table.OnlineModeSettings.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.OnlineModeSettings
             * @static
             * @param {Ydb.Table.IOnlineModeSettings} message OnlineModeSettings message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OnlineModeSettings.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an OnlineModeSettings message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.OnlineModeSettings
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.OnlineModeSettings} OnlineModeSettings
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OnlineModeSettings.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.OnlineModeSettings();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.allowInconsistentReads = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an OnlineModeSettings message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.OnlineModeSettings
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.OnlineModeSettings} OnlineModeSettings
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OnlineModeSettings.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an OnlineModeSettings message.
             * @function verify
             * @memberof Ydb.Table.OnlineModeSettings
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            OnlineModeSettings.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.allowInconsistentReads != null && message.hasOwnProperty("allowInconsistentReads"))
                    if (typeof message.allowInconsistentReads !== "boolean")
                        return "allowInconsistentReads: boolean expected";
                return null;
            };

            /**
             * Creates an OnlineModeSettings message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.OnlineModeSettings
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.OnlineModeSettings} OnlineModeSettings
             */
            OnlineModeSettings.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.OnlineModeSettings)
                    return object;
                var message = new $root.Ydb.Table.OnlineModeSettings();
                if (object.allowInconsistentReads != null)
                    message.allowInconsistentReads = Boolean(object.allowInconsistentReads);
                return message;
            };

            /**
             * Creates a plain object from an OnlineModeSettings message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.OnlineModeSettings
             * @static
             * @param {Ydb.Table.OnlineModeSettings} message OnlineModeSettings
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            OnlineModeSettings.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.allowInconsistentReads = false;
                if (message.allowInconsistentReads != null && message.hasOwnProperty("allowInconsistentReads"))
                    object.allowInconsistentReads = message.allowInconsistentReads;
                return object;
            };

            /**
             * Converts this OnlineModeSettings to JSON.
             * @function toJSON
             * @memberof Ydb.Table.OnlineModeSettings
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            OnlineModeSettings.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return OnlineModeSettings;
        })();

        Table.StaleModeSettings = (function() {

            /**
             * Properties of a StaleModeSettings.
             * @memberof Ydb.Table
             * @interface IStaleModeSettings
             */

            /**
             * Constructs a new StaleModeSettings.
             * @memberof Ydb.Table
             * @classdesc Represents a StaleModeSettings.
             * @implements IStaleModeSettings
             * @constructor
             * @param {Ydb.Table.IStaleModeSettings=} [properties] Properties to set
             */
            function StaleModeSettings(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new StaleModeSettings instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.StaleModeSettings
             * @static
             * @param {Ydb.Table.IStaleModeSettings=} [properties] Properties to set
             * @returns {Ydb.Table.StaleModeSettings} StaleModeSettings instance
             */
            StaleModeSettings.create = function create(properties) {
                return new StaleModeSettings(properties);
            };

            /**
             * Encodes the specified StaleModeSettings message. Does not implicitly {@link Ydb.Table.StaleModeSettings.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.StaleModeSettings
             * @static
             * @param {Ydb.Table.IStaleModeSettings} message StaleModeSettings message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StaleModeSettings.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified StaleModeSettings message, length delimited. Does not implicitly {@link Ydb.Table.StaleModeSettings.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.StaleModeSettings
             * @static
             * @param {Ydb.Table.IStaleModeSettings} message StaleModeSettings message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StaleModeSettings.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a StaleModeSettings message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.StaleModeSettings
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.StaleModeSettings} StaleModeSettings
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StaleModeSettings.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.StaleModeSettings();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a StaleModeSettings message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.StaleModeSettings
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.StaleModeSettings} StaleModeSettings
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StaleModeSettings.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a StaleModeSettings message.
             * @function verify
             * @memberof Ydb.Table.StaleModeSettings
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            StaleModeSettings.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a StaleModeSettings message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.StaleModeSettings
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.StaleModeSettings} StaleModeSettings
             */
            StaleModeSettings.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.StaleModeSettings)
                    return object;
                return new $root.Ydb.Table.StaleModeSettings();
            };

            /**
             * Creates a plain object from a StaleModeSettings message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.StaleModeSettings
             * @static
             * @param {Ydb.Table.StaleModeSettings} message StaleModeSettings
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            StaleModeSettings.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this StaleModeSettings to JSON.
             * @function toJSON
             * @memberof Ydb.Table.StaleModeSettings
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            StaleModeSettings.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return StaleModeSettings;
        })();

        Table.TransactionSettings = (function() {

            /**
             * Properties of a TransactionSettings.
             * @memberof Ydb.Table
             * @interface ITransactionSettings
             * @property {Ydb.Table.ISerializableModeSettings|null} [serializableReadWrite] TransactionSettings serializableReadWrite
             * @property {Ydb.Table.IOnlineModeSettings|null} [onlineReadOnly] TransactionSettings onlineReadOnly
             * @property {Ydb.Table.IStaleModeSettings|null} [staleReadOnly] TransactionSettings staleReadOnly
             */

            /**
             * Constructs a new TransactionSettings.
             * @memberof Ydb.Table
             * @classdesc Represents a TransactionSettings.
             * @implements ITransactionSettings
             * @constructor
             * @param {Ydb.Table.ITransactionSettings=} [properties] Properties to set
             */
            function TransactionSettings(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * TransactionSettings serializableReadWrite.
             * @member {Ydb.Table.ISerializableModeSettings|null|undefined} serializableReadWrite
             * @memberof Ydb.Table.TransactionSettings
             * @instance
             */
            TransactionSettings.prototype.serializableReadWrite = null;

            /**
             * TransactionSettings onlineReadOnly.
             * @member {Ydb.Table.IOnlineModeSettings|null|undefined} onlineReadOnly
             * @memberof Ydb.Table.TransactionSettings
             * @instance
             */
            TransactionSettings.prototype.onlineReadOnly = null;

            /**
             * TransactionSettings staleReadOnly.
             * @member {Ydb.Table.IStaleModeSettings|null|undefined} staleReadOnly
             * @memberof Ydb.Table.TransactionSettings
             * @instance
             */
            TransactionSettings.prototype.staleReadOnly = null;

            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;

            /**
             * TransactionSettings txMode.
             * @member {"serializableReadWrite"|"onlineReadOnly"|"staleReadOnly"|undefined} txMode
             * @memberof Ydb.Table.TransactionSettings
             * @instance
             */
            Object.defineProperty(TransactionSettings.prototype, "txMode", {
                get: $util.oneOfGetter($oneOfFields = ["serializableReadWrite", "onlineReadOnly", "staleReadOnly"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new TransactionSettings instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.TransactionSettings
             * @static
             * @param {Ydb.Table.ITransactionSettings=} [properties] Properties to set
             * @returns {Ydb.Table.TransactionSettings} TransactionSettings instance
             */
            TransactionSettings.create = function create(properties) {
                return new TransactionSettings(properties);
            };

            /**
             * Encodes the specified TransactionSettings message. Does not implicitly {@link Ydb.Table.TransactionSettings.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.TransactionSettings
             * @static
             * @param {Ydb.Table.ITransactionSettings} message TransactionSettings message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TransactionSettings.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.serializableReadWrite != null && Object.hasOwnProperty.call(message, "serializableReadWrite"))
                    $root.Ydb.Table.SerializableModeSettings.encode(message.serializableReadWrite, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.onlineReadOnly != null && Object.hasOwnProperty.call(message, "onlineReadOnly"))
                    $root.Ydb.Table.OnlineModeSettings.encode(message.onlineReadOnly, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.staleReadOnly != null && Object.hasOwnProperty.call(message, "staleReadOnly"))
                    $root.Ydb.Table.StaleModeSettings.encode(message.staleReadOnly, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified TransactionSettings message, length delimited. Does not implicitly {@link Ydb.Table.TransactionSettings.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.TransactionSettings
             * @static
             * @param {Ydb.Table.ITransactionSettings} message TransactionSettings message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TransactionSettings.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a TransactionSettings message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.TransactionSettings
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.TransactionSettings} TransactionSettings
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TransactionSettings.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.TransactionSettings();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.serializableReadWrite = $root.Ydb.Table.SerializableModeSettings.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.onlineReadOnly = $root.Ydb.Table.OnlineModeSettings.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.staleReadOnly = $root.Ydb.Table.StaleModeSettings.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a TransactionSettings message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.TransactionSettings
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.TransactionSettings} TransactionSettings
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TransactionSettings.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a TransactionSettings message.
             * @function verify
             * @memberof Ydb.Table.TransactionSettings
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TransactionSettings.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.serializableReadWrite != null && message.hasOwnProperty("serializableReadWrite")) {
                    properties.txMode = 1;
                    {
                        var error = $root.Ydb.Table.SerializableModeSettings.verify(message.serializableReadWrite);
                        if (error)
                            return "serializableReadWrite." + error;
                    }
                }
                if (message.onlineReadOnly != null && message.hasOwnProperty("onlineReadOnly")) {
                    if (properties.txMode === 1)
                        return "txMode: multiple values";
                    properties.txMode = 1;
                    {
                        var error = $root.Ydb.Table.OnlineModeSettings.verify(message.onlineReadOnly);
                        if (error)
                            return "onlineReadOnly." + error;
                    }
                }
                if (message.staleReadOnly != null && message.hasOwnProperty("staleReadOnly")) {
                    if (properties.txMode === 1)
                        return "txMode: multiple values";
                    properties.txMode = 1;
                    {
                        var error = $root.Ydb.Table.StaleModeSettings.verify(message.staleReadOnly);
                        if (error)
                            return "staleReadOnly." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a TransactionSettings message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.TransactionSettings
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.TransactionSettings} TransactionSettings
             */
            TransactionSettings.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.TransactionSettings)
                    return object;
                var message = new $root.Ydb.Table.TransactionSettings();
                if (object.serializableReadWrite != null) {
                    if (typeof object.serializableReadWrite !== "object")
                        throw TypeError(".Ydb.Table.TransactionSettings.serializableReadWrite: object expected");
                    message.serializableReadWrite = $root.Ydb.Table.SerializableModeSettings.fromObject(object.serializableReadWrite);
                }
                if (object.onlineReadOnly != null) {
                    if (typeof object.onlineReadOnly !== "object")
                        throw TypeError(".Ydb.Table.TransactionSettings.onlineReadOnly: object expected");
                    message.onlineReadOnly = $root.Ydb.Table.OnlineModeSettings.fromObject(object.onlineReadOnly);
                }
                if (object.staleReadOnly != null) {
                    if (typeof object.staleReadOnly !== "object")
                        throw TypeError(".Ydb.Table.TransactionSettings.staleReadOnly: object expected");
                    message.staleReadOnly = $root.Ydb.Table.StaleModeSettings.fromObject(object.staleReadOnly);
                }
                return message;
            };

            /**
             * Creates a plain object from a TransactionSettings message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.TransactionSettings
             * @static
             * @param {Ydb.Table.TransactionSettings} message TransactionSettings
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            TransactionSettings.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (message.serializableReadWrite != null && message.hasOwnProperty("serializableReadWrite")) {
                    object.serializableReadWrite = $root.Ydb.Table.SerializableModeSettings.toObject(message.serializableReadWrite, options);
                    if (options.oneofs)
                        object.txMode = "serializableReadWrite";
                }
                if (message.onlineReadOnly != null && message.hasOwnProperty("onlineReadOnly")) {
                    object.onlineReadOnly = $root.Ydb.Table.OnlineModeSettings.toObject(message.onlineReadOnly, options);
                    if (options.oneofs)
                        object.txMode = "onlineReadOnly";
                }
                if (message.staleReadOnly != null && message.hasOwnProperty("staleReadOnly")) {
                    object.staleReadOnly = $root.Ydb.Table.StaleModeSettings.toObject(message.staleReadOnly, options);
                    if (options.oneofs)
                        object.txMode = "staleReadOnly";
                }
                return object;
            };

            /**
             * Converts this TransactionSettings to JSON.
             * @function toJSON
             * @memberof Ydb.Table.TransactionSettings
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            TransactionSettings.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return TransactionSettings;
        })();

        Table.TransactionControl = (function() {

            /**
             * Properties of a TransactionControl.
             * @memberof Ydb.Table
             * @interface ITransactionControl
             * @property {string|null} [txId] TransactionControl txId
             * @property {Ydb.Table.ITransactionSettings|null} [beginTx] TransactionControl beginTx
             * @property {boolean|null} [commitTx] TransactionControl commitTx
             */

            /**
             * Constructs a new TransactionControl.
             * @memberof Ydb.Table
             * @classdesc Represents a TransactionControl.
             * @implements ITransactionControl
             * @constructor
             * @param {Ydb.Table.ITransactionControl=} [properties] Properties to set
             */
            function TransactionControl(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * TransactionControl txId.
             * @member {string|null|undefined} txId
             * @memberof Ydb.Table.TransactionControl
             * @instance
             */
            TransactionControl.prototype.txId = null;

            /**
             * TransactionControl beginTx.
             * @member {Ydb.Table.ITransactionSettings|null|undefined} beginTx
             * @memberof Ydb.Table.TransactionControl
             * @instance
             */
            TransactionControl.prototype.beginTx = null;

            /**
             * TransactionControl commitTx.
             * @member {boolean} commitTx
             * @memberof Ydb.Table.TransactionControl
             * @instance
             */
            TransactionControl.prototype.commitTx = false;

            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;

            /**
             * TransactionControl txSelector.
             * @member {"txId"|"beginTx"|undefined} txSelector
             * @memberof Ydb.Table.TransactionControl
             * @instance
             */
            Object.defineProperty(TransactionControl.prototype, "txSelector", {
                get: $util.oneOfGetter($oneOfFields = ["txId", "beginTx"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new TransactionControl instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.TransactionControl
             * @static
             * @param {Ydb.Table.ITransactionControl=} [properties] Properties to set
             * @returns {Ydb.Table.TransactionControl} TransactionControl instance
             */
            TransactionControl.create = function create(properties) {
                return new TransactionControl(properties);
            };

            /**
             * Encodes the specified TransactionControl message. Does not implicitly {@link Ydb.Table.TransactionControl.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.TransactionControl
             * @static
             * @param {Ydb.Table.ITransactionControl} message TransactionControl message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TransactionControl.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.txId != null && Object.hasOwnProperty.call(message, "txId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.txId);
                if (message.beginTx != null && Object.hasOwnProperty.call(message, "beginTx"))
                    $root.Ydb.Table.TransactionSettings.encode(message.beginTx, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.commitTx != null && Object.hasOwnProperty.call(message, "commitTx"))
                    writer.uint32(/* id 10, wireType 0 =*/80).bool(message.commitTx);
                return writer;
            };

            /**
             * Encodes the specified TransactionControl message, length delimited. Does not implicitly {@link Ydb.Table.TransactionControl.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.TransactionControl
             * @static
             * @param {Ydb.Table.ITransactionControl} message TransactionControl message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TransactionControl.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a TransactionControl message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.TransactionControl
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.TransactionControl} TransactionControl
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TransactionControl.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.TransactionControl();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.txId = reader.string();
                        break;
                    case 2:
                        message.beginTx = $root.Ydb.Table.TransactionSettings.decode(reader, reader.uint32());
                        break;
                    case 10:
                        message.commitTx = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a TransactionControl message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.TransactionControl
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.TransactionControl} TransactionControl
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TransactionControl.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a TransactionControl message.
             * @function verify
             * @memberof Ydb.Table.TransactionControl
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TransactionControl.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.txId != null && message.hasOwnProperty("txId")) {
                    properties.txSelector = 1;
                    if (!$util.isString(message.txId))
                        return "txId: string expected";
                }
                if (message.beginTx != null && message.hasOwnProperty("beginTx")) {
                    if (properties.txSelector === 1)
                        return "txSelector: multiple values";
                    properties.txSelector = 1;
                    {
                        var error = $root.Ydb.Table.TransactionSettings.verify(message.beginTx);
                        if (error)
                            return "beginTx." + error;
                    }
                }
                if (message.commitTx != null && message.hasOwnProperty("commitTx"))
                    if (typeof message.commitTx !== "boolean")
                        return "commitTx: boolean expected";
                return null;
            };

            /**
             * Creates a TransactionControl message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.TransactionControl
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.TransactionControl} TransactionControl
             */
            TransactionControl.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.TransactionControl)
                    return object;
                var message = new $root.Ydb.Table.TransactionControl();
                if (object.txId != null)
                    message.txId = String(object.txId);
                if (object.beginTx != null) {
                    if (typeof object.beginTx !== "object")
                        throw TypeError(".Ydb.Table.TransactionControl.beginTx: object expected");
                    message.beginTx = $root.Ydb.Table.TransactionSettings.fromObject(object.beginTx);
                }
                if (object.commitTx != null)
                    message.commitTx = Boolean(object.commitTx);
                return message;
            };

            /**
             * Creates a plain object from a TransactionControl message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.TransactionControl
             * @static
             * @param {Ydb.Table.TransactionControl} message TransactionControl
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            TransactionControl.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.commitTx = false;
                if (message.txId != null && message.hasOwnProperty("txId")) {
                    object.txId = message.txId;
                    if (options.oneofs)
                        object.txSelector = "txId";
                }
                if (message.beginTx != null && message.hasOwnProperty("beginTx")) {
                    object.beginTx = $root.Ydb.Table.TransactionSettings.toObject(message.beginTx, options);
                    if (options.oneofs)
                        object.txSelector = "beginTx";
                }
                if (message.commitTx != null && message.hasOwnProperty("commitTx"))
                    object.commitTx = message.commitTx;
                return object;
            };

            /**
             * Converts this TransactionControl to JSON.
             * @function toJSON
             * @memberof Ydb.Table.TransactionControl
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            TransactionControl.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return TransactionControl;
        })();

        Table.QueryCachePolicy = (function() {

            /**
             * Properties of a QueryCachePolicy.
             * @memberof Ydb.Table
             * @interface IQueryCachePolicy
             * @property {boolean|null} [keepInCache] QueryCachePolicy keepInCache
             */

            /**
             * Constructs a new QueryCachePolicy.
             * @memberof Ydb.Table
             * @classdesc Represents a QueryCachePolicy.
             * @implements IQueryCachePolicy
             * @constructor
             * @param {Ydb.Table.IQueryCachePolicy=} [properties] Properties to set
             */
            function QueryCachePolicy(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * QueryCachePolicy keepInCache.
             * @member {boolean} keepInCache
             * @memberof Ydb.Table.QueryCachePolicy
             * @instance
             */
            QueryCachePolicy.prototype.keepInCache = false;

            /**
             * Creates a new QueryCachePolicy instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.QueryCachePolicy
             * @static
             * @param {Ydb.Table.IQueryCachePolicy=} [properties] Properties to set
             * @returns {Ydb.Table.QueryCachePolicy} QueryCachePolicy instance
             */
            QueryCachePolicy.create = function create(properties) {
                return new QueryCachePolicy(properties);
            };

            /**
             * Encodes the specified QueryCachePolicy message. Does not implicitly {@link Ydb.Table.QueryCachePolicy.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.QueryCachePolicy
             * @static
             * @param {Ydb.Table.IQueryCachePolicy} message QueryCachePolicy message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryCachePolicy.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.keepInCache != null && Object.hasOwnProperty.call(message, "keepInCache"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.keepInCache);
                return writer;
            };

            /**
             * Encodes the specified QueryCachePolicy message, length delimited. Does not implicitly {@link Ydb.Table.QueryCachePolicy.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.QueryCachePolicy
             * @static
             * @param {Ydb.Table.IQueryCachePolicy} message QueryCachePolicy message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryCachePolicy.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a QueryCachePolicy message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.QueryCachePolicy
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.QueryCachePolicy} QueryCachePolicy
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryCachePolicy.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.QueryCachePolicy();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.keepInCache = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a QueryCachePolicy message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.QueryCachePolicy
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.QueryCachePolicy} QueryCachePolicy
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryCachePolicy.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a QueryCachePolicy message.
             * @function verify
             * @memberof Ydb.Table.QueryCachePolicy
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            QueryCachePolicy.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.keepInCache != null && message.hasOwnProperty("keepInCache"))
                    if (typeof message.keepInCache !== "boolean")
                        return "keepInCache: boolean expected";
                return null;
            };

            /**
             * Creates a QueryCachePolicy message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.QueryCachePolicy
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.QueryCachePolicy} QueryCachePolicy
             */
            QueryCachePolicy.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.QueryCachePolicy)
                    return object;
                var message = new $root.Ydb.Table.QueryCachePolicy();
                if (object.keepInCache != null)
                    message.keepInCache = Boolean(object.keepInCache);
                return message;
            };

            /**
             * Creates a plain object from a QueryCachePolicy message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.QueryCachePolicy
             * @static
             * @param {Ydb.Table.QueryCachePolicy} message QueryCachePolicy
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            QueryCachePolicy.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.keepInCache = false;
                if (message.keepInCache != null && message.hasOwnProperty("keepInCache"))
                    object.keepInCache = message.keepInCache;
                return object;
            };

            /**
             * Converts this QueryCachePolicy to JSON.
             * @function toJSON
             * @memberof Ydb.Table.QueryCachePolicy
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            QueryCachePolicy.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return QueryCachePolicy;
        })();

        Table.QueryStatsCollection = (function() {

            /**
             * Properties of a QueryStatsCollection.
             * @memberof Ydb.Table
             * @interface IQueryStatsCollection
             */

            /**
             * Constructs a new QueryStatsCollection.
             * @memberof Ydb.Table
             * @classdesc Represents a QueryStatsCollection.
             * @implements IQueryStatsCollection
             * @constructor
             * @param {Ydb.Table.IQueryStatsCollection=} [properties] Properties to set
             */
            function QueryStatsCollection(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new QueryStatsCollection instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.QueryStatsCollection
             * @static
             * @param {Ydb.Table.IQueryStatsCollection=} [properties] Properties to set
             * @returns {Ydb.Table.QueryStatsCollection} QueryStatsCollection instance
             */
            QueryStatsCollection.create = function create(properties) {
                return new QueryStatsCollection(properties);
            };

            /**
             * Encodes the specified QueryStatsCollection message. Does not implicitly {@link Ydb.Table.QueryStatsCollection.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.QueryStatsCollection
             * @static
             * @param {Ydb.Table.IQueryStatsCollection} message QueryStatsCollection message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryStatsCollection.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified QueryStatsCollection message, length delimited. Does not implicitly {@link Ydb.Table.QueryStatsCollection.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.QueryStatsCollection
             * @static
             * @param {Ydb.Table.IQueryStatsCollection} message QueryStatsCollection message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryStatsCollection.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a QueryStatsCollection message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.QueryStatsCollection
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.QueryStatsCollection} QueryStatsCollection
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryStatsCollection.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.QueryStatsCollection();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a QueryStatsCollection message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.QueryStatsCollection
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.QueryStatsCollection} QueryStatsCollection
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryStatsCollection.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a QueryStatsCollection message.
             * @function verify
             * @memberof Ydb.Table.QueryStatsCollection
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            QueryStatsCollection.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a QueryStatsCollection message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.QueryStatsCollection
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.QueryStatsCollection} QueryStatsCollection
             */
            QueryStatsCollection.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.QueryStatsCollection)
                    return object;
                return new $root.Ydb.Table.QueryStatsCollection();
            };

            /**
             * Creates a plain object from a QueryStatsCollection message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.QueryStatsCollection
             * @static
             * @param {Ydb.Table.QueryStatsCollection} message QueryStatsCollection
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            QueryStatsCollection.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this QueryStatsCollection to JSON.
             * @function toJSON
             * @memberof Ydb.Table.QueryStatsCollection
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            QueryStatsCollection.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Mode enum.
             * @name Ydb.Table.QueryStatsCollection.Mode
             * @enum {number}
             * @property {number} STATS_COLLECTION_UNSPECIFIED=0 STATS_COLLECTION_UNSPECIFIED value
             * @property {number} STATS_COLLECTION_NONE=1 STATS_COLLECTION_NONE value
             * @property {number} STATS_COLLECTION_BASIC=2 STATS_COLLECTION_BASIC value
             * @property {number} STATS_COLLECTION_FULL=3 STATS_COLLECTION_FULL value
             */
            QueryStatsCollection.Mode = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "STATS_COLLECTION_UNSPECIFIED"] = 0;
                values[valuesById[1] = "STATS_COLLECTION_NONE"] = 1;
                values[valuesById[2] = "STATS_COLLECTION_BASIC"] = 2;
                values[valuesById[3] = "STATS_COLLECTION_FULL"] = 3;
                return values;
            })();

            return QueryStatsCollection;
        })();

        Table.ExecuteDataQueryRequest = (function() {

            /**
             * Properties of an ExecuteDataQueryRequest.
             * @memberof Ydb.Table
             * @interface IExecuteDataQueryRequest
             * @property {string|null} [sessionId] ExecuteDataQueryRequest sessionId
             * @property {Ydb.Table.ITransactionControl|null} [txControl] ExecuteDataQueryRequest txControl
             * @property {Ydb.Table.IQuery|null} [query] ExecuteDataQueryRequest query
             * @property {Object.<string,Ydb.ITypedValue>|null} [parameters] ExecuteDataQueryRequest parameters
             * @property {Ydb.Table.IQueryCachePolicy|null} [queryCachePolicy] ExecuteDataQueryRequest queryCachePolicy
             * @property {Ydb.Operations.IOperationParams|null} [operationParams] ExecuteDataQueryRequest operationParams
             * @property {Ydb.Table.QueryStatsCollection.Mode|null} [collectStats] ExecuteDataQueryRequest collectStats
             */

            /**
             * Constructs a new ExecuteDataQueryRequest.
             * @memberof Ydb.Table
             * @classdesc Represents an ExecuteDataQueryRequest.
             * @implements IExecuteDataQueryRequest
             * @constructor
             * @param {Ydb.Table.IExecuteDataQueryRequest=} [properties] Properties to set
             */
            function ExecuteDataQueryRequest(properties) {
                this.parameters = {};
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ExecuteDataQueryRequest sessionId.
             * @member {string} sessionId
             * @memberof Ydb.Table.ExecuteDataQueryRequest
             * @instance
             */
            ExecuteDataQueryRequest.prototype.sessionId = "";

            /**
             * ExecuteDataQueryRequest txControl.
             * @member {Ydb.Table.ITransactionControl|null|undefined} txControl
             * @memberof Ydb.Table.ExecuteDataQueryRequest
             * @instance
             */
            ExecuteDataQueryRequest.prototype.txControl = null;

            /**
             * ExecuteDataQueryRequest query.
             * @member {Ydb.Table.IQuery|null|undefined} query
             * @memberof Ydb.Table.ExecuteDataQueryRequest
             * @instance
             */
            ExecuteDataQueryRequest.prototype.query = null;

            /**
             * ExecuteDataQueryRequest parameters.
             * @member {Object.<string,Ydb.ITypedValue>} parameters
             * @memberof Ydb.Table.ExecuteDataQueryRequest
             * @instance
             */
            ExecuteDataQueryRequest.prototype.parameters = $util.emptyObject;

            /**
             * ExecuteDataQueryRequest queryCachePolicy.
             * @member {Ydb.Table.IQueryCachePolicy|null|undefined} queryCachePolicy
             * @memberof Ydb.Table.ExecuteDataQueryRequest
             * @instance
             */
            ExecuteDataQueryRequest.prototype.queryCachePolicy = null;

            /**
             * ExecuteDataQueryRequest operationParams.
             * @member {Ydb.Operations.IOperationParams|null|undefined} operationParams
             * @memberof Ydb.Table.ExecuteDataQueryRequest
             * @instance
             */
            ExecuteDataQueryRequest.prototype.operationParams = null;

            /**
             * ExecuteDataQueryRequest collectStats.
             * @member {Ydb.Table.QueryStatsCollection.Mode} collectStats
             * @memberof Ydb.Table.ExecuteDataQueryRequest
             * @instance
             */
            ExecuteDataQueryRequest.prototype.collectStats = 0;

            /**
             * Creates a new ExecuteDataQueryRequest instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.ExecuteDataQueryRequest
             * @static
             * @param {Ydb.Table.IExecuteDataQueryRequest=} [properties] Properties to set
             * @returns {Ydb.Table.ExecuteDataQueryRequest} ExecuteDataQueryRequest instance
             */
            ExecuteDataQueryRequest.create = function create(properties) {
                return new ExecuteDataQueryRequest(properties);
            };

            /**
             * Encodes the specified ExecuteDataQueryRequest message. Does not implicitly {@link Ydb.Table.ExecuteDataQueryRequest.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.ExecuteDataQueryRequest
             * @static
             * @param {Ydb.Table.IExecuteDataQueryRequest} message ExecuteDataQueryRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExecuteDataQueryRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.sessionId != null && Object.hasOwnProperty.call(message, "sessionId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.sessionId);
                if (message.txControl != null && Object.hasOwnProperty.call(message, "txControl"))
                    $root.Ydb.Table.TransactionControl.encode(message.txControl, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.query != null && Object.hasOwnProperty.call(message, "query"))
                    $root.Ydb.Table.Query.encode(message.query, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.parameters != null && Object.hasOwnProperty.call(message, "parameters"))
                    for (var keys = Object.keys(message.parameters), i = 0; i < keys.length; ++i) {
                        writer.uint32(/* id 4, wireType 2 =*/34).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                        $root.Ydb.TypedValue.encode(message.parameters[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                    }
                if (message.queryCachePolicy != null && Object.hasOwnProperty.call(message, "queryCachePolicy"))
                    $root.Ydb.Table.QueryCachePolicy.encode(message.queryCachePolicy, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.operationParams != null && Object.hasOwnProperty.call(message, "operationParams"))
                    $root.Ydb.Operations.OperationParams.encode(message.operationParams, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.collectStats != null && Object.hasOwnProperty.call(message, "collectStats"))
                    writer.uint32(/* id 7, wireType 0 =*/56).int32(message.collectStats);
                return writer;
            };

            /**
             * Encodes the specified ExecuteDataQueryRequest message, length delimited. Does not implicitly {@link Ydb.Table.ExecuteDataQueryRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.ExecuteDataQueryRequest
             * @static
             * @param {Ydb.Table.IExecuteDataQueryRequest} message ExecuteDataQueryRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExecuteDataQueryRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ExecuteDataQueryRequest message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.ExecuteDataQueryRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.ExecuteDataQueryRequest} ExecuteDataQueryRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExecuteDataQueryRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.ExecuteDataQueryRequest(), key, value;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.sessionId = reader.string();
                        break;
                    case 2:
                        message.txControl = $root.Ydb.Table.TransactionControl.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.query = $root.Ydb.Table.Query.decode(reader, reader.uint32());
                        break;
                    case 4:
                        if (message.parameters === $util.emptyObject)
                            message.parameters = {};
                        var end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = null;
                        while (reader.pos < end2) {
                            var tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = $root.Ydb.TypedValue.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.parameters[key] = value;
                        break;
                    case 5:
                        message.queryCachePolicy = $root.Ydb.Table.QueryCachePolicy.decode(reader, reader.uint32());
                        break;
                    case 6:
                        message.operationParams = $root.Ydb.Operations.OperationParams.decode(reader, reader.uint32());
                        break;
                    case 7:
                        message.collectStats = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an ExecuteDataQueryRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.ExecuteDataQueryRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.ExecuteDataQueryRequest} ExecuteDataQueryRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExecuteDataQueryRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ExecuteDataQueryRequest message.
             * @function verify
             * @memberof Ydb.Table.ExecuteDataQueryRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ExecuteDataQueryRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.sessionId != null && message.hasOwnProperty("sessionId"))
                    if (!$util.isString(message.sessionId))
                        return "sessionId: string expected";
                if (message.txControl != null && message.hasOwnProperty("txControl")) {
                    var error = $root.Ydb.Table.TransactionControl.verify(message.txControl);
                    if (error)
                        return "txControl." + error;
                }
                if (message.query != null && message.hasOwnProperty("query")) {
                    var error = $root.Ydb.Table.Query.verify(message.query);
                    if (error)
                        return "query." + error;
                }
                if (message.parameters != null && message.hasOwnProperty("parameters")) {
                    if (!$util.isObject(message.parameters))
                        return "parameters: object expected";
                    var key = Object.keys(message.parameters);
                    for (var i = 0; i < key.length; ++i) {
                        var error = $root.Ydb.TypedValue.verify(message.parameters[key[i]]);
                        if (error)
                            return "parameters." + error;
                    }
                }
                if (message.queryCachePolicy != null && message.hasOwnProperty("queryCachePolicy")) {
                    var error = $root.Ydb.Table.QueryCachePolicy.verify(message.queryCachePolicy);
                    if (error)
                        return "queryCachePolicy." + error;
                }
                if (message.operationParams != null && message.hasOwnProperty("operationParams")) {
                    var error = $root.Ydb.Operations.OperationParams.verify(message.operationParams);
                    if (error)
                        return "operationParams." + error;
                }
                if (message.collectStats != null && message.hasOwnProperty("collectStats"))
                    switch (message.collectStats) {
                    default:
                        return "collectStats: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                        break;
                    }
                return null;
            };

            /**
             * Creates an ExecuteDataQueryRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.ExecuteDataQueryRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.ExecuteDataQueryRequest} ExecuteDataQueryRequest
             */
            ExecuteDataQueryRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.ExecuteDataQueryRequest)
                    return object;
                var message = new $root.Ydb.Table.ExecuteDataQueryRequest();
                if (object.sessionId != null)
                    message.sessionId = String(object.sessionId);
                if (object.txControl != null) {
                    if (typeof object.txControl !== "object")
                        throw TypeError(".Ydb.Table.ExecuteDataQueryRequest.txControl: object expected");
                    message.txControl = $root.Ydb.Table.TransactionControl.fromObject(object.txControl);
                }
                if (object.query != null) {
                    if (typeof object.query !== "object")
                        throw TypeError(".Ydb.Table.ExecuteDataQueryRequest.query: object expected");
                    message.query = $root.Ydb.Table.Query.fromObject(object.query);
                }
                if (object.parameters) {
                    if (typeof object.parameters !== "object")
                        throw TypeError(".Ydb.Table.ExecuteDataQueryRequest.parameters: object expected");
                    message.parameters = {};
                    for (var keys = Object.keys(object.parameters), i = 0; i < keys.length; ++i) {
                        if (typeof object.parameters[keys[i]] !== "object")
                            throw TypeError(".Ydb.Table.ExecuteDataQueryRequest.parameters: object expected");
                        message.parameters[keys[i]] = $root.Ydb.TypedValue.fromObject(object.parameters[keys[i]]);
                    }
                }
                if (object.queryCachePolicy != null) {
                    if (typeof object.queryCachePolicy !== "object")
                        throw TypeError(".Ydb.Table.ExecuteDataQueryRequest.queryCachePolicy: object expected");
                    message.queryCachePolicy = $root.Ydb.Table.QueryCachePolicy.fromObject(object.queryCachePolicy);
                }
                if (object.operationParams != null) {
                    if (typeof object.operationParams !== "object")
                        throw TypeError(".Ydb.Table.ExecuteDataQueryRequest.operationParams: object expected");
                    message.operationParams = $root.Ydb.Operations.OperationParams.fromObject(object.operationParams);
                }
                switch (object.collectStats) {
                case "STATS_COLLECTION_UNSPECIFIED":
                case 0:
                    message.collectStats = 0;
                    break;
                case "STATS_COLLECTION_NONE":
                case 1:
                    message.collectStats = 1;
                    break;
                case "STATS_COLLECTION_BASIC":
                case 2:
                    message.collectStats = 2;
                    break;
                case "STATS_COLLECTION_FULL":
                case 3:
                    message.collectStats = 3;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from an ExecuteDataQueryRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.ExecuteDataQueryRequest
             * @static
             * @param {Ydb.Table.ExecuteDataQueryRequest} message ExecuteDataQueryRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ExecuteDataQueryRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.objects || options.defaults)
                    object.parameters = {};
                if (options.defaults) {
                    object.sessionId = "";
                    object.txControl = null;
                    object.query = null;
                    object.queryCachePolicy = null;
                    object.operationParams = null;
                    object.collectStats = options.enums === String ? "STATS_COLLECTION_UNSPECIFIED" : 0;
                }
                if (message.sessionId != null && message.hasOwnProperty("sessionId"))
                    object.sessionId = message.sessionId;
                if (message.txControl != null && message.hasOwnProperty("txControl"))
                    object.txControl = $root.Ydb.Table.TransactionControl.toObject(message.txControl, options);
                if (message.query != null && message.hasOwnProperty("query"))
                    object.query = $root.Ydb.Table.Query.toObject(message.query, options);
                var keys2;
                if (message.parameters && (keys2 = Object.keys(message.parameters)).length) {
                    object.parameters = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.parameters[keys2[j]] = $root.Ydb.TypedValue.toObject(message.parameters[keys2[j]], options);
                }
                if (message.queryCachePolicy != null && message.hasOwnProperty("queryCachePolicy"))
                    object.queryCachePolicy = $root.Ydb.Table.QueryCachePolicy.toObject(message.queryCachePolicy, options);
                if (message.operationParams != null && message.hasOwnProperty("operationParams"))
                    object.operationParams = $root.Ydb.Operations.OperationParams.toObject(message.operationParams, options);
                if (message.collectStats != null && message.hasOwnProperty("collectStats"))
                    object.collectStats = options.enums === String ? $root.Ydb.Table.QueryStatsCollection.Mode[message.collectStats] : message.collectStats;
                return object;
            };

            /**
             * Converts this ExecuteDataQueryRequest to JSON.
             * @function toJSON
             * @memberof Ydb.Table.ExecuteDataQueryRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ExecuteDataQueryRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ExecuteDataQueryRequest;
        })();

        Table.ExecuteDataQueryResponse = (function() {

            /**
             * Properties of an ExecuteDataQueryResponse.
             * @memberof Ydb.Table
             * @interface IExecuteDataQueryResponse
             * @property {Ydb.Operations.IOperation|null} [operation] ExecuteDataQueryResponse operation
             */

            /**
             * Constructs a new ExecuteDataQueryResponse.
             * @memberof Ydb.Table
             * @classdesc Represents an ExecuteDataQueryResponse.
             * @implements IExecuteDataQueryResponse
             * @constructor
             * @param {Ydb.Table.IExecuteDataQueryResponse=} [properties] Properties to set
             */
            function ExecuteDataQueryResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ExecuteDataQueryResponse operation.
             * @member {Ydb.Operations.IOperation|null|undefined} operation
             * @memberof Ydb.Table.ExecuteDataQueryResponse
             * @instance
             */
            ExecuteDataQueryResponse.prototype.operation = null;

            /**
             * Creates a new ExecuteDataQueryResponse instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.ExecuteDataQueryResponse
             * @static
             * @param {Ydb.Table.IExecuteDataQueryResponse=} [properties] Properties to set
             * @returns {Ydb.Table.ExecuteDataQueryResponse} ExecuteDataQueryResponse instance
             */
            ExecuteDataQueryResponse.create = function create(properties) {
                return new ExecuteDataQueryResponse(properties);
            };

            /**
             * Encodes the specified ExecuteDataQueryResponse message. Does not implicitly {@link Ydb.Table.ExecuteDataQueryResponse.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.ExecuteDataQueryResponse
             * @static
             * @param {Ydb.Table.IExecuteDataQueryResponse} message ExecuteDataQueryResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExecuteDataQueryResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.operation != null && Object.hasOwnProperty.call(message, "operation"))
                    $root.Ydb.Operations.Operation.encode(message.operation, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ExecuteDataQueryResponse message, length delimited. Does not implicitly {@link Ydb.Table.ExecuteDataQueryResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.ExecuteDataQueryResponse
             * @static
             * @param {Ydb.Table.IExecuteDataQueryResponse} message ExecuteDataQueryResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExecuteDataQueryResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ExecuteDataQueryResponse message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.ExecuteDataQueryResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.ExecuteDataQueryResponse} ExecuteDataQueryResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExecuteDataQueryResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.ExecuteDataQueryResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.operation = $root.Ydb.Operations.Operation.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an ExecuteDataQueryResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.ExecuteDataQueryResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.ExecuteDataQueryResponse} ExecuteDataQueryResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExecuteDataQueryResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ExecuteDataQueryResponse message.
             * @function verify
             * @memberof Ydb.Table.ExecuteDataQueryResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ExecuteDataQueryResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.operation != null && message.hasOwnProperty("operation")) {
                    var error = $root.Ydb.Operations.Operation.verify(message.operation);
                    if (error)
                        return "operation." + error;
                }
                return null;
            };

            /**
             * Creates an ExecuteDataQueryResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.ExecuteDataQueryResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.ExecuteDataQueryResponse} ExecuteDataQueryResponse
             */
            ExecuteDataQueryResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.ExecuteDataQueryResponse)
                    return object;
                var message = new $root.Ydb.Table.ExecuteDataQueryResponse();
                if (object.operation != null) {
                    if (typeof object.operation !== "object")
                        throw TypeError(".Ydb.Table.ExecuteDataQueryResponse.operation: object expected");
                    message.operation = $root.Ydb.Operations.Operation.fromObject(object.operation);
                }
                return message;
            };

            /**
             * Creates a plain object from an ExecuteDataQueryResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.ExecuteDataQueryResponse
             * @static
             * @param {Ydb.Table.ExecuteDataQueryResponse} message ExecuteDataQueryResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ExecuteDataQueryResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.operation = null;
                if (message.operation != null && message.hasOwnProperty("operation"))
                    object.operation = $root.Ydb.Operations.Operation.toObject(message.operation, options);
                return object;
            };

            /**
             * Converts this ExecuteDataQueryResponse to JSON.
             * @function toJSON
             * @memberof Ydb.Table.ExecuteDataQueryResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ExecuteDataQueryResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ExecuteDataQueryResponse;
        })();

        Table.ExecuteSchemeQueryRequest = (function() {

            /**
             * Properties of an ExecuteSchemeQueryRequest.
             * @memberof Ydb.Table
             * @interface IExecuteSchemeQueryRequest
             * @property {string|null} [sessionId] ExecuteSchemeQueryRequest sessionId
             * @property {string|null} [yqlText] ExecuteSchemeQueryRequest yqlText
             * @property {Ydb.Operations.IOperationParams|null} [operationParams] ExecuteSchemeQueryRequest operationParams
             */

            /**
             * Constructs a new ExecuteSchemeQueryRequest.
             * @memberof Ydb.Table
             * @classdesc Represents an ExecuteSchemeQueryRequest.
             * @implements IExecuteSchemeQueryRequest
             * @constructor
             * @param {Ydb.Table.IExecuteSchemeQueryRequest=} [properties] Properties to set
             */
            function ExecuteSchemeQueryRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ExecuteSchemeQueryRequest sessionId.
             * @member {string} sessionId
             * @memberof Ydb.Table.ExecuteSchemeQueryRequest
             * @instance
             */
            ExecuteSchemeQueryRequest.prototype.sessionId = "";

            /**
             * ExecuteSchemeQueryRequest yqlText.
             * @member {string} yqlText
             * @memberof Ydb.Table.ExecuteSchemeQueryRequest
             * @instance
             */
            ExecuteSchemeQueryRequest.prototype.yqlText = "";

            /**
             * ExecuteSchemeQueryRequest operationParams.
             * @member {Ydb.Operations.IOperationParams|null|undefined} operationParams
             * @memberof Ydb.Table.ExecuteSchemeQueryRequest
             * @instance
             */
            ExecuteSchemeQueryRequest.prototype.operationParams = null;

            /**
             * Creates a new ExecuteSchemeQueryRequest instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.ExecuteSchemeQueryRequest
             * @static
             * @param {Ydb.Table.IExecuteSchemeQueryRequest=} [properties] Properties to set
             * @returns {Ydb.Table.ExecuteSchemeQueryRequest} ExecuteSchemeQueryRequest instance
             */
            ExecuteSchemeQueryRequest.create = function create(properties) {
                return new ExecuteSchemeQueryRequest(properties);
            };

            /**
             * Encodes the specified ExecuteSchemeQueryRequest message. Does not implicitly {@link Ydb.Table.ExecuteSchemeQueryRequest.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.ExecuteSchemeQueryRequest
             * @static
             * @param {Ydb.Table.IExecuteSchemeQueryRequest} message ExecuteSchemeQueryRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExecuteSchemeQueryRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.sessionId != null && Object.hasOwnProperty.call(message, "sessionId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.sessionId);
                if (message.yqlText != null && Object.hasOwnProperty.call(message, "yqlText"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.yqlText);
                if (message.operationParams != null && Object.hasOwnProperty.call(message, "operationParams"))
                    $root.Ydb.Operations.OperationParams.encode(message.operationParams, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ExecuteSchemeQueryRequest message, length delimited. Does not implicitly {@link Ydb.Table.ExecuteSchemeQueryRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.ExecuteSchemeQueryRequest
             * @static
             * @param {Ydb.Table.IExecuteSchemeQueryRequest} message ExecuteSchemeQueryRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExecuteSchemeQueryRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ExecuteSchemeQueryRequest message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.ExecuteSchemeQueryRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.ExecuteSchemeQueryRequest} ExecuteSchemeQueryRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExecuteSchemeQueryRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.ExecuteSchemeQueryRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.sessionId = reader.string();
                        break;
                    case 2:
                        message.yqlText = reader.string();
                        break;
                    case 3:
                        message.operationParams = $root.Ydb.Operations.OperationParams.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an ExecuteSchemeQueryRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.ExecuteSchemeQueryRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.ExecuteSchemeQueryRequest} ExecuteSchemeQueryRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExecuteSchemeQueryRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ExecuteSchemeQueryRequest message.
             * @function verify
             * @memberof Ydb.Table.ExecuteSchemeQueryRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ExecuteSchemeQueryRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.sessionId != null && message.hasOwnProperty("sessionId"))
                    if (!$util.isString(message.sessionId))
                        return "sessionId: string expected";
                if (message.yqlText != null && message.hasOwnProperty("yqlText"))
                    if (!$util.isString(message.yqlText))
                        return "yqlText: string expected";
                if (message.operationParams != null && message.hasOwnProperty("operationParams")) {
                    var error = $root.Ydb.Operations.OperationParams.verify(message.operationParams);
                    if (error)
                        return "operationParams." + error;
                }
                return null;
            };

            /**
             * Creates an ExecuteSchemeQueryRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.ExecuteSchemeQueryRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.ExecuteSchemeQueryRequest} ExecuteSchemeQueryRequest
             */
            ExecuteSchemeQueryRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.ExecuteSchemeQueryRequest)
                    return object;
                var message = new $root.Ydb.Table.ExecuteSchemeQueryRequest();
                if (object.sessionId != null)
                    message.sessionId = String(object.sessionId);
                if (object.yqlText != null)
                    message.yqlText = String(object.yqlText);
                if (object.operationParams != null) {
                    if (typeof object.operationParams !== "object")
                        throw TypeError(".Ydb.Table.ExecuteSchemeQueryRequest.operationParams: object expected");
                    message.operationParams = $root.Ydb.Operations.OperationParams.fromObject(object.operationParams);
                }
                return message;
            };

            /**
             * Creates a plain object from an ExecuteSchemeQueryRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.ExecuteSchemeQueryRequest
             * @static
             * @param {Ydb.Table.ExecuteSchemeQueryRequest} message ExecuteSchemeQueryRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ExecuteSchemeQueryRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.sessionId = "";
                    object.yqlText = "";
                    object.operationParams = null;
                }
                if (message.sessionId != null && message.hasOwnProperty("sessionId"))
                    object.sessionId = message.sessionId;
                if (message.yqlText != null && message.hasOwnProperty("yqlText"))
                    object.yqlText = message.yqlText;
                if (message.operationParams != null && message.hasOwnProperty("operationParams"))
                    object.operationParams = $root.Ydb.Operations.OperationParams.toObject(message.operationParams, options);
                return object;
            };

            /**
             * Converts this ExecuteSchemeQueryRequest to JSON.
             * @function toJSON
             * @memberof Ydb.Table.ExecuteSchemeQueryRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ExecuteSchemeQueryRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ExecuteSchemeQueryRequest;
        })();

        Table.ExecuteSchemeQueryResponse = (function() {

            /**
             * Properties of an ExecuteSchemeQueryResponse.
             * @memberof Ydb.Table
             * @interface IExecuteSchemeQueryResponse
             * @property {Ydb.Operations.IOperation|null} [operation] ExecuteSchemeQueryResponse operation
             */

            /**
             * Constructs a new ExecuteSchemeQueryResponse.
             * @memberof Ydb.Table
             * @classdesc Represents an ExecuteSchemeQueryResponse.
             * @implements IExecuteSchemeQueryResponse
             * @constructor
             * @param {Ydb.Table.IExecuteSchemeQueryResponse=} [properties] Properties to set
             */
            function ExecuteSchemeQueryResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ExecuteSchemeQueryResponse operation.
             * @member {Ydb.Operations.IOperation|null|undefined} operation
             * @memberof Ydb.Table.ExecuteSchemeQueryResponse
             * @instance
             */
            ExecuteSchemeQueryResponse.prototype.operation = null;

            /**
             * Creates a new ExecuteSchemeQueryResponse instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.ExecuteSchemeQueryResponse
             * @static
             * @param {Ydb.Table.IExecuteSchemeQueryResponse=} [properties] Properties to set
             * @returns {Ydb.Table.ExecuteSchemeQueryResponse} ExecuteSchemeQueryResponse instance
             */
            ExecuteSchemeQueryResponse.create = function create(properties) {
                return new ExecuteSchemeQueryResponse(properties);
            };

            /**
             * Encodes the specified ExecuteSchemeQueryResponse message. Does not implicitly {@link Ydb.Table.ExecuteSchemeQueryResponse.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.ExecuteSchemeQueryResponse
             * @static
             * @param {Ydb.Table.IExecuteSchemeQueryResponse} message ExecuteSchemeQueryResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExecuteSchemeQueryResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.operation != null && Object.hasOwnProperty.call(message, "operation"))
                    $root.Ydb.Operations.Operation.encode(message.operation, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ExecuteSchemeQueryResponse message, length delimited. Does not implicitly {@link Ydb.Table.ExecuteSchemeQueryResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.ExecuteSchemeQueryResponse
             * @static
             * @param {Ydb.Table.IExecuteSchemeQueryResponse} message ExecuteSchemeQueryResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExecuteSchemeQueryResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ExecuteSchemeQueryResponse message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.ExecuteSchemeQueryResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.ExecuteSchemeQueryResponse} ExecuteSchemeQueryResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExecuteSchemeQueryResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.ExecuteSchemeQueryResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.operation = $root.Ydb.Operations.Operation.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an ExecuteSchemeQueryResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.ExecuteSchemeQueryResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.ExecuteSchemeQueryResponse} ExecuteSchemeQueryResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExecuteSchemeQueryResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ExecuteSchemeQueryResponse message.
             * @function verify
             * @memberof Ydb.Table.ExecuteSchemeQueryResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ExecuteSchemeQueryResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.operation != null && message.hasOwnProperty("operation")) {
                    var error = $root.Ydb.Operations.Operation.verify(message.operation);
                    if (error)
                        return "operation." + error;
                }
                return null;
            };

            /**
             * Creates an ExecuteSchemeQueryResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.ExecuteSchemeQueryResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.ExecuteSchemeQueryResponse} ExecuteSchemeQueryResponse
             */
            ExecuteSchemeQueryResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.ExecuteSchemeQueryResponse)
                    return object;
                var message = new $root.Ydb.Table.ExecuteSchemeQueryResponse();
                if (object.operation != null) {
                    if (typeof object.operation !== "object")
                        throw TypeError(".Ydb.Table.ExecuteSchemeQueryResponse.operation: object expected");
                    message.operation = $root.Ydb.Operations.Operation.fromObject(object.operation);
                }
                return message;
            };

            /**
             * Creates a plain object from an ExecuteSchemeQueryResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.ExecuteSchemeQueryResponse
             * @static
             * @param {Ydb.Table.ExecuteSchemeQueryResponse} message ExecuteSchemeQueryResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ExecuteSchemeQueryResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.operation = null;
                if (message.operation != null && message.hasOwnProperty("operation"))
                    object.operation = $root.Ydb.Operations.Operation.toObject(message.operation, options);
                return object;
            };

            /**
             * Converts this ExecuteSchemeQueryResponse to JSON.
             * @function toJSON
             * @memberof Ydb.Table.ExecuteSchemeQueryResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ExecuteSchemeQueryResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ExecuteSchemeQueryResponse;
        })();

        Table.TransactionMeta = (function() {

            /**
             * Properties of a TransactionMeta.
             * @memberof Ydb.Table
             * @interface ITransactionMeta
             * @property {string|null} [id] TransactionMeta id
             */

            /**
             * Constructs a new TransactionMeta.
             * @memberof Ydb.Table
             * @classdesc Represents a TransactionMeta.
             * @implements ITransactionMeta
             * @constructor
             * @param {Ydb.Table.ITransactionMeta=} [properties] Properties to set
             */
            function TransactionMeta(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * TransactionMeta id.
             * @member {string} id
             * @memberof Ydb.Table.TransactionMeta
             * @instance
             */
            TransactionMeta.prototype.id = "";

            /**
             * Creates a new TransactionMeta instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.TransactionMeta
             * @static
             * @param {Ydb.Table.ITransactionMeta=} [properties] Properties to set
             * @returns {Ydb.Table.TransactionMeta} TransactionMeta instance
             */
            TransactionMeta.create = function create(properties) {
                return new TransactionMeta(properties);
            };

            /**
             * Encodes the specified TransactionMeta message. Does not implicitly {@link Ydb.Table.TransactionMeta.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.TransactionMeta
             * @static
             * @param {Ydb.Table.ITransactionMeta} message TransactionMeta message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TransactionMeta.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                return writer;
            };

            /**
             * Encodes the specified TransactionMeta message, length delimited. Does not implicitly {@link Ydb.Table.TransactionMeta.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.TransactionMeta
             * @static
             * @param {Ydb.Table.ITransactionMeta} message TransactionMeta message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TransactionMeta.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a TransactionMeta message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.TransactionMeta
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.TransactionMeta} TransactionMeta
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TransactionMeta.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.TransactionMeta();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a TransactionMeta message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.TransactionMeta
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.TransactionMeta} TransactionMeta
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TransactionMeta.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a TransactionMeta message.
             * @function verify
             * @memberof Ydb.Table.TransactionMeta
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TransactionMeta.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isString(message.id))
                        return "id: string expected";
                return null;
            };

            /**
             * Creates a TransactionMeta message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.TransactionMeta
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.TransactionMeta} TransactionMeta
             */
            TransactionMeta.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.TransactionMeta)
                    return object;
                var message = new $root.Ydb.Table.TransactionMeta();
                if (object.id != null)
                    message.id = String(object.id);
                return message;
            };

            /**
             * Creates a plain object from a TransactionMeta message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.TransactionMeta
             * @static
             * @param {Ydb.Table.TransactionMeta} message TransactionMeta
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            TransactionMeta.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.id = "";
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                return object;
            };

            /**
             * Converts this TransactionMeta to JSON.
             * @function toJSON
             * @memberof Ydb.Table.TransactionMeta
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            TransactionMeta.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return TransactionMeta;
        })();

        Table.QueryMeta = (function() {

            /**
             * Properties of a QueryMeta.
             * @memberof Ydb.Table
             * @interface IQueryMeta
             * @property {string|null} [id] QueryMeta id
             * @property {Object.<string,Ydb.IType>|null} [parametersTypes] QueryMeta parametersTypes
             */

            /**
             * Constructs a new QueryMeta.
             * @memberof Ydb.Table
             * @classdesc Represents a QueryMeta.
             * @implements IQueryMeta
             * @constructor
             * @param {Ydb.Table.IQueryMeta=} [properties] Properties to set
             */
            function QueryMeta(properties) {
                this.parametersTypes = {};
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * QueryMeta id.
             * @member {string} id
             * @memberof Ydb.Table.QueryMeta
             * @instance
             */
            QueryMeta.prototype.id = "";

            /**
             * QueryMeta parametersTypes.
             * @member {Object.<string,Ydb.IType>} parametersTypes
             * @memberof Ydb.Table.QueryMeta
             * @instance
             */
            QueryMeta.prototype.parametersTypes = $util.emptyObject;

            /**
             * Creates a new QueryMeta instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.QueryMeta
             * @static
             * @param {Ydb.Table.IQueryMeta=} [properties] Properties to set
             * @returns {Ydb.Table.QueryMeta} QueryMeta instance
             */
            QueryMeta.create = function create(properties) {
                return new QueryMeta(properties);
            };

            /**
             * Encodes the specified QueryMeta message. Does not implicitly {@link Ydb.Table.QueryMeta.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.QueryMeta
             * @static
             * @param {Ydb.Table.IQueryMeta} message QueryMeta message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryMeta.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                if (message.parametersTypes != null && Object.hasOwnProperty.call(message, "parametersTypes"))
                    for (var keys = Object.keys(message.parametersTypes), i = 0; i < keys.length; ++i) {
                        writer.uint32(/* id 2, wireType 2 =*/18).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                        $root.Ydb.Type.encode(message.parametersTypes[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                    }
                return writer;
            };

            /**
             * Encodes the specified QueryMeta message, length delimited. Does not implicitly {@link Ydb.Table.QueryMeta.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.QueryMeta
             * @static
             * @param {Ydb.Table.IQueryMeta} message QueryMeta message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryMeta.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a QueryMeta message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.QueryMeta
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.QueryMeta} QueryMeta
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryMeta.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.QueryMeta(), key, value;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = reader.string();
                        break;
                    case 2:
                        if (message.parametersTypes === $util.emptyObject)
                            message.parametersTypes = {};
                        var end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = null;
                        while (reader.pos < end2) {
                            var tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = $root.Ydb.Type.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.parametersTypes[key] = value;
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a QueryMeta message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.QueryMeta
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.QueryMeta} QueryMeta
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryMeta.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a QueryMeta message.
             * @function verify
             * @memberof Ydb.Table.QueryMeta
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            QueryMeta.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isString(message.id))
                        return "id: string expected";
                if (message.parametersTypes != null && message.hasOwnProperty("parametersTypes")) {
                    if (!$util.isObject(message.parametersTypes))
                        return "parametersTypes: object expected";
                    var key = Object.keys(message.parametersTypes);
                    for (var i = 0; i < key.length; ++i) {
                        var error = $root.Ydb.Type.verify(message.parametersTypes[key[i]]);
                        if (error)
                            return "parametersTypes." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a QueryMeta message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.QueryMeta
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.QueryMeta} QueryMeta
             */
            QueryMeta.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.QueryMeta)
                    return object;
                var message = new $root.Ydb.Table.QueryMeta();
                if (object.id != null)
                    message.id = String(object.id);
                if (object.parametersTypes) {
                    if (typeof object.parametersTypes !== "object")
                        throw TypeError(".Ydb.Table.QueryMeta.parametersTypes: object expected");
                    message.parametersTypes = {};
                    for (var keys = Object.keys(object.parametersTypes), i = 0; i < keys.length; ++i) {
                        if (typeof object.parametersTypes[keys[i]] !== "object")
                            throw TypeError(".Ydb.Table.QueryMeta.parametersTypes: object expected");
                        message.parametersTypes[keys[i]] = $root.Ydb.Type.fromObject(object.parametersTypes[keys[i]]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a QueryMeta message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.QueryMeta
             * @static
             * @param {Ydb.Table.QueryMeta} message QueryMeta
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            QueryMeta.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.objects || options.defaults)
                    object.parametersTypes = {};
                if (options.defaults)
                    object.id = "";
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                var keys2;
                if (message.parametersTypes && (keys2 = Object.keys(message.parametersTypes)).length) {
                    object.parametersTypes = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.parametersTypes[keys2[j]] = $root.Ydb.Type.toObject(message.parametersTypes[keys2[j]], options);
                }
                return object;
            };

            /**
             * Converts this QueryMeta to JSON.
             * @function toJSON
             * @memberof Ydb.Table.QueryMeta
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            QueryMeta.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return QueryMeta;
        })();

        Table.ExecuteQueryResult = (function() {

            /**
             * Properties of an ExecuteQueryResult.
             * @memberof Ydb.Table
             * @interface IExecuteQueryResult
             * @property {Array.<Ydb.IResultSet>|null} [resultSets] ExecuteQueryResult resultSets
             * @property {Ydb.Table.ITransactionMeta|null} [txMeta] ExecuteQueryResult txMeta
             * @property {Ydb.Table.IQueryMeta|null} [queryMeta] ExecuteQueryResult queryMeta
             * @property {Ydb.TableStats.IQueryStats|null} [queryStats] ExecuteQueryResult queryStats
             */

            /**
             * Constructs a new ExecuteQueryResult.
             * @memberof Ydb.Table
             * @classdesc Represents an ExecuteQueryResult.
             * @implements IExecuteQueryResult
             * @constructor
             * @param {Ydb.Table.IExecuteQueryResult=} [properties] Properties to set
             */
            function ExecuteQueryResult(properties) {
                this.resultSets = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ExecuteQueryResult resultSets.
             * @member {Array.<Ydb.IResultSet>} resultSets
             * @memberof Ydb.Table.ExecuteQueryResult
             * @instance
             */
            ExecuteQueryResult.prototype.resultSets = $util.emptyArray;

            /**
             * ExecuteQueryResult txMeta.
             * @member {Ydb.Table.ITransactionMeta|null|undefined} txMeta
             * @memberof Ydb.Table.ExecuteQueryResult
             * @instance
             */
            ExecuteQueryResult.prototype.txMeta = null;

            /**
             * ExecuteQueryResult queryMeta.
             * @member {Ydb.Table.IQueryMeta|null|undefined} queryMeta
             * @memberof Ydb.Table.ExecuteQueryResult
             * @instance
             */
            ExecuteQueryResult.prototype.queryMeta = null;

            /**
             * ExecuteQueryResult queryStats.
             * @member {Ydb.TableStats.IQueryStats|null|undefined} queryStats
             * @memberof Ydb.Table.ExecuteQueryResult
             * @instance
             */
            ExecuteQueryResult.prototype.queryStats = null;

            /**
             * Creates a new ExecuteQueryResult instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.ExecuteQueryResult
             * @static
             * @param {Ydb.Table.IExecuteQueryResult=} [properties] Properties to set
             * @returns {Ydb.Table.ExecuteQueryResult} ExecuteQueryResult instance
             */
            ExecuteQueryResult.create = function create(properties) {
                return new ExecuteQueryResult(properties);
            };

            /**
             * Encodes the specified ExecuteQueryResult message. Does not implicitly {@link Ydb.Table.ExecuteQueryResult.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.ExecuteQueryResult
             * @static
             * @param {Ydb.Table.IExecuteQueryResult} message ExecuteQueryResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExecuteQueryResult.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.resultSets != null && message.resultSets.length)
                    for (var i = 0; i < message.resultSets.length; ++i)
                        $root.Ydb.ResultSet.encode(message.resultSets[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.txMeta != null && Object.hasOwnProperty.call(message, "txMeta"))
                    $root.Ydb.Table.TransactionMeta.encode(message.txMeta, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.queryMeta != null && Object.hasOwnProperty.call(message, "queryMeta"))
                    $root.Ydb.Table.QueryMeta.encode(message.queryMeta, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.queryStats != null && Object.hasOwnProperty.call(message, "queryStats"))
                    $root.Ydb.TableStats.QueryStats.encode(message.queryStats, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ExecuteQueryResult message, length delimited. Does not implicitly {@link Ydb.Table.ExecuteQueryResult.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.ExecuteQueryResult
             * @static
             * @param {Ydb.Table.IExecuteQueryResult} message ExecuteQueryResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExecuteQueryResult.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ExecuteQueryResult message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.ExecuteQueryResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.ExecuteQueryResult} ExecuteQueryResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExecuteQueryResult.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.ExecuteQueryResult();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.resultSets && message.resultSets.length))
                            message.resultSets = [];
                        message.resultSets.push($root.Ydb.ResultSet.decode(reader, reader.uint32()));
                        break;
                    case 2:
                        message.txMeta = $root.Ydb.Table.TransactionMeta.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.queryMeta = $root.Ydb.Table.QueryMeta.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.queryStats = $root.Ydb.TableStats.QueryStats.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an ExecuteQueryResult message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.ExecuteQueryResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.ExecuteQueryResult} ExecuteQueryResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExecuteQueryResult.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ExecuteQueryResult message.
             * @function verify
             * @memberof Ydb.Table.ExecuteQueryResult
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ExecuteQueryResult.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.resultSets != null && message.hasOwnProperty("resultSets")) {
                    if (!Array.isArray(message.resultSets))
                        return "resultSets: array expected";
                    for (var i = 0; i < message.resultSets.length; ++i) {
                        var error = $root.Ydb.ResultSet.verify(message.resultSets[i]);
                        if (error)
                            return "resultSets." + error;
                    }
                }
                if (message.txMeta != null && message.hasOwnProperty("txMeta")) {
                    var error = $root.Ydb.Table.TransactionMeta.verify(message.txMeta);
                    if (error)
                        return "txMeta." + error;
                }
                if (message.queryMeta != null && message.hasOwnProperty("queryMeta")) {
                    var error = $root.Ydb.Table.QueryMeta.verify(message.queryMeta);
                    if (error)
                        return "queryMeta." + error;
                }
                if (message.queryStats != null && message.hasOwnProperty("queryStats")) {
                    var error = $root.Ydb.TableStats.QueryStats.verify(message.queryStats);
                    if (error)
                        return "queryStats." + error;
                }
                return null;
            };

            /**
             * Creates an ExecuteQueryResult message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.ExecuteQueryResult
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.ExecuteQueryResult} ExecuteQueryResult
             */
            ExecuteQueryResult.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.ExecuteQueryResult)
                    return object;
                var message = new $root.Ydb.Table.ExecuteQueryResult();
                if (object.resultSets) {
                    if (!Array.isArray(object.resultSets))
                        throw TypeError(".Ydb.Table.ExecuteQueryResult.resultSets: array expected");
                    message.resultSets = [];
                    for (var i = 0; i < object.resultSets.length; ++i) {
                        if (typeof object.resultSets[i] !== "object")
                            throw TypeError(".Ydb.Table.ExecuteQueryResult.resultSets: object expected");
                        message.resultSets[i] = $root.Ydb.ResultSet.fromObject(object.resultSets[i]);
                    }
                }
                if (object.txMeta != null) {
                    if (typeof object.txMeta !== "object")
                        throw TypeError(".Ydb.Table.ExecuteQueryResult.txMeta: object expected");
                    message.txMeta = $root.Ydb.Table.TransactionMeta.fromObject(object.txMeta);
                }
                if (object.queryMeta != null) {
                    if (typeof object.queryMeta !== "object")
                        throw TypeError(".Ydb.Table.ExecuteQueryResult.queryMeta: object expected");
                    message.queryMeta = $root.Ydb.Table.QueryMeta.fromObject(object.queryMeta);
                }
                if (object.queryStats != null) {
                    if (typeof object.queryStats !== "object")
                        throw TypeError(".Ydb.Table.ExecuteQueryResult.queryStats: object expected");
                    message.queryStats = $root.Ydb.TableStats.QueryStats.fromObject(object.queryStats);
                }
                return message;
            };

            /**
             * Creates a plain object from an ExecuteQueryResult message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.ExecuteQueryResult
             * @static
             * @param {Ydb.Table.ExecuteQueryResult} message ExecuteQueryResult
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ExecuteQueryResult.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.resultSets = [];
                if (options.defaults) {
                    object.txMeta = null;
                    object.queryMeta = null;
                    object.queryStats = null;
                }
                if (message.resultSets && message.resultSets.length) {
                    object.resultSets = [];
                    for (var j = 0; j < message.resultSets.length; ++j)
                        object.resultSets[j] = $root.Ydb.ResultSet.toObject(message.resultSets[j], options);
                }
                if (message.txMeta != null && message.hasOwnProperty("txMeta"))
                    object.txMeta = $root.Ydb.Table.TransactionMeta.toObject(message.txMeta, options);
                if (message.queryMeta != null && message.hasOwnProperty("queryMeta"))
                    object.queryMeta = $root.Ydb.Table.QueryMeta.toObject(message.queryMeta, options);
                if (message.queryStats != null && message.hasOwnProperty("queryStats"))
                    object.queryStats = $root.Ydb.TableStats.QueryStats.toObject(message.queryStats, options);
                return object;
            };

            /**
             * Converts this ExecuteQueryResult to JSON.
             * @function toJSON
             * @memberof Ydb.Table.ExecuteQueryResult
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ExecuteQueryResult.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ExecuteQueryResult;
        })();

        Table.ExplainDataQueryRequest = (function() {

            /**
             * Properties of an ExplainDataQueryRequest.
             * @memberof Ydb.Table
             * @interface IExplainDataQueryRequest
             * @property {string|null} [sessionId] ExplainDataQueryRequest sessionId
             * @property {string|null} [yqlText] ExplainDataQueryRequest yqlText
             * @property {Ydb.Operations.IOperationParams|null} [operationParams] ExplainDataQueryRequest operationParams
             */

            /**
             * Constructs a new ExplainDataQueryRequest.
             * @memberof Ydb.Table
             * @classdesc Represents an ExplainDataQueryRequest.
             * @implements IExplainDataQueryRequest
             * @constructor
             * @param {Ydb.Table.IExplainDataQueryRequest=} [properties] Properties to set
             */
            function ExplainDataQueryRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ExplainDataQueryRequest sessionId.
             * @member {string} sessionId
             * @memberof Ydb.Table.ExplainDataQueryRequest
             * @instance
             */
            ExplainDataQueryRequest.prototype.sessionId = "";

            /**
             * ExplainDataQueryRequest yqlText.
             * @member {string} yqlText
             * @memberof Ydb.Table.ExplainDataQueryRequest
             * @instance
             */
            ExplainDataQueryRequest.prototype.yqlText = "";

            /**
             * ExplainDataQueryRequest operationParams.
             * @member {Ydb.Operations.IOperationParams|null|undefined} operationParams
             * @memberof Ydb.Table.ExplainDataQueryRequest
             * @instance
             */
            ExplainDataQueryRequest.prototype.operationParams = null;

            /**
             * Creates a new ExplainDataQueryRequest instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.ExplainDataQueryRequest
             * @static
             * @param {Ydb.Table.IExplainDataQueryRequest=} [properties] Properties to set
             * @returns {Ydb.Table.ExplainDataQueryRequest} ExplainDataQueryRequest instance
             */
            ExplainDataQueryRequest.create = function create(properties) {
                return new ExplainDataQueryRequest(properties);
            };

            /**
             * Encodes the specified ExplainDataQueryRequest message. Does not implicitly {@link Ydb.Table.ExplainDataQueryRequest.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.ExplainDataQueryRequest
             * @static
             * @param {Ydb.Table.IExplainDataQueryRequest} message ExplainDataQueryRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExplainDataQueryRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.sessionId != null && Object.hasOwnProperty.call(message, "sessionId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.sessionId);
                if (message.yqlText != null && Object.hasOwnProperty.call(message, "yqlText"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.yqlText);
                if (message.operationParams != null && Object.hasOwnProperty.call(message, "operationParams"))
                    $root.Ydb.Operations.OperationParams.encode(message.operationParams, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ExplainDataQueryRequest message, length delimited. Does not implicitly {@link Ydb.Table.ExplainDataQueryRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.ExplainDataQueryRequest
             * @static
             * @param {Ydb.Table.IExplainDataQueryRequest} message ExplainDataQueryRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExplainDataQueryRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ExplainDataQueryRequest message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.ExplainDataQueryRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.ExplainDataQueryRequest} ExplainDataQueryRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExplainDataQueryRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.ExplainDataQueryRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.sessionId = reader.string();
                        break;
                    case 2:
                        message.yqlText = reader.string();
                        break;
                    case 3:
                        message.operationParams = $root.Ydb.Operations.OperationParams.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an ExplainDataQueryRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.ExplainDataQueryRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.ExplainDataQueryRequest} ExplainDataQueryRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExplainDataQueryRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ExplainDataQueryRequest message.
             * @function verify
             * @memberof Ydb.Table.ExplainDataQueryRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ExplainDataQueryRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.sessionId != null && message.hasOwnProperty("sessionId"))
                    if (!$util.isString(message.sessionId))
                        return "sessionId: string expected";
                if (message.yqlText != null && message.hasOwnProperty("yqlText"))
                    if (!$util.isString(message.yqlText))
                        return "yqlText: string expected";
                if (message.operationParams != null && message.hasOwnProperty("operationParams")) {
                    var error = $root.Ydb.Operations.OperationParams.verify(message.operationParams);
                    if (error)
                        return "operationParams." + error;
                }
                return null;
            };

            /**
             * Creates an ExplainDataQueryRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.ExplainDataQueryRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.ExplainDataQueryRequest} ExplainDataQueryRequest
             */
            ExplainDataQueryRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.ExplainDataQueryRequest)
                    return object;
                var message = new $root.Ydb.Table.ExplainDataQueryRequest();
                if (object.sessionId != null)
                    message.sessionId = String(object.sessionId);
                if (object.yqlText != null)
                    message.yqlText = String(object.yqlText);
                if (object.operationParams != null) {
                    if (typeof object.operationParams !== "object")
                        throw TypeError(".Ydb.Table.ExplainDataQueryRequest.operationParams: object expected");
                    message.operationParams = $root.Ydb.Operations.OperationParams.fromObject(object.operationParams);
                }
                return message;
            };

            /**
             * Creates a plain object from an ExplainDataQueryRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.ExplainDataQueryRequest
             * @static
             * @param {Ydb.Table.ExplainDataQueryRequest} message ExplainDataQueryRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ExplainDataQueryRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.sessionId = "";
                    object.yqlText = "";
                    object.operationParams = null;
                }
                if (message.sessionId != null && message.hasOwnProperty("sessionId"))
                    object.sessionId = message.sessionId;
                if (message.yqlText != null && message.hasOwnProperty("yqlText"))
                    object.yqlText = message.yqlText;
                if (message.operationParams != null && message.hasOwnProperty("operationParams"))
                    object.operationParams = $root.Ydb.Operations.OperationParams.toObject(message.operationParams, options);
                return object;
            };

            /**
             * Converts this ExplainDataQueryRequest to JSON.
             * @function toJSON
             * @memberof Ydb.Table.ExplainDataQueryRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ExplainDataQueryRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ExplainDataQueryRequest;
        })();

        Table.ExplainDataQueryResponse = (function() {

            /**
             * Properties of an ExplainDataQueryResponse.
             * @memberof Ydb.Table
             * @interface IExplainDataQueryResponse
             * @property {Ydb.Operations.IOperation|null} [operation] ExplainDataQueryResponse operation
             */

            /**
             * Constructs a new ExplainDataQueryResponse.
             * @memberof Ydb.Table
             * @classdesc Represents an ExplainDataQueryResponse.
             * @implements IExplainDataQueryResponse
             * @constructor
             * @param {Ydb.Table.IExplainDataQueryResponse=} [properties] Properties to set
             */
            function ExplainDataQueryResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ExplainDataQueryResponse operation.
             * @member {Ydb.Operations.IOperation|null|undefined} operation
             * @memberof Ydb.Table.ExplainDataQueryResponse
             * @instance
             */
            ExplainDataQueryResponse.prototype.operation = null;

            /**
             * Creates a new ExplainDataQueryResponse instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.ExplainDataQueryResponse
             * @static
             * @param {Ydb.Table.IExplainDataQueryResponse=} [properties] Properties to set
             * @returns {Ydb.Table.ExplainDataQueryResponse} ExplainDataQueryResponse instance
             */
            ExplainDataQueryResponse.create = function create(properties) {
                return new ExplainDataQueryResponse(properties);
            };

            /**
             * Encodes the specified ExplainDataQueryResponse message. Does not implicitly {@link Ydb.Table.ExplainDataQueryResponse.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.ExplainDataQueryResponse
             * @static
             * @param {Ydb.Table.IExplainDataQueryResponse} message ExplainDataQueryResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExplainDataQueryResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.operation != null && Object.hasOwnProperty.call(message, "operation"))
                    $root.Ydb.Operations.Operation.encode(message.operation, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ExplainDataQueryResponse message, length delimited. Does not implicitly {@link Ydb.Table.ExplainDataQueryResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.ExplainDataQueryResponse
             * @static
             * @param {Ydb.Table.IExplainDataQueryResponse} message ExplainDataQueryResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExplainDataQueryResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ExplainDataQueryResponse message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.ExplainDataQueryResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.ExplainDataQueryResponse} ExplainDataQueryResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExplainDataQueryResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.ExplainDataQueryResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.operation = $root.Ydb.Operations.Operation.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an ExplainDataQueryResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.ExplainDataQueryResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.ExplainDataQueryResponse} ExplainDataQueryResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExplainDataQueryResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ExplainDataQueryResponse message.
             * @function verify
             * @memberof Ydb.Table.ExplainDataQueryResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ExplainDataQueryResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.operation != null && message.hasOwnProperty("operation")) {
                    var error = $root.Ydb.Operations.Operation.verify(message.operation);
                    if (error)
                        return "operation." + error;
                }
                return null;
            };

            /**
             * Creates an ExplainDataQueryResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.ExplainDataQueryResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.ExplainDataQueryResponse} ExplainDataQueryResponse
             */
            ExplainDataQueryResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.ExplainDataQueryResponse)
                    return object;
                var message = new $root.Ydb.Table.ExplainDataQueryResponse();
                if (object.operation != null) {
                    if (typeof object.operation !== "object")
                        throw TypeError(".Ydb.Table.ExplainDataQueryResponse.operation: object expected");
                    message.operation = $root.Ydb.Operations.Operation.fromObject(object.operation);
                }
                return message;
            };

            /**
             * Creates a plain object from an ExplainDataQueryResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.ExplainDataQueryResponse
             * @static
             * @param {Ydb.Table.ExplainDataQueryResponse} message ExplainDataQueryResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ExplainDataQueryResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.operation = null;
                if (message.operation != null && message.hasOwnProperty("operation"))
                    object.operation = $root.Ydb.Operations.Operation.toObject(message.operation, options);
                return object;
            };

            /**
             * Converts this ExplainDataQueryResponse to JSON.
             * @function toJSON
             * @memberof Ydb.Table.ExplainDataQueryResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ExplainDataQueryResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ExplainDataQueryResponse;
        })();

        Table.ExplainQueryResult = (function() {

            /**
             * Properties of an ExplainQueryResult.
             * @memberof Ydb.Table
             * @interface IExplainQueryResult
             * @property {string|null} [queryAst] ExplainQueryResult queryAst
             * @property {string|null} [queryPlan] ExplainQueryResult queryPlan
             */

            /**
             * Constructs a new ExplainQueryResult.
             * @memberof Ydb.Table
             * @classdesc Represents an ExplainQueryResult.
             * @implements IExplainQueryResult
             * @constructor
             * @param {Ydb.Table.IExplainQueryResult=} [properties] Properties to set
             */
            function ExplainQueryResult(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ExplainQueryResult queryAst.
             * @member {string} queryAst
             * @memberof Ydb.Table.ExplainQueryResult
             * @instance
             */
            ExplainQueryResult.prototype.queryAst = "";

            /**
             * ExplainQueryResult queryPlan.
             * @member {string} queryPlan
             * @memberof Ydb.Table.ExplainQueryResult
             * @instance
             */
            ExplainQueryResult.prototype.queryPlan = "";

            /**
             * Creates a new ExplainQueryResult instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.ExplainQueryResult
             * @static
             * @param {Ydb.Table.IExplainQueryResult=} [properties] Properties to set
             * @returns {Ydb.Table.ExplainQueryResult} ExplainQueryResult instance
             */
            ExplainQueryResult.create = function create(properties) {
                return new ExplainQueryResult(properties);
            };

            /**
             * Encodes the specified ExplainQueryResult message. Does not implicitly {@link Ydb.Table.ExplainQueryResult.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.ExplainQueryResult
             * @static
             * @param {Ydb.Table.IExplainQueryResult} message ExplainQueryResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExplainQueryResult.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.queryAst != null && Object.hasOwnProperty.call(message, "queryAst"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.queryAst);
                if (message.queryPlan != null && Object.hasOwnProperty.call(message, "queryPlan"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.queryPlan);
                return writer;
            };

            /**
             * Encodes the specified ExplainQueryResult message, length delimited. Does not implicitly {@link Ydb.Table.ExplainQueryResult.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.ExplainQueryResult
             * @static
             * @param {Ydb.Table.IExplainQueryResult} message ExplainQueryResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExplainQueryResult.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ExplainQueryResult message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.ExplainQueryResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.ExplainQueryResult} ExplainQueryResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExplainQueryResult.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.ExplainQueryResult();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.queryAst = reader.string();
                        break;
                    case 2:
                        message.queryPlan = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an ExplainQueryResult message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.ExplainQueryResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.ExplainQueryResult} ExplainQueryResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExplainQueryResult.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ExplainQueryResult message.
             * @function verify
             * @memberof Ydb.Table.ExplainQueryResult
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ExplainQueryResult.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.queryAst != null && message.hasOwnProperty("queryAst"))
                    if (!$util.isString(message.queryAst))
                        return "queryAst: string expected";
                if (message.queryPlan != null && message.hasOwnProperty("queryPlan"))
                    if (!$util.isString(message.queryPlan))
                        return "queryPlan: string expected";
                return null;
            };

            /**
             * Creates an ExplainQueryResult message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.ExplainQueryResult
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.ExplainQueryResult} ExplainQueryResult
             */
            ExplainQueryResult.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.ExplainQueryResult)
                    return object;
                var message = new $root.Ydb.Table.ExplainQueryResult();
                if (object.queryAst != null)
                    message.queryAst = String(object.queryAst);
                if (object.queryPlan != null)
                    message.queryPlan = String(object.queryPlan);
                return message;
            };

            /**
             * Creates a plain object from an ExplainQueryResult message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.ExplainQueryResult
             * @static
             * @param {Ydb.Table.ExplainQueryResult} message ExplainQueryResult
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ExplainQueryResult.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.queryAst = "";
                    object.queryPlan = "";
                }
                if (message.queryAst != null && message.hasOwnProperty("queryAst"))
                    object.queryAst = message.queryAst;
                if (message.queryPlan != null && message.hasOwnProperty("queryPlan"))
                    object.queryPlan = message.queryPlan;
                return object;
            };

            /**
             * Converts this ExplainQueryResult to JSON.
             * @function toJSON
             * @memberof Ydb.Table.ExplainQueryResult
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ExplainQueryResult.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ExplainQueryResult;
        })();

        Table.PrepareDataQueryRequest = (function() {

            /**
             * Properties of a PrepareDataQueryRequest.
             * @memberof Ydb.Table
             * @interface IPrepareDataQueryRequest
             * @property {string|null} [sessionId] PrepareDataQueryRequest sessionId
             * @property {string|null} [yqlText] PrepareDataQueryRequest yqlText
             * @property {Ydb.Operations.IOperationParams|null} [operationParams] PrepareDataQueryRequest operationParams
             */

            /**
             * Constructs a new PrepareDataQueryRequest.
             * @memberof Ydb.Table
             * @classdesc Represents a PrepareDataQueryRequest.
             * @implements IPrepareDataQueryRequest
             * @constructor
             * @param {Ydb.Table.IPrepareDataQueryRequest=} [properties] Properties to set
             */
            function PrepareDataQueryRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PrepareDataQueryRequest sessionId.
             * @member {string} sessionId
             * @memberof Ydb.Table.PrepareDataQueryRequest
             * @instance
             */
            PrepareDataQueryRequest.prototype.sessionId = "";

            /**
             * PrepareDataQueryRequest yqlText.
             * @member {string} yqlText
             * @memberof Ydb.Table.PrepareDataQueryRequest
             * @instance
             */
            PrepareDataQueryRequest.prototype.yqlText = "";

            /**
             * PrepareDataQueryRequest operationParams.
             * @member {Ydb.Operations.IOperationParams|null|undefined} operationParams
             * @memberof Ydb.Table.PrepareDataQueryRequest
             * @instance
             */
            PrepareDataQueryRequest.prototype.operationParams = null;

            /**
             * Creates a new PrepareDataQueryRequest instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.PrepareDataQueryRequest
             * @static
             * @param {Ydb.Table.IPrepareDataQueryRequest=} [properties] Properties to set
             * @returns {Ydb.Table.PrepareDataQueryRequest} PrepareDataQueryRequest instance
             */
            PrepareDataQueryRequest.create = function create(properties) {
                return new PrepareDataQueryRequest(properties);
            };

            /**
             * Encodes the specified PrepareDataQueryRequest message. Does not implicitly {@link Ydb.Table.PrepareDataQueryRequest.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.PrepareDataQueryRequest
             * @static
             * @param {Ydb.Table.IPrepareDataQueryRequest} message PrepareDataQueryRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PrepareDataQueryRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.sessionId != null && Object.hasOwnProperty.call(message, "sessionId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.sessionId);
                if (message.yqlText != null && Object.hasOwnProperty.call(message, "yqlText"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.yqlText);
                if (message.operationParams != null && Object.hasOwnProperty.call(message, "operationParams"))
                    $root.Ydb.Operations.OperationParams.encode(message.operationParams, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified PrepareDataQueryRequest message, length delimited. Does not implicitly {@link Ydb.Table.PrepareDataQueryRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.PrepareDataQueryRequest
             * @static
             * @param {Ydb.Table.IPrepareDataQueryRequest} message PrepareDataQueryRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PrepareDataQueryRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PrepareDataQueryRequest message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.PrepareDataQueryRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.PrepareDataQueryRequest} PrepareDataQueryRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PrepareDataQueryRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.PrepareDataQueryRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.sessionId = reader.string();
                        break;
                    case 2:
                        message.yqlText = reader.string();
                        break;
                    case 3:
                        message.operationParams = $root.Ydb.Operations.OperationParams.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a PrepareDataQueryRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.PrepareDataQueryRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.PrepareDataQueryRequest} PrepareDataQueryRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PrepareDataQueryRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PrepareDataQueryRequest message.
             * @function verify
             * @memberof Ydb.Table.PrepareDataQueryRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PrepareDataQueryRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.sessionId != null && message.hasOwnProperty("sessionId"))
                    if (!$util.isString(message.sessionId))
                        return "sessionId: string expected";
                if (message.yqlText != null && message.hasOwnProperty("yqlText"))
                    if (!$util.isString(message.yqlText))
                        return "yqlText: string expected";
                if (message.operationParams != null && message.hasOwnProperty("operationParams")) {
                    var error = $root.Ydb.Operations.OperationParams.verify(message.operationParams);
                    if (error)
                        return "operationParams." + error;
                }
                return null;
            };

            /**
             * Creates a PrepareDataQueryRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.PrepareDataQueryRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.PrepareDataQueryRequest} PrepareDataQueryRequest
             */
            PrepareDataQueryRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.PrepareDataQueryRequest)
                    return object;
                var message = new $root.Ydb.Table.PrepareDataQueryRequest();
                if (object.sessionId != null)
                    message.sessionId = String(object.sessionId);
                if (object.yqlText != null)
                    message.yqlText = String(object.yqlText);
                if (object.operationParams != null) {
                    if (typeof object.operationParams !== "object")
                        throw TypeError(".Ydb.Table.PrepareDataQueryRequest.operationParams: object expected");
                    message.operationParams = $root.Ydb.Operations.OperationParams.fromObject(object.operationParams);
                }
                return message;
            };

            /**
             * Creates a plain object from a PrepareDataQueryRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.PrepareDataQueryRequest
             * @static
             * @param {Ydb.Table.PrepareDataQueryRequest} message PrepareDataQueryRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PrepareDataQueryRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.sessionId = "";
                    object.yqlText = "";
                    object.operationParams = null;
                }
                if (message.sessionId != null && message.hasOwnProperty("sessionId"))
                    object.sessionId = message.sessionId;
                if (message.yqlText != null && message.hasOwnProperty("yqlText"))
                    object.yqlText = message.yqlText;
                if (message.operationParams != null && message.hasOwnProperty("operationParams"))
                    object.operationParams = $root.Ydb.Operations.OperationParams.toObject(message.operationParams, options);
                return object;
            };

            /**
             * Converts this PrepareDataQueryRequest to JSON.
             * @function toJSON
             * @memberof Ydb.Table.PrepareDataQueryRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PrepareDataQueryRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return PrepareDataQueryRequest;
        })();

        Table.PrepareDataQueryResponse = (function() {

            /**
             * Properties of a PrepareDataQueryResponse.
             * @memberof Ydb.Table
             * @interface IPrepareDataQueryResponse
             * @property {Ydb.Operations.IOperation|null} [operation] PrepareDataQueryResponse operation
             */

            /**
             * Constructs a new PrepareDataQueryResponse.
             * @memberof Ydb.Table
             * @classdesc Represents a PrepareDataQueryResponse.
             * @implements IPrepareDataQueryResponse
             * @constructor
             * @param {Ydb.Table.IPrepareDataQueryResponse=} [properties] Properties to set
             */
            function PrepareDataQueryResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PrepareDataQueryResponse operation.
             * @member {Ydb.Operations.IOperation|null|undefined} operation
             * @memberof Ydb.Table.PrepareDataQueryResponse
             * @instance
             */
            PrepareDataQueryResponse.prototype.operation = null;

            /**
             * Creates a new PrepareDataQueryResponse instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.PrepareDataQueryResponse
             * @static
             * @param {Ydb.Table.IPrepareDataQueryResponse=} [properties] Properties to set
             * @returns {Ydb.Table.PrepareDataQueryResponse} PrepareDataQueryResponse instance
             */
            PrepareDataQueryResponse.create = function create(properties) {
                return new PrepareDataQueryResponse(properties);
            };

            /**
             * Encodes the specified PrepareDataQueryResponse message. Does not implicitly {@link Ydb.Table.PrepareDataQueryResponse.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.PrepareDataQueryResponse
             * @static
             * @param {Ydb.Table.IPrepareDataQueryResponse} message PrepareDataQueryResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PrepareDataQueryResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.operation != null && Object.hasOwnProperty.call(message, "operation"))
                    $root.Ydb.Operations.Operation.encode(message.operation, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified PrepareDataQueryResponse message, length delimited. Does not implicitly {@link Ydb.Table.PrepareDataQueryResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.PrepareDataQueryResponse
             * @static
             * @param {Ydb.Table.IPrepareDataQueryResponse} message PrepareDataQueryResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PrepareDataQueryResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PrepareDataQueryResponse message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.PrepareDataQueryResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.PrepareDataQueryResponse} PrepareDataQueryResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PrepareDataQueryResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.PrepareDataQueryResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.operation = $root.Ydb.Operations.Operation.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a PrepareDataQueryResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.PrepareDataQueryResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.PrepareDataQueryResponse} PrepareDataQueryResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PrepareDataQueryResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PrepareDataQueryResponse message.
             * @function verify
             * @memberof Ydb.Table.PrepareDataQueryResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PrepareDataQueryResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.operation != null && message.hasOwnProperty("operation")) {
                    var error = $root.Ydb.Operations.Operation.verify(message.operation);
                    if (error)
                        return "operation." + error;
                }
                return null;
            };

            /**
             * Creates a PrepareDataQueryResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.PrepareDataQueryResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.PrepareDataQueryResponse} PrepareDataQueryResponse
             */
            PrepareDataQueryResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.PrepareDataQueryResponse)
                    return object;
                var message = new $root.Ydb.Table.PrepareDataQueryResponse();
                if (object.operation != null) {
                    if (typeof object.operation !== "object")
                        throw TypeError(".Ydb.Table.PrepareDataQueryResponse.operation: object expected");
                    message.operation = $root.Ydb.Operations.Operation.fromObject(object.operation);
                }
                return message;
            };

            /**
             * Creates a plain object from a PrepareDataQueryResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.PrepareDataQueryResponse
             * @static
             * @param {Ydb.Table.PrepareDataQueryResponse} message PrepareDataQueryResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PrepareDataQueryResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.operation = null;
                if (message.operation != null && message.hasOwnProperty("operation"))
                    object.operation = $root.Ydb.Operations.Operation.toObject(message.operation, options);
                return object;
            };

            /**
             * Converts this PrepareDataQueryResponse to JSON.
             * @function toJSON
             * @memberof Ydb.Table.PrepareDataQueryResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PrepareDataQueryResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return PrepareDataQueryResponse;
        })();

        Table.PrepareQueryResult = (function() {

            /**
             * Properties of a PrepareQueryResult.
             * @memberof Ydb.Table
             * @interface IPrepareQueryResult
             * @property {string|null} [queryId] PrepareQueryResult queryId
             * @property {Object.<string,Ydb.IType>|null} [parametersTypes] PrepareQueryResult parametersTypes
             */

            /**
             * Constructs a new PrepareQueryResult.
             * @memberof Ydb.Table
             * @classdesc Represents a PrepareQueryResult.
             * @implements IPrepareQueryResult
             * @constructor
             * @param {Ydb.Table.IPrepareQueryResult=} [properties] Properties to set
             */
            function PrepareQueryResult(properties) {
                this.parametersTypes = {};
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PrepareQueryResult queryId.
             * @member {string} queryId
             * @memberof Ydb.Table.PrepareQueryResult
             * @instance
             */
            PrepareQueryResult.prototype.queryId = "";

            /**
             * PrepareQueryResult parametersTypes.
             * @member {Object.<string,Ydb.IType>} parametersTypes
             * @memberof Ydb.Table.PrepareQueryResult
             * @instance
             */
            PrepareQueryResult.prototype.parametersTypes = $util.emptyObject;

            /**
             * Creates a new PrepareQueryResult instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.PrepareQueryResult
             * @static
             * @param {Ydb.Table.IPrepareQueryResult=} [properties] Properties to set
             * @returns {Ydb.Table.PrepareQueryResult} PrepareQueryResult instance
             */
            PrepareQueryResult.create = function create(properties) {
                return new PrepareQueryResult(properties);
            };

            /**
             * Encodes the specified PrepareQueryResult message. Does not implicitly {@link Ydb.Table.PrepareQueryResult.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.PrepareQueryResult
             * @static
             * @param {Ydb.Table.IPrepareQueryResult} message PrepareQueryResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PrepareQueryResult.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.queryId != null && Object.hasOwnProperty.call(message, "queryId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.queryId);
                if (message.parametersTypes != null && Object.hasOwnProperty.call(message, "parametersTypes"))
                    for (var keys = Object.keys(message.parametersTypes), i = 0; i < keys.length; ++i) {
                        writer.uint32(/* id 2, wireType 2 =*/18).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                        $root.Ydb.Type.encode(message.parametersTypes[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                    }
                return writer;
            };

            /**
             * Encodes the specified PrepareQueryResult message, length delimited. Does not implicitly {@link Ydb.Table.PrepareQueryResult.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.PrepareQueryResult
             * @static
             * @param {Ydb.Table.IPrepareQueryResult} message PrepareQueryResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PrepareQueryResult.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PrepareQueryResult message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.PrepareQueryResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.PrepareQueryResult} PrepareQueryResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PrepareQueryResult.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.PrepareQueryResult(), key, value;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.queryId = reader.string();
                        break;
                    case 2:
                        if (message.parametersTypes === $util.emptyObject)
                            message.parametersTypes = {};
                        var end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = null;
                        while (reader.pos < end2) {
                            var tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = $root.Ydb.Type.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.parametersTypes[key] = value;
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a PrepareQueryResult message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.PrepareQueryResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.PrepareQueryResult} PrepareQueryResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PrepareQueryResult.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PrepareQueryResult message.
             * @function verify
             * @memberof Ydb.Table.PrepareQueryResult
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PrepareQueryResult.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.queryId != null && message.hasOwnProperty("queryId"))
                    if (!$util.isString(message.queryId))
                        return "queryId: string expected";
                if (message.parametersTypes != null && message.hasOwnProperty("parametersTypes")) {
                    if (!$util.isObject(message.parametersTypes))
                        return "parametersTypes: object expected";
                    var key = Object.keys(message.parametersTypes);
                    for (var i = 0; i < key.length; ++i) {
                        var error = $root.Ydb.Type.verify(message.parametersTypes[key[i]]);
                        if (error)
                            return "parametersTypes." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a PrepareQueryResult message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.PrepareQueryResult
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.PrepareQueryResult} PrepareQueryResult
             */
            PrepareQueryResult.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.PrepareQueryResult)
                    return object;
                var message = new $root.Ydb.Table.PrepareQueryResult();
                if (object.queryId != null)
                    message.queryId = String(object.queryId);
                if (object.parametersTypes) {
                    if (typeof object.parametersTypes !== "object")
                        throw TypeError(".Ydb.Table.PrepareQueryResult.parametersTypes: object expected");
                    message.parametersTypes = {};
                    for (var keys = Object.keys(object.parametersTypes), i = 0; i < keys.length; ++i) {
                        if (typeof object.parametersTypes[keys[i]] !== "object")
                            throw TypeError(".Ydb.Table.PrepareQueryResult.parametersTypes: object expected");
                        message.parametersTypes[keys[i]] = $root.Ydb.Type.fromObject(object.parametersTypes[keys[i]]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a PrepareQueryResult message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.PrepareQueryResult
             * @static
             * @param {Ydb.Table.PrepareQueryResult} message PrepareQueryResult
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PrepareQueryResult.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.objects || options.defaults)
                    object.parametersTypes = {};
                if (options.defaults)
                    object.queryId = "";
                if (message.queryId != null && message.hasOwnProperty("queryId"))
                    object.queryId = message.queryId;
                var keys2;
                if (message.parametersTypes && (keys2 = Object.keys(message.parametersTypes)).length) {
                    object.parametersTypes = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.parametersTypes[keys2[j]] = $root.Ydb.Type.toObject(message.parametersTypes[keys2[j]], options);
                }
                return object;
            };

            /**
             * Converts this PrepareQueryResult to JSON.
             * @function toJSON
             * @memberof Ydb.Table.PrepareQueryResult
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PrepareQueryResult.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return PrepareQueryResult;
        })();

        Table.KeepAliveRequest = (function() {

            /**
             * Properties of a KeepAliveRequest.
             * @memberof Ydb.Table
             * @interface IKeepAliveRequest
             * @property {string|null} [sessionId] KeepAliveRequest sessionId
             * @property {Ydb.Operations.IOperationParams|null} [operationParams] KeepAliveRequest operationParams
             */

            /**
             * Constructs a new KeepAliveRequest.
             * @memberof Ydb.Table
             * @classdesc Represents a KeepAliveRequest.
             * @implements IKeepAliveRequest
             * @constructor
             * @param {Ydb.Table.IKeepAliveRequest=} [properties] Properties to set
             */
            function KeepAliveRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * KeepAliveRequest sessionId.
             * @member {string} sessionId
             * @memberof Ydb.Table.KeepAliveRequest
             * @instance
             */
            KeepAliveRequest.prototype.sessionId = "";

            /**
             * KeepAliveRequest operationParams.
             * @member {Ydb.Operations.IOperationParams|null|undefined} operationParams
             * @memberof Ydb.Table.KeepAliveRequest
             * @instance
             */
            KeepAliveRequest.prototype.operationParams = null;

            /**
             * Creates a new KeepAliveRequest instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.KeepAliveRequest
             * @static
             * @param {Ydb.Table.IKeepAliveRequest=} [properties] Properties to set
             * @returns {Ydb.Table.KeepAliveRequest} KeepAliveRequest instance
             */
            KeepAliveRequest.create = function create(properties) {
                return new KeepAliveRequest(properties);
            };

            /**
             * Encodes the specified KeepAliveRequest message. Does not implicitly {@link Ydb.Table.KeepAliveRequest.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.KeepAliveRequest
             * @static
             * @param {Ydb.Table.IKeepAliveRequest} message KeepAliveRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KeepAliveRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.sessionId != null && Object.hasOwnProperty.call(message, "sessionId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.sessionId);
                if (message.operationParams != null && Object.hasOwnProperty.call(message, "operationParams"))
                    $root.Ydb.Operations.OperationParams.encode(message.operationParams, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified KeepAliveRequest message, length delimited. Does not implicitly {@link Ydb.Table.KeepAliveRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.KeepAliveRequest
             * @static
             * @param {Ydb.Table.IKeepAliveRequest} message KeepAliveRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KeepAliveRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a KeepAliveRequest message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.KeepAliveRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.KeepAliveRequest} KeepAliveRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KeepAliveRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.KeepAliveRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.sessionId = reader.string();
                        break;
                    case 2:
                        message.operationParams = $root.Ydb.Operations.OperationParams.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a KeepAliveRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.KeepAliveRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.KeepAliveRequest} KeepAliveRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KeepAliveRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a KeepAliveRequest message.
             * @function verify
             * @memberof Ydb.Table.KeepAliveRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            KeepAliveRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.sessionId != null && message.hasOwnProperty("sessionId"))
                    if (!$util.isString(message.sessionId))
                        return "sessionId: string expected";
                if (message.operationParams != null && message.hasOwnProperty("operationParams")) {
                    var error = $root.Ydb.Operations.OperationParams.verify(message.operationParams);
                    if (error)
                        return "operationParams." + error;
                }
                return null;
            };

            /**
             * Creates a KeepAliveRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.KeepAliveRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.KeepAliveRequest} KeepAliveRequest
             */
            KeepAliveRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.KeepAliveRequest)
                    return object;
                var message = new $root.Ydb.Table.KeepAliveRequest();
                if (object.sessionId != null)
                    message.sessionId = String(object.sessionId);
                if (object.operationParams != null) {
                    if (typeof object.operationParams !== "object")
                        throw TypeError(".Ydb.Table.KeepAliveRequest.operationParams: object expected");
                    message.operationParams = $root.Ydb.Operations.OperationParams.fromObject(object.operationParams);
                }
                return message;
            };

            /**
             * Creates a plain object from a KeepAliveRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.KeepAliveRequest
             * @static
             * @param {Ydb.Table.KeepAliveRequest} message KeepAliveRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            KeepAliveRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.sessionId = "";
                    object.operationParams = null;
                }
                if (message.sessionId != null && message.hasOwnProperty("sessionId"))
                    object.sessionId = message.sessionId;
                if (message.operationParams != null && message.hasOwnProperty("operationParams"))
                    object.operationParams = $root.Ydb.Operations.OperationParams.toObject(message.operationParams, options);
                return object;
            };

            /**
             * Converts this KeepAliveRequest to JSON.
             * @function toJSON
             * @memberof Ydb.Table.KeepAliveRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            KeepAliveRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return KeepAliveRequest;
        })();

        Table.KeepAliveResponse = (function() {

            /**
             * Properties of a KeepAliveResponse.
             * @memberof Ydb.Table
             * @interface IKeepAliveResponse
             * @property {Ydb.Operations.IOperation|null} [operation] KeepAliveResponse operation
             */

            /**
             * Constructs a new KeepAliveResponse.
             * @memberof Ydb.Table
             * @classdesc Represents a KeepAliveResponse.
             * @implements IKeepAliveResponse
             * @constructor
             * @param {Ydb.Table.IKeepAliveResponse=} [properties] Properties to set
             */
            function KeepAliveResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * KeepAliveResponse operation.
             * @member {Ydb.Operations.IOperation|null|undefined} operation
             * @memberof Ydb.Table.KeepAliveResponse
             * @instance
             */
            KeepAliveResponse.prototype.operation = null;

            /**
             * Creates a new KeepAliveResponse instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.KeepAliveResponse
             * @static
             * @param {Ydb.Table.IKeepAliveResponse=} [properties] Properties to set
             * @returns {Ydb.Table.KeepAliveResponse} KeepAliveResponse instance
             */
            KeepAliveResponse.create = function create(properties) {
                return new KeepAliveResponse(properties);
            };

            /**
             * Encodes the specified KeepAliveResponse message. Does not implicitly {@link Ydb.Table.KeepAliveResponse.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.KeepAliveResponse
             * @static
             * @param {Ydb.Table.IKeepAliveResponse} message KeepAliveResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KeepAliveResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.operation != null && Object.hasOwnProperty.call(message, "operation"))
                    $root.Ydb.Operations.Operation.encode(message.operation, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified KeepAliveResponse message, length delimited. Does not implicitly {@link Ydb.Table.KeepAliveResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.KeepAliveResponse
             * @static
             * @param {Ydb.Table.IKeepAliveResponse} message KeepAliveResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KeepAliveResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a KeepAliveResponse message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.KeepAliveResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.KeepAliveResponse} KeepAliveResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KeepAliveResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.KeepAliveResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.operation = $root.Ydb.Operations.Operation.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a KeepAliveResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.KeepAliveResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.KeepAliveResponse} KeepAliveResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KeepAliveResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a KeepAliveResponse message.
             * @function verify
             * @memberof Ydb.Table.KeepAliveResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            KeepAliveResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.operation != null && message.hasOwnProperty("operation")) {
                    var error = $root.Ydb.Operations.Operation.verify(message.operation);
                    if (error)
                        return "operation." + error;
                }
                return null;
            };

            /**
             * Creates a KeepAliveResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.KeepAliveResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.KeepAliveResponse} KeepAliveResponse
             */
            KeepAliveResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.KeepAliveResponse)
                    return object;
                var message = new $root.Ydb.Table.KeepAliveResponse();
                if (object.operation != null) {
                    if (typeof object.operation !== "object")
                        throw TypeError(".Ydb.Table.KeepAliveResponse.operation: object expected");
                    message.operation = $root.Ydb.Operations.Operation.fromObject(object.operation);
                }
                return message;
            };

            /**
             * Creates a plain object from a KeepAliveResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.KeepAliveResponse
             * @static
             * @param {Ydb.Table.KeepAliveResponse} message KeepAliveResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            KeepAliveResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.operation = null;
                if (message.operation != null && message.hasOwnProperty("operation"))
                    object.operation = $root.Ydb.Operations.Operation.toObject(message.operation, options);
                return object;
            };

            /**
             * Converts this KeepAliveResponse to JSON.
             * @function toJSON
             * @memberof Ydb.Table.KeepAliveResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            KeepAliveResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return KeepAliveResponse;
        })();

        Table.KeepAliveResult = (function() {

            /**
             * Properties of a KeepAliveResult.
             * @memberof Ydb.Table
             * @interface IKeepAliveResult
             * @property {Ydb.Table.KeepAliveResult.SessionStatus|null} [sessionStatus] KeepAliveResult sessionStatus
             */

            /**
             * Constructs a new KeepAliveResult.
             * @memberof Ydb.Table
             * @classdesc Represents a KeepAliveResult.
             * @implements IKeepAliveResult
             * @constructor
             * @param {Ydb.Table.IKeepAliveResult=} [properties] Properties to set
             */
            function KeepAliveResult(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * KeepAliveResult sessionStatus.
             * @member {Ydb.Table.KeepAliveResult.SessionStatus} sessionStatus
             * @memberof Ydb.Table.KeepAliveResult
             * @instance
             */
            KeepAliveResult.prototype.sessionStatus = 0;

            /**
             * Creates a new KeepAliveResult instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.KeepAliveResult
             * @static
             * @param {Ydb.Table.IKeepAliveResult=} [properties] Properties to set
             * @returns {Ydb.Table.KeepAliveResult} KeepAliveResult instance
             */
            KeepAliveResult.create = function create(properties) {
                return new KeepAliveResult(properties);
            };

            /**
             * Encodes the specified KeepAliveResult message. Does not implicitly {@link Ydb.Table.KeepAliveResult.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.KeepAliveResult
             * @static
             * @param {Ydb.Table.IKeepAliveResult} message KeepAliveResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KeepAliveResult.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.sessionStatus != null && Object.hasOwnProperty.call(message, "sessionStatus"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.sessionStatus);
                return writer;
            };

            /**
             * Encodes the specified KeepAliveResult message, length delimited. Does not implicitly {@link Ydb.Table.KeepAliveResult.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.KeepAliveResult
             * @static
             * @param {Ydb.Table.IKeepAliveResult} message KeepAliveResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KeepAliveResult.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a KeepAliveResult message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.KeepAliveResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.KeepAliveResult} KeepAliveResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KeepAliveResult.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.KeepAliveResult();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.sessionStatus = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a KeepAliveResult message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.KeepAliveResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.KeepAliveResult} KeepAliveResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KeepAliveResult.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a KeepAliveResult message.
             * @function verify
             * @memberof Ydb.Table.KeepAliveResult
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            KeepAliveResult.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.sessionStatus != null && message.hasOwnProperty("sessionStatus"))
                    switch (message.sessionStatus) {
                    default:
                        return "sessionStatus: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                return null;
            };

            /**
             * Creates a KeepAliveResult message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.KeepAliveResult
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.KeepAliveResult} KeepAliveResult
             */
            KeepAliveResult.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.KeepAliveResult)
                    return object;
                var message = new $root.Ydb.Table.KeepAliveResult();
                switch (object.sessionStatus) {
                case "SESSION_STATUS_UNSPECIFIED":
                case 0:
                    message.sessionStatus = 0;
                    break;
                case "SESSION_STATUS_READY":
                case 1:
                    message.sessionStatus = 1;
                    break;
                case "SESSION_STATUS_BUSY":
                case 2:
                    message.sessionStatus = 2;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from a KeepAliveResult message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.KeepAliveResult
             * @static
             * @param {Ydb.Table.KeepAliveResult} message KeepAliveResult
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            KeepAliveResult.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.sessionStatus = options.enums === String ? "SESSION_STATUS_UNSPECIFIED" : 0;
                if (message.sessionStatus != null && message.hasOwnProperty("sessionStatus"))
                    object.sessionStatus = options.enums === String ? $root.Ydb.Table.KeepAliveResult.SessionStatus[message.sessionStatus] : message.sessionStatus;
                return object;
            };

            /**
             * Converts this KeepAliveResult to JSON.
             * @function toJSON
             * @memberof Ydb.Table.KeepAliveResult
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            KeepAliveResult.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * SessionStatus enum.
             * @name Ydb.Table.KeepAliveResult.SessionStatus
             * @enum {number}
             * @property {number} SESSION_STATUS_UNSPECIFIED=0 SESSION_STATUS_UNSPECIFIED value
             * @property {number} SESSION_STATUS_READY=1 SESSION_STATUS_READY value
             * @property {number} SESSION_STATUS_BUSY=2 SESSION_STATUS_BUSY value
             */
            KeepAliveResult.SessionStatus = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "SESSION_STATUS_UNSPECIFIED"] = 0;
                values[valuesById[1] = "SESSION_STATUS_READY"] = 1;
                values[valuesById[2] = "SESSION_STATUS_BUSY"] = 2;
                return values;
            })();

            return KeepAliveResult;
        })();

        Table.BeginTransactionRequest = (function() {

            /**
             * Properties of a BeginTransactionRequest.
             * @memberof Ydb.Table
             * @interface IBeginTransactionRequest
             * @property {string|null} [sessionId] BeginTransactionRequest sessionId
             * @property {Ydb.Table.ITransactionSettings|null} [txSettings] BeginTransactionRequest txSettings
             * @property {Ydb.Operations.IOperationParams|null} [operationParams] BeginTransactionRequest operationParams
             */

            /**
             * Constructs a new BeginTransactionRequest.
             * @memberof Ydb.Table
             * @classdesc Represents a BeginTransactionRequest.
             * @implements IBeginTransactionRequest
             * @constructor
             * @param {Ydb.Table.IBeginTransactionRequest=} [properties] Properties to set
             */
            function BeginTransactionRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * BeginTransactionRequest sessionId.
             * @member {string} sessionId
             * @memberof Ydb.Table.BeginTransactionRequest
             * @instance
             */
            BeginTransactionRequest.prototype.sessionId = "";

            /**
             * BeginTransactionRequest txSettings.
             * @member {Ydb.Table.ITransactionSettings|null|undefined} txSettings
             * @memberof Ydb.Table.BeginTransactionRequest
             * @instance
             */
            BeginTransactionRequest.prototype.txSettings = null;

            /**
             * BeginTransactionRequest operationParams.
             * @member {Ydb.Operations.IOperationParams|null|undefined} operationParams
             * @memberof Ydb.Table.BeginTransactionRequest
             * @instance
             */
            BeginTransactionRequest.prototype.operationParams = null;

            /**
             * Creates a new BeginTransactionRequest instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.BeginTransactionRequest
             * @static
             * @param {Ydb.Table.IBeginTransactionRequest=} [properties] Properties to set
             * @returns {Ydb.Table.BeginTransactionRequest} BeginTransactionRequest instance
             */
            BeginTransactionRequest.create = function create(properties) {
                return new BeginTransactionRequest(properties);
            };

            /**
             * Encodes the specified BeginTransactionRequest message. Does not implicitly {@link Ydb.Table.BeginTransactionRequest.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.BeginTransactionRequest
             * @static
             * @param {Ydb.Table.IBeginTransactionRequest} message BeginTransactionRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BeginTransactionRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.sessionId != null && Object.hasOwnProperty.call(message, "sessionId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.sessionId);
                if (message.txSettings != null && Object.hasOwnProperty.call(message, "txSettings"))
                    $root.Ydb.Table.TransactionSettings.encode(message.txSettings, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.operationParams != null && Object.hasOwnProperty.call(message, "operationParams"))
                    $root.Ydb.Operations.OperationParams.encode(message.operationParams, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified BeginTransactionRequest message, length delimited. Does not implicitly {@link Ydb.Table.BeginTransactionRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.BeginTransactionRequest
             * @static
             * @param {Ydb.Table.IBeginTransactionRequest} message BeginTransactionRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BeginTransactionRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BeginTransactionRequest message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.BeginTransactionRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.BeginTransactionRequest} BeginTransactionRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BeginTransactionRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.BeginTransactionRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.sessionId = reader.string();
                        break;
                    case 2:
                        message.txSettings = $root.Ydb.Table.TransactionSettings.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.operationParams = $root.Ydb.Operations.OperationParams.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a BeginTransactionRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.BeginTransactionRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.BeginTransactionRequest} BeginTransactionRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BeginTransactionRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BeginTransactionRequest message.
             * @function verify
             * @memberof Ydb.Table.BeginTransactionRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BeginTransactionRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.sessionId != null && message.hasOwnProperty("sessionId"))
                    if (!$util.isString(message.sessionId))
                        return "sessionId: string expected";
                if (message.txSettings != null && message.hasOwnProperty("txSettings")) {
                    var error = $root.Ydb.Table.TransactionSettings.verify(message.txSettings);
                    if (error)
                        return "txSettings." + error;
                }
                if (message.operationParams != null && message.hasOwnProperty("operationParams")) {
                    var error = $root.Ydb.Operations.OperationParams.verify(message.operationParams);
                    if (error)
                        return "operationParams." + error;
                }
                return null;
            };

            /**
             * Creates a BeginTransactionRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.BeginTransactionRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.BeginTransactionRequest} BeginTransactionRequest
             */
            BeginTransactionRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.BeginTransactionRequest)
                    return object;
                var message = new $root.Ydb.Table.BeginTransactionRequest();
                if (object.sessionId != null)
                    message.sessionId = String(object.sessionId);
                if (object.txSettings != null) {
                    if (typeof object.txSettings !== "object")
                        throw TypeError(".Ydb.Table.BeginTransactionRequest.txSettings: object expected");
                    message.txSettings = $root.Ydb.Table.TransactionSettings.fromObject(object.txSettings);
                }
                if (object.operationParams != null) {
                    if (typeof object.operationParams !== "object")
                        throw TypeError(".Ydb.Table.BeginTransactionRequest.operationParams: object expected");
                    message.operationParams = $root.Ydb.Operations.OperationParams.fromObject(object.operationParams);
                }
                return message;
            };

            /**
             * Creates a plain object from a BeginTransactionRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.BeginTransactionRequest
             * @static
             * @param {Ydb.Table.BeginTransactionRequest} message BeginTransactionRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BeginTransactionRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.sessionId = "";
                    object.txSettings = null;
                    object.operationParams = null;
                }
                if (message.sessionId != null && message.hasOwnProperty("sessionId"))
                    object.sessionId = message.sessionId;
                if (message.txSettings != null && message.hasOwnProperty("txSettings"))
                    object.txSettings = $root.Ydb.Table.TransactionSettings.toObject(message.txSettings, options);
                if (message.operationParams != null && message.hasOwnProperty("operationParams"))
                    object.operationParams = $root.Ydb.Operations.OperationParams.toObject(message.operationParams, options);
                return object;
            };

            /**
             * Converts this BeginTransactionRequest to JSON.
             * @function toJSON
             * @memberof Ydb.Table.BeginTransactionRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BeginTransactionRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return BeginTransactionRequest;
        })();

        Table.BeginTransactionResponse = (function() {

            /**
             * Properties of a BeginTransactionResponse.
             * @memberof Ydb.Table
             * @interface IBeginTransactionResponse
             * @property {Ydb.Operations.IOperation|null} [operation] BeginTransactionResponse operation
             */

            /**
             * Constructs a new BeginTransactionResponse.
             * @memberof Ydb.Table
             * @classdesc Represents a BeginTransactionResponse.
             * @implements IBeginTransactionResponse
             * @constructor
             * @param {Ydb.Table.IBeginTransactionResponse=} [properties] Properties to set
             */
            function BeginTransactionResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * BeginTransactionResponse operation.
             * @member {Ydb.Operations.IOperation|null|undefined} operation
             * @memberof Ydb.Table.BeginTransactionResponse
             * @instance
             */
            BeginTransactionResponse.prototype.operation = null;

            /**
             * Creates a new BeginTransactionResponse instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.BeginTransactionResponse
             * @static
             * @param {Ydb.Table.IBeginTransactionResponse=} [properties] Properties to set
             * @returns {Ydb.Table.BeginTransactionResponse} BeginTransactionResponse instance
             */
            BeginTransactionResponse.create = function create(properties) {
                return new BeginTransactionResponse(properties);
            };

            /**
             * Encodes the specified BeginTransactionResponse message. Does not implicitly {@link Ydb.Table.BeginTransactionResponse.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.BeginTransactionResponse
             * @static
             * @param {Ydb.Table.IBeginTransactionResponse} message BeginTransactionResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BeginTransactionResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.operation != null && Object.hasOwnProperty.call(message, "operation"))
                    $root.Ydb.Operations.Operation.encode(message.operation, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified BeginTransactionResponse message, length delimited. Does not implicitly {@link Ydb.Table.BeginTransactionResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.BeginTransactionResponse
             * @static
             * @param {Ydb.Table.IBeginTransactionResponse} message BeginTransactionResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BeginTransactionResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BeginTransactionResponse message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.BeginTransactionResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.BeginTransactionResponse} BeginTransactionResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BeginTransactionResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.BeginTransactionResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.operation = $root.Ydb.Operations.Operation.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a BeginTransactionResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.BeginTransactionResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.BeginTransactionResponse} BeginTransactionResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BeginTransactionResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BeginTransactionResponse message.
             * @function verify
             * @memberof Ydb.Table.BeginTransactionResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BeginTransactionResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.operation != null && message.hasOwnProperty("operation")) {
                    var error = $root.Ydb.Operations.Operation.verify(message.operation);
                    if (error)
                        return "operation." + error;
                }
                return null;
            };

            /**
             * Creates a BeginTransactionResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.BeginTransactionResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.BeginTransactionResponse} BeginTransactionResponse
             */
            BeginTransactionResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.BeginTransactionResponse)
                    return object;
                var message = new $root.Ydb.Table.BeginTransactionResponse();
                if (object.operation != null) {
                    if (typeof object.operation !== "object")
                        throw TypeError(".Ydb.Table.BeginTransactionResponse.operation: object expected");
                    message.operation = $root.Ydb.Operations.Operation.fromObject(object.operation);
                }
                return message;
            };

            /**
             * Creates a plain object from a BeginTransactionResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.BeginTransactionResponse
             * @static
             * @param {Ydb.Table.BeginTransactionResponse} message BeginTransactionResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BeginTransactionResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.operation = null;
                if (message.operation != null && message.hasOwnProperty("operation"))
                    object.operation = $root.Ydb.Operations.Operation.toObject(message.operation, options);
                return object;
            };

            /**
             * Converts this BeginTransactionResponse to JSON.
             * @function toJSON
             * @memberof Ydb.Table.BeginTransactionResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BeginTransactionResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return BeginTransactionResponse;
        })();

        Table.BeginTransactionResult = (function() {

            /**
             * Properties of a BeginTransactionResult.
             * @memberof Ydb.Table
             * @interface IBeginTransactionResult
             * @property {Ydb.Table.ITransactionMeta|null} [txMeta] BeginTransactionResult txMeta
             */

            /**
             * Constructs a new BeginTransactionResult.
             * @memberof Ydb.Table
             * @classdesc Represents a BeginTransactionResult.
             * @implements IBeginTransactionResult
             * @constructor
             * @param {Ydb.Table.IBeginTransactionResult=} [properties] Properties to set
             */
            function BeginTransactionResult(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * BeginTransactionResult txMeta.
             * @member {Ydb.Table.ITransactionMeta|null|undefined} txMeta
             * @memberof Ydb.Table.BeginTransactionResult
             * @instance
             */
            BeginTransactionResult.prototype.txMeta = null;

            /**
             * Creates a new BeginTransactionResult instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.BeginTransactionResult
             * @static
             * @param {Ydb.Table.IBeginTransactionResult=} [properties] Properties to set
             * @returns {Ydb.Table.BeginTransactionResult} BeginTransactionResult instance
             */
            BeginTransactionResult.create = function create(properties) {
                return new BeginTransactionResult(properties);
            };

            /**
             * Encodes the specified BeginTransactionResult message. Does not implicitly {@link Ydb.Table.BeginTransactionResult.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.BeginTransactionResult
             * @static
             * @param {Ydb.Table.IBeginTransactionResult} message BeginTransactionResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BeginTransactionResult.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.txMeta != null && Object.hasOwnProperty.call(message, "txMeta"))
                    $root.Ydb.Table.TransactionMeta.encode(message.txMeta, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified BeginTransactionResult message, length delimited. Does not implicitly {@link Ydb.Table.BeginTransactionResult.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.BeginTransactionResult
             * @static
             * @param {Ydb.Table.IBeginTransactionResult} message BeginTransactionResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BeginTransactionResult.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BeginTransactionResult message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.BeginTransactionResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.BeginTransactionResult} BeginTransactionResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BeginTransactionResult.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.BeginTransactionResult();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.txMeta = $root.Ydb.Table.TransactionMeta.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a BeginTransactionResult message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.BeginTransactionResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.BeginTransactionResult} BeginTransactionResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BeginTransactionResult.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BeginTransactionResult message.
             * @function verify
             * @memberof Ydb.Table.BeginTransactionResult
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BeginTransactionResult.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.txMeta != null && message.hasOwnProperty("txMeta")) {
                    var error = $root.Ydb.Table.TransactionMeta.verify(message.txMeta);
                    if (error)
                        return "txMeta." + error;
                }
                return null;
            };

            /**
             * Creates a BeginTransactionResult message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.BeginTransactionResult
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.BeginTransactionResult} BeginTransactionResult
             */
            BeginTransactionResult.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.BeginTransactionResult)
                    return object;
                var message = new $root.Ydb.Table.BeginTransactionResult();
                if (object.txMeta != null) {
                    if (typeof object.txMeta !== "object")
                        throw TypeError(".Ydb.Table.BeginTransactionResult.txMeta: object expected");
                    message.txMeta = $root.Ydb.Table.TransactionMeta.fromObject(object.txMeta);
                }
                return message;
            };

            /**
             * Creates a plain object from a BeginTransactionResult message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.BeginTransactionResult
             * @static
             * @param {Ydb.Table.BeginTransactionResult} message BeginTransactionResult
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BeginTransactionResult.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.txMeta = null;
                if (message.txMeta != null && message.hasOwnProperty("txMeta"))
                    object.txMeta = $root.Ydb.Table.TransactionMeta.toObject(message.txMeta, options);
                return object;
            };

            /**
             * Converts this BeginTransactionResult to JSON.
             * @function toJSON
             * @memberof Ydb.Table.BeginTransactionResult
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BeginTransactionResult.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return BeginTransactionResult;
        })();

        Table.CommitTransactionRequest = (function() {

            /**
             * Properties of a CommitTransactionRequest.
             * @memberof Ydb.Table
             * @interface ICommitTransactionRequest
             * @property {string|null} [sessionId] CommitTransactionRequest sessionId
             * @property {string|null} [txId] CommitTransactionRequest txId
             * @property {Ydb.Operations.IOperationParams|null} [operationParams] CommitTransactionRequest operationParams
             * @property {Ydb.Table.QueryStatsCollection.Mode|null} [collectStats] CommitTransactionRequest collectStats
             */

            /**
             * Constructs a new CommitTransactionRequest.
             * @memberof Ydb.Table
             * @classdesc Represents a CommitTransactionRequest.
             * @implements ICommitTransactionRequest
             * @constructor
             * @param {Ydb.Table.ICommitTransactionRequest=} [properties] Properties to set
             */
            function CommitTransactionRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CommitTransactionRequest sessionId.
             * @member {string} sessionId
             * @memberof Ydb.Table.CommitTransactionRequest
             * @instance
             */
            CommitTransactionRequest.prototype.sessionId = "";

            /**
             * CommitTransactionRequest txId.
             * @member {string} txId
             * @memberof Ydb.Table.CommitTransactionRequest
             * @instance
             */
            CommitTransactionRequest.prototype.txId = "";

            /**
             * CommitTransactionRequest operationParams.
             * @member {Ydb.Operations.IOperationParams|null|undefined} operationParams
             * @memberof Ydb.Table.CommitTransactionRequest
             * @instance
             */
            CommitTransactionRequest.prototype.operationParams = null;

            /**
             * CommitTransactionRequest collectStats.
             * @member {Ydb.Table.QueryStatsCollection.Mode} collectStats
             * @memberof Ydb.Table.CommitTransactionRequest
             * @instance
             */
            CommitTransactionRequest.prototype.collectStats = 0;

            /**
             * Creates a new CommitTransactionRequest instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.CommitTransactionRequest
             * @static
             * @param {Ydb.Table.ICommitTransactionRequest=} [properties] Properties to set
             * @returns {Ydb.Table.CommitTransactionRequest} CommitTransactionRequest instance
             */
            CommitTransactionRequest.create = function create(properties) {
                return new CommitTransactionRequest(properties);
            };

            /**
             * Encodes the specified CommitTransactionRequest message. Does not implicitly {@link Ydb.Table.CommitTransactionRequest.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.CommitTransactionRequest
             * @static
             * @param {Ydb.Table.ICommitTransactionRequest} message CommitTransactionRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CommitTransactionRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.sessionId != null && Object.hasOwnProperty.call(message, "sessionId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.sessionId);
                if (message.txId != null && Object.hasOwnProperty.call(message, "txId"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.txId);
                if (message.operationParams != null && Object.hasOwnProperty.call(message, "operationParams"))
                    $root.Ydb.Operations.OperationParams.encode(message.operationParams, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.collectStats != null && Object.hasOwnProperty.call(message, "collectStats"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.collectStats);
                return writer;
            };

            /**
             * Encodes the specified CommitTransactionRequest message, length delimited. Does not implicitly {@link Ydb.Table.CommitTransactionRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.CommitTransactionRequest
             * @static
             * @param {Ydb.Table.ICommitTransactionRequest} message CommitTransactionRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CommitTransactionRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CommitTransactionRequest message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.CommitTransactionRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.CommitTransactionRequest} CommitTransactionRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CommitTransactionRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.CommitTransactionRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.sessionId = reader.string();
                        break;
                    case 2:
                        message.txId = reader.string();
                        break;
                    case 3:
                        message.operationParams = $root.Ydb.Operations.OperationParams.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.collectStats = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a CommitTransactionRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.CommitTransactionRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.CommitTransactionRequest} CommitTransactionRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CommitTransactionRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CommitTransactionRequest message.
             * @function verify
             * @memberof Ydb.Table.CommitTransactionRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CommitTransactionRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.sessionId != null && message.hasOwnProperty("sessionId"))
                    if (!$util.isString(message.sessionId))
                        return "sessionId: string expected";
                if (message.txId != null && message.hasOwnProperty("txId"))
                    if (!$util.isString(message.txId))
                        return "txId: string expected";
                if (message.operationParams != null && message.hasOwnProperty("operationParams")) {
                    var error = $root.Ydb.Operations.OperationParams.verify(message.operationParams);
                    if (error)
                        return "operationParams." + error;
                }
                if (message.collectStats != null && message.hasOwnProperty("collectStats"))
                    switch (message.collectStats) {
                    default:
                        return "collectStats: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                        break;
                    }
                return null;
            };

            /**
             * Creates a CommitTransactionRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.CommitTransactionRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.CommitTransactionRequest} CommitTransactionRequest
             */
            CommitTransactionRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.CommitTransactionRequest)
                    return object;
                var message = new $root.Ydb.Table.CommitTransactionRequest();
                if (object.sessionId != null)
                    message.sessionId = String(object.sessionId);
                if (object.txId != null)
                    message.txId = String(object.txId);
                if (object.operationParams != null) {
                    if (typeof object.operationParams !== "object")
                        throw TypeError(".Ydb.Table.CommitTransactionRequest.operationParams: object expected");
                    message.operationParams = $root.Ydb.Operations.OperationParams.fromObject(object.operationParams);
                }
                switch (object.collectStats) {
                case "STATS_COLLECTION_UNSPECIFIED":
                case 0:
                    message.collectStats = 0;
                    break;
                case "STATS_COLLECTION_NONE":
                case 1:
                    message.collectStats = 1;
                    break;
                case "STATS_COLLECTION_BASIC":
                case 2:
                    message.collectStats = 2;
                    break;
                case "STATS_COLLECTION_FULL":
                case 3:
                    message.collectStats = 3;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from a CommitTransactionRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.CommitTransactionRequest
             * @static
             * @param {Ydb.Table.CommitTransactionRequest} message CommitTransactionRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CommitTransactionRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.sessionId = "";
                    object.txId = "";
                    object.operationParams = null;
                    object.collectStats = options.enums === String ? "STATS_COLLECTION_UNSPECIFIED" : 0;
                }
                if (message.sessionId != null && message.hasOwnProperty("sessionId"))
                    object.sessionId = message.sessionId;
                if (message.txId != null && message.hasOwnProperty("txId"))
                    object.txId = message.txId;
                if (message.operationParams != null && message.hasOwnProperty("operationParams"))
                    object.operationParams = $root.Ydb.Operations.OperationParams.toObject(message.operationParams, options);
                if (message.collectStats != null && message.hasOwnProperty("collectStats"))
                    object.collectStats = options.enums === String ? $root.Ydb.Table.QueryStatsCollection.Mode[message.collectStats] : message.collectStats;
                return object;
            };

            /**
             * Converts this CommitTransactionRequest to JSON.
             * @function toJSON
             * @memberof Ydb.Table.CommitTransactionRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CommitTransactionRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return CommitTransactionRequest;
        })();

        Table.CommitTransactionResponse = (function() {

            /**
             * Properties of a CommitTransactionResponse.
             * @memberof Ydb.Table
             * @interface ICommitTransactionResponse
             * @property {Ydb.Operations.IOperation|null} [operation] CommitTransactionResponse operation
             */

            /**
             * Constructs a new CommitTransactionResponse.
             * @memberof Ydb.Table
             * @classdesc Represents a CommitTransactionResponse.
             * @implements ICommitTransactionResponse
             * @constructor
             * @param {Ydb.Table.ICommitTransactionResponse=} [properties] Properties to set
             */
            function CommitTransactionResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CommitTransactionResponse operation.
             * @member {Ydb.Operations.IOperation|null|undefined} operation
             * @memberof Ydb.Table.CommitTransactionResponse
             * @instance
             */
            CommitTransactionResponse.prototype.operation = null;

            /**
             * Creates a new CommitTransactionResponse instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.CommitTransactionResponse
             * @static
             * @param {Ydb.Table.ICommitTransactionResponse=} [properties] Properties to set
             * @returns {Ydb.Table.CommitTransactionResponse} CommitTransactionResponse instance
             */
            CommitTransactionResponse.create = function create(properties) {
                return new CommitTransactionResponse(properties);
            };

            /**
             * Encodes the specified CommitTransactionResponse message. Does not implicitly {@link Ydb.Table.CommitTransactionResponse.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.CommitTransactionResponse
             * @static
             * @param {Ydb.Table.ICommitTransactionResponse} message CommitTransactionResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CommitTransactionResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.operation != null && Object.hasOwnProperty.call(message, "operation"))
                    $root.Ydb.Operations.Operation.encode(message.operation, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified CommitTransactionResponse message, length delimited. Does not implicitly {@link Ydb.Table.CommitTransactionResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.CommitTransactionResponse
             * @static
             * @param {Ydb.Table.ICommitTransactionResponse} message CommitTransactionResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CommitTransactionResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CommitTransactionResponse message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.CommitTransactionResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.CommitTransactionResponse} CommitTransactionResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CommitTransactionResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.CommitTransactionResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.operation = $root.Ydb.Operations.Operation.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a CommitTransactionResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.CommitTransactionResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.CommitTransactionResponse} CommitTransactionResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CommitTransactionResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CommitTransactionResponse message.
             * @function verify
             * @memberof Ydb.Table.CommitTransactionResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CommitTransactionResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.operation != null && message.hasOwnProperty("operation")) {
                    var error = $root.Ydb.Operations.Operation.verify(message.operation);
                    if (error)
                        return "operation." + error;
                }
                return null;
            };

            /**
             * Creates a CommitTransactionResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.CommitTransactionResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.CommitTransactionResponse} CommitTransactionResponse
             */
            CommitTransactionResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.CommitTransactionResponse)
                    return object;
                var message = new $root.Ydb.Table.CommitTransactionResponse();
                if (object.operation != null) {
                    if (typeof object.operation !== "object")
                        throw TypeError(".Ydb.Table.CommitTransactionResponse.operation: object expected");
                    message.operation = $root.Ydb.Operations.Operation.fromObject(object.operation);
                }
                return message;
            };

            /**
             * Creates a plain object from a CommitTransactionResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.CommitTransactionResponse
             * @static
             * @param {Ydb.Table.CommitTransactionResponse} message CommitTransactionResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CommitTransactionResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.operation = null;
                if (message.operation != null && message.hasOwnProperty("operation"))
                    object.operation = $root.Ydb.Operations.Operation.toObject(message.operation, options);
                return object;
            };

            /**
             * Converts this CommitTransactionResponse to JSON.
             * @function toJSON
             * @memberof Ydb.Table.CommitTransactionResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CommitTransactionResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return CommitTransactionResponse;
        })();

        Table.CommitTransactionResult = (function() {

            /**
             * Properties of a CommitTransactionResult.
             * @memberof Ydb.Table
             * @interface ICommitTransactionResult
             * @property {Ydb.TableStats.IQueryStats|null} [queryStats] CommitTransactionResult queryStats
             */

            /**
             * Constructs a new CommitTransactionResult.
             * @memberof Ydb.Table
             * @classdesc Represents a CommitTransactionResult.
             * @implements ICommitTransactionResult
             * @constructor
             * @param {Ydb.Table.ICommitTransactionResult=} [properties] Properties to set
             */
            function CommitTransactionResult(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CommitTransactionResult queryStats.
             * @member {Ydb.TableStats.IQueryStats|null|undefined} queryStats
             * @memberof Ydb.Table.CommitTransactionResult
             * @instance
             */
            CommitTransactionResult.prototype.queryStats = null;

            /**
             * Creates a new CommitTransactionResult instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.CommitTransactionResult
             * @static
             * @param {Ydb.Table.ICommitTransactionResult=} [properties] Properties to set
             * @returns {Ydb.Table.CommitTransactionResult} CommitTransactionResult instance
             */
            CommitTransactionResult.create = function create(properties) {
                return new CommitTransactionResult(properties);
            };

            /**
             * Encodes the specified CommitTransactionResult message. Does not implicitly {@link Ydb.Table.CommitTransactionResult.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.CommitTransactionResult
             * @static
             * @param {Ydb.Table.ICommitTransactionResult} message CommitTransactionResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CommitTransactionResult.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.queryStats != null && Object.hasOwnProperty.call(message, "queryStats"))
                    $root.Ydb.TableStats.QueryStats.encode(message.queryStats, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified CommitTransactionResult message, length delimited. Does not implicitly {@link Ydb.Table.CommitTransactionResult.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.CommitTransactionResult
             * @static
             * @param {Ydb.Table.ICommitTransactionResult} message CommitTransactionResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CommitTransactionResult.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CommitTransactionResult message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.CommitTransactionResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.CommitTransactionResult} CommitTransactionResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CommitTransactionResult.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.CommitTransactionResult();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.queryStats = $root.Ydb.TableStats.QueryStats.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a CommitTransactionResult message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.CommitTransactionResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.CommitTransactionResult} CommitTransactionResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CommitTransactionResult.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CommitTransactionResult message.
             * @function verify
             * @memberof Ydb.Table.CommitTransactionResult
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CommitTransactionResult.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.queryStats != null && message.hasOwnProperty("queryStats")) {
                    var error = $root.Ydb.TableStats.QueryStats.verify(message.queryStats);
                    if (error)
                        return "queryStats." + error;
                }
                return null;
            };

            /**
             * Creates a CommitTransactionResult message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.CommitTransactionResult
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.CommitTransactionResult} CommitTransactionResult
             */
            CommitTransactionResult.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.CommitTransactionResult)
                    return object;
                var message = new $root.Ydb.Table.CommitTransactionResult();
                if (object.queryStats != null) {
                    if (typeof object.queryStats !== "object")
                        throw TypeError(".Ydb.Table.CommitTransactionResult.queryStats: object expected");
                    message.queryStats = $root.Ydb.TableStats.QueryStats.fromObject(object.queryStats);
                }
                return message;
            };

            /**
             * Creates a plain object from a CommitTransactionResult message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.CommitTransactionResult
             * @static
             * @param {Ydb.Table.CommitTransactionResult} message CommitTransactionResult
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CommitTransactionResult.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.queryStats = null;
                if (message.queryStats != null && message.hasOwnProperty("queryStats"))
                    object.queryStats = $root.Ydb.TableStats.QueryStats.toObject(message.queryStats, options);
                return object;
            };

            /**
             * Converts this CommitTransactionResult to JSON.
             * @function toJSON
             * @memberof Ydb.Table.CommitTransactionResult
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CommitTransactionResult.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return CommitTransactionResult;
        })();

        Table.RollbackTransactionRequest = (function() {

            /**
             * Properties of a RollbackTransactionRequest.
             * @memberof Ydb.Table
             * @interface IRollbackTransactionRequest
             * @property {string|null} [sessionId] RollbackTransactionRequest sessionId
             * @property {string|null} [txId] RollbackTransactionRequest txId
             * @property {Ydb.Operations.IOperationParams|null} [operationParams] RollbackTransactionRequest operationParams
             */

            /**
             * Constructs a new RollbackTransactionRequest.
             * @memberof Ydb.Table
             * @classdesc Represents a RollbackTransactionRequest.
             * @implements IRollbackTransactionRequest
             * @constructor
             * @param {Ydb.Table.IRollbackTransactionRequest=} [properties] Properties to set
             */
            function RollbackTransactionRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RollbackTransactionRequest sessionId.
             * @member {string} sessionId
             * @memberof Ydb.Table.RollbackTransactionRequest
             * @instance
             */
            RollbackTransactionRequest.prototype.sessionId = "";

            /**
             * RollbackTransactionRequest txId.
             * @member {string} txId
             * @memberof Ydb.Table.RollbackTransactionRequest
             * @instance
             */
            RollbackTransactionRequest.prototype.txId = "";

            /**
             * RollbackTransactionRequest operationParams.
             * @member {Ydb.Operations.IOperationParams|null|undefined} operationParams
             * @memberof Ydb.Table.RollbackTransactionRequest
             * @instance
             */
            RollbackTransactionRequest.prototype.operationParams = null;

            /**
             * Creates a new RollbackTransactionRequest instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.RollbackTransactionRequest
             * @static
             * @param {Ydb.Table.IRollbackTransactionRequest=} [properties] Properties to set
             * @returns {Ydb.Table.RollbackTransactionRequest} RollbackTransactionRequest instance
             */
            RollbackTransactionRequest.create = function create(properties) {
                return new RollbackTransactionRequest(properties);
            };

            /**
             * Encodes the specified RollbackTransactionRequest message. Does not implicitly {@link Ydb.Table.RollbackTransactionRequest.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.RollbackTransactionRequest
             * @static
             * @param {Ydb.Table.IRollbackTransactionRequest} message RollbackTransactionRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RollbackTransactionRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.sessionId != null && Object.hasOwnProperty.call(message, "sessionId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.sessionId);
                if (message.txId != null && Object.hasOwnProperty.call(message, "txId"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.txId);
                if (message.operationParams != null && Object.hasOwnProperty.call(message, "operationParams"))
                    $root.Ydb.Operations.OperationParams.encode(message.operationParams, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified RollbackTransactionRequest message, length delimited. Does not implicitly {@link Ydb.Table.RollbackTransactionRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.RollbackTransactionRequest
             * @static
             * @param {Ydb.Table.IRollbackTransactionRequest} message RollbackTransactionRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RollbackTransactionRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RollbackTransactionRequest message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.RollbackTransactionRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.RollbackTransactionRequest} RollbackTransactionRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RollbackTransactionRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.RollbackTransactionRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.sessionId = reader.string();
                        break;
                    case 2:
                        message.txId = reader.string();
                        break;
                    case 3:
                        message.operationParams = $root.Ydb.Operations.OperationParams.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RollbackTransactionRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.RollbackTransactionRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.RollbackTransactionRequest} RollbackTransactionRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RollbackTransactionRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RollbackTransactionRequest message.
             * @function verify
             * @memberof Ydb.Table.RollbackTransactionRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RollbackTransactionRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.sessionId != null && message.hasOwnProperty("sessionId"))
                    if (!$util.isString(message.sessionId))
                        return "sessionId: string expected";
                if (message.txId != null && message.hasOwnProperty("txId"))
                    if (!$util.isString(message.txId))
                        return "txId: string expected";
                if (message.operationParams != null && message.hasOwnProperty("operationParams")) {
                    var error = $root.Ydb.Operations.OperationParams.verify(message.operationParams);
                    if (error)
                        return "operationParams." + error;
                }
                return null;
            };

            /**
             * Creates a RollbackTransactionRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.RollbackTransactionRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.RollbackTransactionRequest} RollbackTransactionRequest
             */
            RollbackTransactionRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.RollbackTransactionRequest)
                    return object;
                var message = new $root.Ydb.Table.RollbackTransactionRequest();
                if (object.sessionId != null)
                    message.sessionId = String(object.sessionId);
                if (object.txId != null)
                    message.txId = String(object.txId);
                if (object.operationParams != null) {
                    if (typeof object.operationParams !== "object")
                        throw TypeError(".Ydb.Table.RollbackTransactionRequest.operationParams: object expected");
                    message.operationParams = $root.Ydb.Operations.OperationParams.fromObject(object.operationParams);
                }
                return message;
            };

            /**
             * Creates a plain object from a RollbackTransactionRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.RollbackTransactionRequest
             * @static
             * @param {Ydb.Table.RollbackTransactionRequest} message RollbackTransactionRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RollbackTransactionRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.sessionId = "";
                    object.txId = "";
                    object.operationParams = null;
                }
                if (message.sessionId != null && message.hasOwnProperty("sessionId"))
                    object.sessionId = message.sessionId;
                if (message.txId != null && message.hasOwnProperty("txId"))
                    object.txId = message.txId;
                if (message.operationParams != null && message.hasOwnProperty("operationParams"))
                    object.operationParams = $root.Ydb.Operations.OperationParams.toObject(message.operationParams, options);
                return object;
            };

            /**
             * Converts this RollbackTransactionRequest to JSON.
             * @function toJSON
             * @memberof Ydb.Table.RollbackTransactionRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RollbackTransactionRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RollbackTransactionRequest;
        })();

        Table.RollbackTransactionResponse = (function() {

            /**
             * Properties of a RollbackTransactionResponse.
             * @memberof Ydb.Table
             * @interface IRollbackTransactionResponse
             * @property {Ydb.Operations.IOperation|null} [operation] RollbackTransactionResponse operation
             */

            /**
             * Constructs a new RollbackTransactionResponse.
             * @memberof Ydb.Table
             * @classdesc Represents a RollbackTransactionResponse.
             * @implements IRollbackTransactionResponse
             * @constructor
             * @param {Ydb.Table.IRollbackTransactionResponse=} [properties] Properties to set
             */
            function RollbackTransactionResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RollbackTransactionResponse operation.
             * @member {Ydb.Operations.IOperation|null|undefined} operation
             * @memberof Ydb.Table.RollbackTransactionResponse
             * @instance
             */
            RollbackTransactionResponse.prototype.operation = null;

            /**
             * Creates a new RollbackTransactionResponse instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.RollbackTransactionResponse
             * @static
             * @param {Ydb.Table.IRollbackTransactionResponse=} [properties] Properties to set
             * @returns {Ydb.Table.RollbackTransactionResponse} RollbackTransactionResponse instance
             */
            RollbackTransactionResponse.create = function create(properties) {
                return new RollbackTransactionResponse(properties);
            };

            /**
             * Encodes the specified RollbackTransactionResponse message. Does not implicitly {@link Ydb.Table.RollbackTransactionResponse.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.RollbackTransactionResponse
             * @static
             * @param {Ydb.Table.IRollbackTransactionResponse} message RollbackTransactionResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RollbackTransactionResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.operation != null && Object.hasOwnProperty.call(message, "operation"))
                    $root.Ydb.Operations.Operation.encode(message.operation, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified RollbackTransactionResponse message, length delimited. Does not implicitly {@link Ydb.Table.RollbackTransactionResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.RollbackTransactionResponse
             * @static
             * @param {Ydb.Table.IRollbackTransactionResponse} message RollbackTransactionResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RollbackTransactionResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RollbackTransactionResponse message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.RollbackTransactionResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.RollbackTransactionResponse} RollbackTransactionResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RollbackTransactionResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.RollbackTransactionResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.operation = $root.Ydb.Operations.Operation.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RollbackTransactionResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.RollbackTransactionResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.RollbackTransactionResponse} RollbackTransactionResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RollbackTransactionResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RollbackTransactionResponse message.
             * @function verify
             * @memberof Ydb.Table.RollbackTransactionResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RollbackTransactionResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.operation != null && message.hasOwnProperty("operation")) {
                    var error = $root.Ydb.Operations.Operation.verify(message.operation);
                    if (error)
                        return "operation." + error;
                }
                return null;
            };

            /**
             * Creates a RollbackTransactionResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.RollbackTransactionResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.RollbackTransactionResponse} RollbackTransactionResponse
             */
            RollbackTransactionResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.RollbackTransactionResponse)
                    return object;
                var message = new $root.Ydb.Table.RollbackTransactionResponse();
                if (object.operation != null) {
                    if (typeof object.operation !== "object")
                        throw TypeError(".Ydb.Table.RollbackTransactionResponse.operation: object expected");
                    message.operation = $root.Ydb.Operations.Operation.fromObject(object.operation);
                }
                return message;
            };

            /**
             * Creates a plain object from a RollbackTransactionResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.RollbackTransactionResponse
             * @static
             * @param {Ydb.Table.RollbackTransactionResponse} message RollbackTransactionResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RollbackTransactionResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.operation = null;
                if (message.operation != null && message.hasOwnProperty("operation"))
                    object.operation = $root.Ydb.Operations.Operation.toObject(message.operation, options);
                return object;
            };

            /**
             * Converts this RollbackTransactionResponse to JSON.
             * @function toJSON
             * @memberof Ydb.Table.RollbackTransactionResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RollbackTransactionResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RollbackTransactionResponse;
        })();

        Table.StoragePolicyDescription = (function() {

            /**
             * Properties of a StoragePolicyDescription.
             * @memberof Ydb.Table
             * @interface IStoragePolicyDescription
             * @property {string|null} [name] StoragePolicyDescription name
             * @property {Object.<string,string>|null} [labels] StoragePolicyDescription labels
             */

            /**
             * Constructs a new StoragePolicyDescription.
             * @memberof Ydb.Table
             * @classdesc Represents a StoragePolicyDescription.
             * @implements IStoragePolicyDescription
             * @constructor
             * @param {Ydb.Table.IStoragePolicyDescription=} [properties] Properties to set
             */
            function StoragePolicyDescription(properties) {
                this.labels = {};
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * StoragePolicyDescription name.
             * @member {string} name
             * @memberof Ydb.Table.StoragePolicyDescription
             * @instance
             */
            StoragePolicyDescription.prototype.name = "";

            /**
             * StoragePolicyDescription labels.
             * @member {Object.<string,string>} labels
             * @memberof Ydb.Table.StoragePolicyDescription
             * @instance
             */
            StoragePolicyDescription.prototype.labels = $util.emptyObject;

            /**
             * Creates a new StoragePolicyDescription instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.StoragePolicyDescription
             * @static
             * @param {Ydb.Table.IStoragePolicyDescription=} [properties] Properties to set
             * @returns {Ydb.Table.StoragePolicyDescription} StoragePolicyDescription instance
             */
            StoragePolicyDescription.create = function create(properties) {
                return new StoragePolicyDescription(properties);
            };

            /**
             * Encodes the specified StoragePolicyDescription message. Does not implicitly {@link Ydb.Table.StoragePolicyDescription.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.StoragePolicyDescription
             * @static
             * @param {Ydb.Table.IStoragePolicyDescription} message StoragePolicyDescription message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StoragePolicyDescription.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.labels != null && Object.hasOwnProperty.call(message, "labels"))
                    for (var keys = Object.keys(message.labels), i = 0; i < keys.length; ++i)
                        writer.uint32(/* id 2, wireType 2 =*/18).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.labels[keys[i]]).ldelim();
                return writer;
            };

            /**
             * Encodes the specified StoragePolicyDescription message, length delimited. Does not implicitly {@link Ydb.Table.StoragePolicyDescription.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.StoragePolicyDescription
             * @static
             * @param {Ydb.Table.IStoragePolicyDescription} message StoragePolicyDescription message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StoragePolicyDescription.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a StoragePolicyDescription message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.StoragePolicyDescription
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.StoragePolicyDescription} StoragePolicyDescription
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StoragePolicyDescription.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.StoragePolicyDescription(), key, value;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        if (message.labels === $util.emptyObject)
                            message.labels = {};
                        var end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = "";
                        while (reader.pos < end2) {
                            var tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = reader.string();
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.labels[key] = value;
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a StoragePolicyDescription message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.StoragePolicyDescription
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.StoragePolicyDescription} StoragePolicyDescription
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StoragePolicyDescription.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a StoragePolicyDescription message.
             * @function verify
             * @memberof Ydb.Table.StoragePolicyDescription
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            StoragePolicyDescription.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.labels != null && message.hasOwnProperty("labels")) {
                    if (!$util.isObject(message.labels))
                        return "labels: object expected";
                    var key = Object.keys(message.labels);
                    for (var i = 0; i < key.length; ++i)
                        if (!$util.isString(message.labels[key[i]]))
                            return "labels: string{k:string} expected";
                }
                return null;
            };

            /**
             * Creates a StoragePolicyDescription message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.StoragePolicyDescription
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.StoragePolicyDescription} StoragePolicyDescription
             */
            StoragePolicyDescription.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.StoragePolicyDescription)
                    return object;
                var message = new $root.Ydb.Table.StoragePolicyDescription();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.labels) {
                    if (typeof object.labels !== "object")
                        throw TypeError(".Ydb.Table.StoragePolicyDescription.labels: object expected");
                    message.labels = {};
                    for (var keys = Object.keys(object.labels), i = 0; i < keys.length; ++i)
                        message.labels[keys[i]] = String(object.labels[keys[i]]);
                }
                return message;
            };

            /**
             * Creates a plain object from a StoragePolicyDescription message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.StoragePolicyDescription
             * @static
             * @param {Ydb.Table.StoragePolicyDescription} message StoragePolicyDescription
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            StoragePolicyDescription.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.objects || options.defaults)
                    object.labels = {};
                if (options.defaults)
                    object.name = "";
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                var keys2;
                if (message.labels && (keys2 = Object.keys(message.labels)).length) {
                    object.labels = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.labels[keys2[j]] = message.labels[keys2[j]];
                }
                return object;
            };

            /**
             * Converts this StoragePolicyDescription to JSON.
             * @function toJSON
             * @memberof Ydb.Table.StoragePolicyDescription
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            StoragePolicyDescription.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return StoragePolicyDescription;
        })();

        Table.CompactionPolicyDescription = (function() {

            /**
             * Properties of a CompactionPolicyDescription.
             * @memberof Ydb.Table
             * @interface ICompactionPolicyDescription
             * @property {string|null} [name] CompactionPolicyDescription name
             * @property {Object.<string,string>|null} [labels] CompactionPolicyDescription labels
             */

            /**
             * Constructs a new CompactionPolicyDescription.
             * @memberof Ydb.Table
             * @classdesc Represents a CompactionPolicyDescription.
             * @implements ICompactionPolicyDescription
             * @constructor
             * @param {Ydb.Table.ICompactionPolicyDescription=} [properties] Properties to set
             */
            function CompactionPolicyDescription(properties) {
                this.labels = {};
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CompactionPolicyDescription name.
             * @member {string} name
             * @memberof Ydb.Table.CompactionPolicyDescription
             * @instance
             */
            CompactionPolicyDescription.prototype.name = "";

            /**
             * CompactionPolicyDescription labels.
             * @member {Object.<string,string>} labels
             * @memberof Ydb.Table.CompactionPolicyDescription
             * @instance
             */
            CompactionPolicyDescription.prototype.labels = $util.emptyObject;

            /**
             * Creates a new CompactionPolicyDescription instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.CompactionPolicyDescription
             * @static
             * @param {Ydb.Table.ICompactionPolicyDescription=} [properties] Properties to set
             * @returns {Ydb.Table.CompactionPolicyDescription} CompactionPolicyDescription instance
             */
            CompactionPolicyDescription.create = function create(properties) {
                return new CompactionPolicyDescription(properties);
            };

            /**
             * Encodes the specified CompactionPolicyDescription message. Does not implicitly {@link Ydb.Table.CompactionPolicyDescription.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.CompactionPolicyDescription
             * @static
             * @param {Ydb.Table.ICompactionPolicyDescription} message CompactionPolicyDescription message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CompactionPolicyDescription.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.labels != null && Object.hasOwnProperty.call(message, "labels"))
                    for (var keys = Object.keys(message.labels), i = 0; i < keys.length; ++i)
                        writer.uint32(/* id 2, wireType 2 =*/18).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.labels[keys[i]]).ldelim();
                return writer;
            };

            /**
             * Encodes the specified CompactionPolicyDescription message, length delimited. Does not implicitly {@link Ydb.Table.CompactionPolicyDescription.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.CompactionPolicyDescription
             * @static
             * @param {Ydb.Table.ICompactionPolicyDescription} message CompactionPolicyDescription message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CompactionPolicyDescription.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CompactionPolicyDescription message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.CompactionPolicyDescription
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.CompactionPolicyDescription} CompactionPolicyDescription
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CompactionPolicyDescription.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.CompactionPolicyDescription(), key, value;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        if (message.labels === $util.emptyObject)
                            message.labels = {};
                        var end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = "";
                        while (reader.pos < end2) {
                            var tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = reader.string();
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.labels[key] = value;
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a CompactionPolicyDescription message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.CompactionPolicyDescription
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.CompactionPolicyDescription} CompactionPolicyDescription
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CompactionPolicyDescription.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CompactionPolicyDescription message.
             * @function verify
             * @memberof Ydb.Table.CompactionPolicyDescription
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CompactionPolicyDescription.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.labels != null && message.hasOwnProperty("labels")) {
                    if (!$util.isObject(message.labels))
                        return "labels: object expected";
                    var key = Object.keys(message.labels);
                    for (var i = 0; i < key.length; ++i)
                        if (!$util.isString(message.labels[key[i]]))
                            return "labels: string{k:string} expected";
                }
                return null;
            };

            /**
             * Creates a CompactionPolicyDescription message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.CompactionPolicyDescription
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.CompactionPolicyDescription} CompactionPolicyDescription
             */
            CompactionPolicyDescription.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.CompactionPolicyDescription)
                    return object;
                var message = new $root.Ydb.Table.CompactionPolicyDescription();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.labels) {
                    if (typeof object.labels !== "object")
                        throw TypeError(".Ydb.Table.CompactionPolicyDescription.labels: object expected");
                    message.labels = {};
                    for (var keys = Object.keys(object.labels), i = 0; i < keys.length; ++i)
                        message.labels[keys[i]] = String(object.labels[keys[i]]);
                }
                return message;
            };

            /**
             * Creates a plain object from a CompactionPolicyDescription message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.CompactionPolicyDescription
             * @static
             * @param {Ydb.Table.CompactionPolicyDescription} message CompactionPolicyDescription
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CompactionPolicyDescription.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.objects || options.defaults)
                    object.labels = {};
                if (options.defaults)
                    object.name = "";
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                var keys2;
                if (message.labels && (keys2 = Object.keys(message.labels)).length) {
                    object.labels = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.labels[keys2[j]] = message.labels[keys2[j]];
                }
                return object;
            };

            /**
             * Converts this CompactionPolicyDescription to JSON.
             * @function toJSON
             * @memberof Ydb.Table.CompactionPolicyDescription
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CompactionPolicyDescription.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return CompactionPolicyDescription;
        })();

        Table.PartitioningPolicyDescription = (function() {

            /**
             * Properties of a PartitioningPolicyDescription.
             * @memberof Ydb.Table
             * @interface IPartitioningPolicyDescription
             * @property {string|null} [name] PartitioningPolicyDescription name
             * @property {Object.<string,string>|null} [labels] PartitioningPolicyDescription labels
             */

            /**
             * Constructs a new PartitioningPolicyDescription.
             * @memberof Ydb.Table
             * @classdesc Represents a PartitioningPolicyDescription.
             * @implements IPartitioningPolicyDescription
             * @constructor
             * @param {Ydb.Table.IPartitioningPolicyDescription=} [properties] Properties to set
             */
            function PartitioningPolicyDescription(properties) {
                this.labels = {};
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PartitioningPolicyDescription name.
             * @member {string} name
             * @memberof Ydb.Table.PartitioningPolicyDescription
             * @instance
             */
            PartitioningPolicyDescription.prototype.name = "";

            /**
             * PartitioningPolicyDescription labels.
             * @member {Object.<string,string>} labels
             * @memberof Ydb.Table.PartitioningPolicyDescription
             * @instance
             */
            PartitioningPolicyDescription.prototype.labels = $util.emptyObject;

            /**
             * Creates a new PartitioningPolicyDescription instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.PartitioningPolicyDescription
             * @static
             * @param {Ydb.Table.IPartitioningPolicyDescription=} [properties] Properties to set
             * @returns {Ydb.Table.PartitioningPolicyDescription} PartitioningPolicyDescription instance
             */
            PartitioningPolicyDescription.create = function create(properties) {
                return new PartitioningPolicyDescription(properties);
            };

            /**
             * Encodes the specified PartitioningPolicyDescription message. Does not implicitly {@link Ydb.Table.PartitioningPolicyDescription.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.PartitioningPolicyDescription
             * @static
             * @param {Ydb.Table.IPartitioningPolicyDescription} message PartitioningPolicyDescription message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PartitioningPolicyDescription.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.labels != null && Object.hasOwnProperty.call(message, "labels"))
                    for (var keys = Object.keys(message.labels), i = 0; i < keys.length; ++i)
                        writer.uint32(/* id 2, wireType 2 =*/18).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.labels[keys[i]]).ldelim();
                return writer;
            };

            /**
             * Encodes the specified PartitioningPolicyDescription message, length delimited. Does not implicitly {@link Ydb.Table.PartitioningPolicyDescription.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.PartitioningPolicyDescription
             * @static
             * @param {Ydb.Table.IPartitioningPolicyDescription} message PartitioningPolicyDescription message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PartitioningPolicyDescription.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PartitioningPolicyDescription message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.PartitioningPolicyDescription
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.PartitioningPolicyDescription} PartitioningPolicyDescription
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PartitioningPolicyDescription.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.PartitioningPolicyDescription(), key, value;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        if (message.labels === $util.emptyObject)
                            message.labels = {};
                        var end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = "";
                        while (reader.pos < end2) {
                            var tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = reader.string();
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.labels[key] = value;
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a PartitioningPolicyDescription message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.PartitioningPolicyDescription
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.PartitioningPolicyDescription} PartitioningPolicyDescription
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PartitioningPolicyDescription.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PartitioningPolicyDescription message.
             * @function verify
             * @memberof Ydb.Table.PartitioningPolicyDescription
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PartitioningPolicyDescription.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.labels != null && message.hasOwnProperty("labels")) {
                    if (!$util.isObject(message.labels))
                        return "labels: object expected";
                    var key = Object.keys(message.labels);
                    for (var i = 0; i < key.length; ++i)
                        if (!$util.isString(message.labels[key[i]]))
                            return "labels: string{k:string} expected";
                }
                return null;
            };

            /**
             * Creates a PartitioningPolicyDescription message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.PartitioningPolicyDescription
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.PartitioningPolicyDescription} PartitioningPolicyDescription
             */
            PartitioningPolicyDescription.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.PartitioningPolicyDescription)
                    return object;
                var message = new $root.Ydb.Table.PartitioningPolicyDescription();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.labels) {
                    if (typeof object.labels !== "object")
                        throw TypeError(".Ydb.Table.PartitioningPolicyDescription.labels: object expected");
                    message.labels = {};
                    for (var keys = Object.keys(object.labels), i = 0; i < keys.length; ++i)
                        message.labels[keys[i]] = String(object.labels[keys[i]]);
                }
                return message;
            };

            /**
             * Creates a plain object from a PartitioningPolicyDescription message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.PartitioningPolicyDescription
             * @static
             * @param {Ydb.Table.PartitioningPolicyDescription} message PartitioningPolicyDescription
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PartitioningPolicyDescription.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.objects || options.defaults)
                    object.labels = {};
                if (options.defaults)
                    object.name = "";
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                var keys2;
                if (message.labels && (keys2 = Object.keys(message.labels)).length) {
                    object.labels = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.labels[keys2[j]] = message.labels[keys2[j]];
                }
                return object;
            };

            /**
             * Converts this PartitioningPolicyDescription to JSON.
             * @function toJSON
             * @memberof Ydb.Table.PartitioningPolicyDescription
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PartitioningPolicyDescription.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return PartitioningPolicyDescription;
        })();

        Table.ExecutionPolicyDescription = (function() {

            /**
             * Properties of an ExecutionPolicyDescription.
             * @memberof Ydb.Table
             * @interface IExecutionPolicyDescription
             * @property {string|null} [name] ExecutionPolicyDescription name
             * @property {Object.<string,string>|null} [labels] ExecutionPolicyDescription labels
             */

            /**
             * Constructs a new ExecutionPolicyDescription.
             * @memberof Ydb.Table
             * @classdesc Represents an ExecutionPolicyDescription.
             * @implements IExecutionPolicyDescription
             * @constructor
             * @param {Ydb.Table.IExecutionPolicyDescription=} [properties] Properties to set
             */
            function ExecutionPolicyDescription(properties) {
                this.labels = {};
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ExecutionPolicyDescription name.
             * @member {string} name
             * @memberof Ydb.Table.ExecutionPolicyDescription
             * @instance
             */
            ExecutionPolicyDescription.prototype.name = "";

            /**
             * ExecutionPolicyDescription labels.
             * @member {Object.<string,string>} labels
             * @memberof Ydb.Table.ExecutionPolicyDescription
             * @instance
             */
            ExecutionPolicyDescription.prototype.labels = $util.emptyObject;

            /**
             * Creates a new ExecutionPolicyDescription instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.ExecutionPolicyDescription
             * @static
             * @param {Ydb.Table.IExecutionPolicyDescription=} [properties] Properties to set
             * @returns {Ydb.Table.ExecutionPolicyDescription} ExecutionPolicyDescription instance
             */
            ExecutionPolicyDescription.create = function create(properties) {
                return new ExecutionPolicyDescription(properties);
            };

            /**
             * Encodes the specified ExecutionPolicyDescription message. Does not implicitly {@link Ydb.Table.ExecutionPolicyDescription.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.ExecutionPolicyDescription
             * @static
             * @param {Ydb.Table.IExecutionPolicyDescription} message ExecutionPolicyDescription message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExecutionPolicyDescription.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.labels != null && Object.hasOwnProperty.call(message, "labels"))
                    for (var keys = Object.keys(message.labels), i = 0; i < keys.length; ++i)
                        writer.uint32(/* id 2, wireType 2 =*/18).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.labels[keys[i]]).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ExecutionPolicyDescription message, length delimited. Does not implicitly {@link Ydb.Table.ExecutionPolicyDescription.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.ExecutionPolicyDescription
             * @static
             * @param {Ydb.Table.IExecutionPolicyDescription} message ExecutionPolicyDescription message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExecutionPolicyDescription.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ExecutionPolicyDescription message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.ExecutionPolicyDescription
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.ExecutionPolicyDescription} ExecutionPolicyDescription
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExecutionPolicyDescription.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.ExecutionPolicyDescription(), key, value;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        if (message.labels === $util.emptyObject)
                            message.labels = {};
                        var end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = "";
                        while (reader.pos < end2) {
                            var tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = reader.string();
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.labels[key] = value;
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an ExecutionPolicyDescription message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.ExecutionPolicyDescription
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.ExecutionPolicyDescription} ExecutionPolicyDescription
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExecutionPolicyDescription.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ExecutionPolicyDescription message.
             * @function verify
             * @memberof Ydb.Table.ExecutionPolicyDescription
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ExecutionPolicyDescription.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.labels != null && message.hasOwnProperty("labels")) {
                    if (!$util.isObject(message.labels))
                        return "labels: object expected";
                    var key = Object.keys(message.labels);
                    for (var i = 0; i < key.length; ++i)
                        if (!$util.isString(message.labels[key[i]]))
                            return "labels: string{k:string} expected";
                }
                return null;
            };

            /**
             * Creates an ExecutionPolicyDescription message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.ExecutionPolicyDescription
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.ExecutionPolicyDescription} ExecutionPolicyDescription
             */
            ExecutionPolicyDescription.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.ExecutionPolicyDescription)
                    return object;
                var message = new $root.Ydb.Table.ExecutionPolicyDescription();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.labels) {
                    if (typeof object.labels !== "object")
                        throw TypeError(".Ydb.Table.ExecutionPolicyDescription.labels: object expected");
                    message.labels = {};
                    for (var keys = Object.keys(object.labels), i = 0; i < keys.length; ++i)
                        message.labels[keys[i]] = String(object.labels[keys[i]]);
                }
                return message;
            };

            /**
             * Creates a plain object from an ExecutionPolicyDescription message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.ExecutionPolicyDescription
             * @static
             * @param {Ydb.Table.ExecutionPolicyDescription} message ExecutionPolicyDescription
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ExecutionPolicyDescription.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.objects || options.defaults)
                    object.labels = {};
                if (options.defaults)
                    object.name = "";
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                var keys2;
                if (message.labels && (keys2 = Object.keys(message.labels)).length) {
                    object.labels = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.labels[keys2[j]] = message.labels[keys2[j]];
                }
                return object;
            };

            /**
             * Converts this ExecutionPolicyDescription to JSON.
             * @function toJSON
             * @memberof Ydb.Table.ExecutionPolicyDescription
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ExecutionPolicyDescription.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ExecutionPolicyDescription;
        })();

        Table.ReplicationPolicyDescription = (function() {

            /**
             * Properties of a ReplicationPolicyDescription.
             * @memberof Ydb.Table
             * @interface IReplicationPolicyDescription
             * @property {string|null} [name] ReplicationPolicyDescription name
             * @property {Object.<string,string>|null} [labels] ReplicationPolicyDescription labels
             */

            /**
             * Constructs a new ReplicationPolicyDescription.
             * @memberof Ydb.Table
             * @classdesc Represents a ReplicationPolicyDescription.
             * @implements IReplicationPolicyDescription
             * @constructor
             * @param {Ydb.Table.IReplicationPolicyDescription=} [properties] Properties to set
             */
            function ReplicationPolicyDescription(properties) {
                this.labels = {};
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ReplicationPolicyDescription name.
             * @member {string} name
             * @memberof Ydb.Table.ReplicationPolicyDescription
             * @instance
             */
            ReplicationPolicyDescription.prototype.name = "";

            /**
             * ReplicationPolicyDescription labels.
             * @member {Object.<string,string>} labels
             * @memberof Ydb.Table.ReplicationPolicyDescription
             * @instance
             */
            ReplicationPolicyDescription.prototype.labels = $util.emptyObject;

            /**
             * Creates a new ReplicationPolicyDescription instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.ReplicationPolicyDescription
             * @static
             * @param {Ydb.Table.IReplicationPolicyDescription=} [properties] Properties to set
             * @returns {Ydb.Table.ReplicationPolicyDescription} ReplicationPolicyDescription instance
             */
            ReplicationPolicyDescription.create = function create(properties) {
                return new ReplicationPolicyDescription(properties);
            };

            /**
             * Encodes the specified ReplicationPolicyDescription message. Does not implicitly {@link Ydb.Table.ReplicationPolicyDescription.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.ReplicationPolicyDescription
             * @static
             * @param {Ydb.Table.IReplicationPolicyDescription} message ReplicationPolicyDescription message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReplicationPolicyDescription.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.labels != null && Object.hasOwnProperty.call(message, "labels"))
                    for (var keys = Object.keys(message.labels), i = 0; i < keys.length; ++i)
                        writer.uint32(/* id 2, wireType 2 =*/18).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.labels[keys[i]]).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ReplicationPolicyDescription message, length delimited. Does not implicitly {@link Ydb.Table.ReplicationPolicyDescription.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.ReplicationPolicyDescription
             * @static
             * @param {Ydb.Table.IReplicationPolicyDescription} message ReplicationPolicyDescription message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReplicationPolicyDescription.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReplicationPolicyDescription message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.ReplicationPolicyDescription
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.ReplicationPolicyDescription} ReplicationPolicyDescription
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReplicationPolicyDescription.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.ReplicationPolicyDescription(), key, value;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        if (message.labels === $util.emptyObject)
                            message.labels = {};
                        var end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = "";
                        while (reader.pos < end2) {
                            var tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = reader.string();
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.labels[key] = value;
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ReplicationPolicyDescription message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.ReplicationPolicyDescription
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.ReplicationPolicyDescription} ReplicationPolicyDescription
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReplicationPolicyDescription.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReplicationPolicyDescription message.
             * @function verify
             * @memberof Ydb.Table.ReplicationPolicyDescription
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReplicationPolicyDescription.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.labels != null && message.hasOwnProperty("labels")) {
                    if (!$util.isObject(message.labels))
                        return "labels: object expected";
                    var key = Object.keys(message.labels);
                    for (var i = 0; i < key.length; ++i)
                        if (!$util.isString(message.labels[key[i]]))
                            return "labels: string{k:string} expected";
                }
                return null;
            };

            /**
             * Creates a ReplicationPolicyDescription message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.ReplicationPolicyDescription
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.ReplicationPolicyDescription} ReplicationPolicyDescription
             */
            ReplicationPolicyDescription.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.ReplicationPolicyDescription)
                    return object;
                var message = new $root.Ydb.Table.ReplicationPolicyDescription();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.labels) {
                    if (typeof object.labels !== "object")
                        throw TypeError(".Ydb.Table.ReplicationPolicyDescription.labels: object expected");
                    message.labels = {};
                    for (var keys = Object.keys(object.labels), i = 0; i < keys.length; ++i)
                        message.labels[keys[i]] = String(object.labels[keys[i]]);
                }
                return message;
            };

            /**
             * Creates a plain object from a ReplicationPolicyDescription message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.ReplicationPolicyDescription
             * @static
             * @param {Ydb.Table.ReplicationPolicyDescription} message ReplicationPolicyDescription
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReplicationPolicyDescription.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.objects || options.defaults)
                    object.labels = {};
                if (options.defaults)
                    object.name = "";
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                var keys2;
                if (message.labels && (keys2 = Object.keys(message.labels)).length) {
                    object.labels = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.labels[keys2[j]] = message.labels[keys2[j]];
                }
                return object;
            };

            /**
             * Converts this ReplicationPolicyDescription to JSON.
             * @function toJSON
             * @memberof Ydb.Table.ReplicationPolicyDescription
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReplicationPolicyDescription.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ReplicationPolicyDescription;
        })();

        Table.CachingPolicyDescription = (function() {

            /**
             * Properties of a CachingPolicyDescription.
             * @memberof Ydb.Table
             * @interface ICachingPolicyDescription
             * @property {string|null} [name] CachingPolicyDescription name
             * @property {Object.<string,string>|null} [labels] CachingPolicyDescription labels
             */

            /**
             * Constructs a new CachingPolicyDescription.
             * @memberof Ydb.Table
             * @classdesc Represents a CachingPolicyDescription.
             * @implements ICachingPolicyDescription
             * @constructor
             * @param {Ydb.Table.ICachingPolicyDescription=} [properties] Properties to set
             */
            function CachingPolicyDescription(properties) {
                this.labels = {};
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CachingPolicyDescription name.
             * @member {string} name
             * @memberof Ydb.Table.CachingPolicyDescription
             * @instance
             */
            CachingPolicyDescription.prototype.name = "";

            /**
             * CachingPolicyDescription labels.
             * @member {Object.<string,string>} labels
             * @memberof Ydb.Table.CachingPolicyDescription
             * @instance
             */
            CachingPolicyDescription.prototype.labels = $util.emptyObject;

            /**
             * Creates a new CachingPolicyDescription instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.CachingPolicyDescription
             * @static
             * @param {Ydb.Table.ICachingPolicyDescription=} [properties] Properties to set
             * @returns {Ydb.Table.CachingPolicyDescription} CachingPolicyDescription instance
             */
            CachingPolicyDescription.create = function create(properties) {
                return new CachingPolicyDescription(properties);
            };

            /**
             * Encodes the specified CachingPolicyDescription message. Does not implicitly {@link Ydb.Table.CachingPolicyDescription.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.CachingPolicyDescription
             * @static
             * @param {Ydb.Table.ICachingPolicyDescription} message CachingPolicyDescription message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CachingPolicyDescription.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.labels != null && Object.hasOwnProperty.call(message, "labels"))
                    for (var keys = Object.keys(message.labels), i = 0; i < keys.length; ++i)
                        writer.uint32(/* id 2, wireType 2 =*/18).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.labels[keys[i]]).ldelim();
                return writer;
            };

            /**
             * Encodes the specified CachingPolicyDescription message, length delimited. Does not implicitly {@link Ydb.Table.CachingPolicyDescription.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.CachingPolicyDescription
             * @static
             * @param {Ydb.Table.ICachingPolicyDescription} message CachingPolicyDescription message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CachingPolicyDescription.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CachingPolicyDescription message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.CachingPolicyDescription
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.CachingPolicyDescription} CachingPolicyDescription
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CachingPolicyDescription.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.CachingPolicyDescription(), key, value;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        if (message.labels === $util.emptyObject)
                            message.labels = {};
                        var end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = "";
                        while (reader.pos < end2) {
                            var tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = reader.string();
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.labels[key] = value;
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a CachingPolicyDescription message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.CachingPolicyDescription
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.CachingPolicyDescription} CachingPolicyDescription
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CachingPolicyDescription.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CachingPolicyDescription message.
             * @function verify
             * @memberof Ydb.Table.CachingPolicyDescription
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CachingPolicyDescription.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.labels != null && message.hasOwnProperty("labels")) {
                    if (!$util.isObject(message.labels))
                        return "labels: object expected";
                    var key = Object.keys(message.labels);
                    for (var i = 0; i < key.length; ++i)
                        if (!$util.isString(message.labels[key[i]]))
                            return "labels: string{k:string} expected";
                }
                return null;
            };

            /**
             * Creates a CachingPolicyDescription message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.CachingPolicyDescription
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.CachingPolicyDescription} CachingPolicyDescription
             */
            CachingPolicyDescription.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.CachingPolicyDescription)
                    return object;
                var message = new $root.Ydb.Table.CachingPolicyDescription();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.labels) {
                    if (typeof object.labels !== "object")
                        throw TypeError(".Ydb.Table.CachingPolicyDescription.labels: object expected");
                    message.labels = {};
                    for (var keys = Object.keys(object.labels), i = 0; i < keys.length; ++i)
                        message.labels[keys[i]] = String(object.labels[keys[i]]);
                }
                return message;
            };

            /**
             * Creates a plain object from a CachingPolicyDescription message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.CachingPolicyDescription
             * @static
             * @param {Ydb.Table.CachingPolicyDescription} message CachingPolicyDescription
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CachingPolicyDescription.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.objects || options.defaults)
                    object.labels = {};
                if (options.defaults)
                    object.name = "";
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                var keys2;
                if (message.labels && (keys2 = Object.keys(message.labels)).length) {
                    object.labels = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.labels[keys2[j]] = message.labels[keys2[j]];
                }
                return object;
            };

            /**
             * Converts this CachingPolicyDescription to JSON.
             * @function toJSON
             * @memberof Ydb.Table.CachingPolicyDescription
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CachingPolicyDescription.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return CachingPolicyDescription;
        })();

        Table.TableProfileDescription = (function() {

            /**
             * Properties of a TableProfileDescription.
             * @memberof Ydb.Table
             * @interface ITableProfileDescription
             * @property {string|null} [name] TableProfileDescription name
             * @property {Object.<string,string>|null} [labels] TableProfileDescription labels
             * @property {string|null} [defaultStoragePolicy] TableProfileDescription defaultStoragePolicy
             * @property {Array.<string>|null} [allowedStoragePolicies] TableProfileDescription allowedStoragePolicies
             * @property {string|null} [defaultCompactionPolicy] TableProfileDescription defaultCompactionPolicy
             * @property {Array.<string>|null} [allowedCompactionPolicies] TableProfileDescription allowedCompactionPolicies
             * @property {string|null} [defaultPartitioningPolicy] TableProfileDescription defaultPartitioningPolicy
             * @property {Array.<string>|null} [allowedPartitioningPolicies] TableProfileDescription allowedPartitioningPolicies
             * @property {string|null} [defaultExecutionPolicy] TableProfileDescription defaultExecutionPolicy
             * @property {Array.<string>|null} [allowedExecutionPolicies] TableProfileDescription allowedExecutionPolicies
             * @property {string|null} [defaultReplicationPolicy] TableProfileDescription defaultReplicationPolicy
             * @property {Array.<string>|null} [allowedReplicationPolicies] TableProfileDescription allowedReplicationPolicies
             * @property {string|null} [defaultCachingPolicy] TableProfileDescription defaultCachingPolicy
             * @property {Array.<string>|null} [allowedCachingPolicies] TableProfileDescription allowedCachingPolicies
             */

            /**
             * Constructs a new TableProfileDescription.
             * @memberof Ydb.Table
             * @classdesc Represents a TableProfileDescription.
             * @implements ITableProfileDescription
             * @constructor
             * @param {Ydb.Table.ITableProfileDescription=} [properties] Properties to set
             */
            function TableProfileDescription(properties) {
                this.labels = {};
                this.allowedStoragePolicies = [];
                this.allowedCompactionPolicies = [];
                this.allowedPartitioningPolicies = [];
                this.allowedExecutionPolicies = [];
                this.allowedReplicationPolicies = [];
                this.allowedCachingPolicies = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * TableProfileDescription name.
             * @member {string} name
             * @memberof Ydb.Table.TableProfileDescription
             * @instance
             */
            TableProfileDescription.prototype.name = "";

            /**
             * TableProfileDescription labels.
             * @member {Object.<string,string>} labels
             * @memberof Ydb.Table.TableProfileDescription
             * @instance
             */
            TableProfileDescription.prototype.labels = $util.emptyObject;

            /**
             * TableProfileDescription defaultStoragePolicy.
             * @member {string} defaultStoragePolicy
             * @memberof Ydb.Table.TableProfileDescription
             * @instance
             */
            TableProfileDescription.prototype.defaultStoragePolicy = "";

            /**
             * TableProfileDescription allowedStoragePolicies.
             * @member {Array.<string>} allowedStoragePolicies
             * @memberof Ydb.Table.TableProfileDescription
             * @instance
             */
            TableProfileDescription.prototype.allowedStoragePolicies = $util.emptyArray;

            /**
             * TableProfileDescription defaultCompactionPolicy.
             * @member {string} defaultCompactionPolicy
             * @memberof Ydb.Table.TableProfileDescription
             * @instance
             */
            TableProfileDescription.prototype.defaultCompactionPolicy = "";

            /**
             * TableProfileDescription allowedCompactionPolicies.
             * @member {Array.<string>} allowedCompactionPolicies
             * @memberof Ydb.Table.TableProfileDescription
             * @instance
             */
            TableProfileDescription.prototype.allowedCompactionPolicies = $util.emptyArray;

            /**
             * TableProfileDescription defaultPartitioningPolicy.
             * @member {string} defaultPartitioningPolicy
             * @memberof Ydb.Table.TableProfileDescription
             * @instance
             */
            TableProfileDescription.prototype.defaultPartitioningPolicy = "";

            /**
             * TableProfileDescription allowedPartitioningPolicies.
             * @member {Array.<string>} allowedPartitioningPolicies
             * @memberof Ydb.Table.TableProfileDescription
             * @instance
             */
            TableProfileDescription.prototype.allowedPartitioningPolicies = $util.emptyArray;

            /**
             * TableProfileDescription defaultExecutionPolicy.
             * @member {string} defaultExecutionPolicy
             * @memberof Ydb.Table.TableProfileDescription
             * @instance
             */
            TableProfileDescription.prototype.defaultExecutionPolicy = "";

            /**
             * TableProfileDescription allowedExecutionPolicies.
             * @member {Array.<string>} allowedExecutionPolicies
             * @memberof Ydb.Table.TableProfileDescription
             * @instance
             */
            TableProfileDescription.prototype.allowedExecutionPolicies = $util.emptyArray;

            /**
             * TableProfileDescription defaultReplicationPolicy.
             * @member {string} defaultReplicationPolicy
             * @memberof Ydb.Table.TableProfileDescription
             * @instance
             */
            TableProfileDescription.prototype.defaultReplicationPolicy = "";

            /**
             * TableProfileDescription allowedReplicationPolicies.
             * @member {Array.<string>} allowedReplicationPolicies
             * @memberof Ydb.Table.TableProfileDescription
             * @instance
             */
            TableProfileDescription.prototype.allowedReplicationPolicies = $util.emptyArray;

            /**
             * TableProfileDescription defaultCachingPolicy.
             * @member {string} defaultCachingPolicy
             * @memberof Ydb.Table.TableProfileDescription
             * @instance
             */
            TableProfileDescription.prototype.defaultCachingPolicy = "";

            /**
             * TableProfileDescription allowedCachingPolicies.
             * @member {Array.<string>} allowedCachingPolicies
             * @memberof Ydb.Table.TableProfileDescription
             * @instance
             */
            TableProfileDescription.prototype.allowedCachingPolicies = $util.emptyArray;

            /**
             * Creates a new TableProfileDescription instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.TableProfileDescription
             * @static
             * @param {Ydb.Table.ITableProfileDescription=} [properties] Properties to set
             * @returns {Ydb.Table.TableProfileDescription} TableProfileDescription instance
             */
            TableProfileDescription.create = function create(properties) {
                return new TableProfileDescription(properties);
            };

            /**
             * Encodes the specified TableProfileDescription message. Does not implicitly {@link Ydb.Table.TableProfileDescription.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.TableProfileDescription
             * @static
             * @param {Ydb.Table.ITableProfileDescription} message TableProfileDescription message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TableProfileDescription.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.labels != null && Object.hasOwnProperty.call(message, "labels"))
                    for (var keys = Object.keys(message.labels), i = 0; i < keys.length; ++i)
                        writer.uint32(/* id 2, wireType 2 =*/18).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.labels[keys[i]]).ldelim();
                if (message.defaultStoragePolicy != null && Object.hasOwnProperty.call(message, "defaultStoragePolicy"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.defaultStoragePolicy);
                if (message.allowedStoragePolicies != null && message.allowedStoragePolicies.length)
                    for (var i = 0; i < message.allowedStoragePolicies.length; ++i)
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.allowedStoragePolicies[i]);
                if (message.defaultCompactionPolicy != null && Object.hasOwnProperty.call(message, "defaultCompactionPolicy"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.defaultCompactionPolicy);
                if (message.allowedCompactionPolicies != null && message.allowedCompactionPolicies.length)
                    for (var i = 0; i < message.allowedCompactionPolicies.length; ++i)
                        writer.uint32(/* id 6, wireType 2 =*/50).string(message.allowedCompactionPolicies[i]);
                if (message.defaultPartitioningPolicy != null && Object.hasOwnProperty.call(message, "defaultPartitioningPolicy"))
                    writer.uint32(/* id 7, wireType 2 =*/58).string(message.defaultPartitioningPolicy);
                if (message.allowedPartitioningPolicies != null && message.allowedPartitioningPolicies.length)
                    for (var i = 0; i < message.allowedPartitioningPolicies.length; ++i)
                        writer.uint32(/* id 8, wireType 2 =*/66).string(message.allowedPartitioningPolicies[i]);
                if (message.defaultExecutionPolicy != null && Object.hasOwnProperty.call(message, "defaultExecutionPolicy"))
                    writer.uint32(/* id 9, wireType 2 =*/74).string(message.defaultExecutionPolicy);
                if (message.allowedExecutionPolicies != null && message.allowedExecutionPolicies.length)
                    for (var i = 0; i < message.allowedExecutionPolicies.length; ++i)
                        writer.uint32(/* id 10, wireType 2 =*/82).string(message.allowedExecutionPolicies[i]);
                if (message.defaultReplicationPolicy != null && Object.hasOwnProperty.call(message, "defaultReplicationPolicy"))
                    writer.uint32(/* id 11, wireType 2 =*/90).string(message.defaultReplicationPolicy);
                if (message.allowedReplicationPolicies != null && message.allowedReplicationPolicies.length)
                    for (var i = 0; i < message.allowedReplicationPolicies.length; ++i)
                        writer.uint32(/* id 12, wireType 2 =*/98).string(message.allowedReplicationPolicies[i]);
                if (message.defaultCachingPolicy != null && Object.hasOwnProperty.call(message, "defaultCachingPolicy"))
                    writer.uint32(/* id 13, wireType 2 =*/106).string(message.defaultCachingPolicy);
                if (message.allowedCachingPolicies != null && message.allowedCachingPolicies.length)
                    for (var i = 0; i < message.allowedCachingPolicies.length; ++i)
                        writer.uint32(/* id 14, wireType 2 =*/114).string(message.allowedCachingPolicies[i]);
                return writer;
            };

            /**
             * Encodes the specified TableProfileDescription message, length delimited. Does not implicitly {@link Ydb.Table.TableProfileDescription.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.TableProfileDescription
             * @static
             * @param {Ydb.Table.ITableProfileDescription} message TableProfileDescription message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TableProfileDescription.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a TableProfileDescription message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.TableProfileDescription
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.TableProfileDescription} TableProfileDescription
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TableProfileDescription.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.TableProfileDescription(), key, value;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        if (message.labels === $util.emptyObject)
                            message.labels = {};
                        var end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = "";
                        while (reader.pos < end2) {
                            var tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = reader.string();
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.labels[key] = value;
                        break;
                    case 3:
                        message.defaultStoragePolicy = reader.string();
                        break;
                    case 4:
                        if (!(message.allowedStoragePolicies && message.allowedStoragePolicies.length))
                            message.allowedStoragePolicies = [];
                        message.allowedStoragePolicies.push(reader.string());
                        break;
                    case 5:
                        message.defaultCompactionPolicy = reader.string();
                        break;
                    case 6:
                        if (!(message.allowedCompactionPolicies && message.allowedCompactionPolicies.length))
                            message.allowedCompactionPolicies = [];
                        message.allowedCompactionPolicies.push(reader.string());
                        break;
                    case 7:
                        message.defaultPartitioningPolicy = reader.string();
                        break;
                    case 8:
                        if (!(message.allowedPartitioningPolicies && message.allowedPartitioningPolicies.length))
                            message.allowedPartitioningPolicies = [];
                        message.allowedPartitioningPolicies.push(reader.string());
                        break;
                    case 9:
                        message.defaultExecutionPolicy = reader.string();
                        break;
                    case 10:
                        if (!(message.allowedExecutionPolicies && message.allowedExecutionPolicies.length))
                            message.allowedExecutionPolicies = [];
                        message.allowedExecutionPolicies.push(reader.string());
                        break;
                    case 11:
                        message.defaultReplicationPolicy = reader.string();
                        break;
                    case 12:
                        if (!(message.allowedReplicationPolicies && message.allowedReplicationPolicies.length))
                            message.allowedReplicationPolicies = [];
                        message.allowedReplicationPolicies.push(reader.string());
                        break;
                    case 13:
                        message.defaultCachingPolicy = reader.string();
                        break;
                    case 14:
                        if (!(message.allowedCachingPolicies && message.allowedCachingPolicies.length))
                            message.allowedCachingPolicies = [];
                        message.allowedCachingPolicies.push(reader.string());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a TableProfileDescription message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.TableProfileDescription
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.TableProfileDescription} TableProfileDescription
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TableProfileDescription.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a TableProfileDescription message.
             * @function verify
             * @memberof Ydb.Table.TableProfileDescription
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TableProfileDescription.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.labels != null && message.hasOwnProperty("labels")) {
                    if (!$util.isObject(message.labels))
                        return "labels: object expected";
                    var key = Object.keys(message.labels);
                    for (var i = 0; i < key.length; ++i)
                        if (!$util.isString(message.labels[key[i]]))
                            return "labels: string{k:string} expected";
                }
                if (message.defaultStoragePolicy != null && message.hasOwnProperty("defaultStoragePolicy"))
                    if (!$util.isString(message.defaultStoragePolicy))
                        return "defaultStoragePolicy: string expected";
                if (message.allowedStoragePolicies != null && message.hasOwnProperty("allowedStoragePolicies")) {
                    if (!Array.isArray(message.allowedStoragePolicies))
                        return "allowedStoragePolicies: array expected";
                    for (var i = 0; i < message.allowedStoragePolicies.length; ++i)
                        if (!$util.isString(message.allowedStoragePolicies[i]))
                            return "allowedStoragePolicies: string[] expected";
                }
                if (message.defaultCompactionPolicy != null && message.hasOwnProperty("defaultCompactionPolicy"))
                    if (!$util.isString(message.defaultCompactionPolicy))
                        return "defaultCompactionPolicy: string expected";
                if (message.allowedCompactionPolicies != null && message.hasOwnProperty("allowedCompactionPolicies")) {
                    if (!Array.isArray(message.allowedCompactionPolicies))
                        return "allowedCompactionPolicies: array expected";
                    for (var i = 0; i < message.allowedCompactionPolicies.length; ++i)
                        if (!$util.isString(message.allowedCompactionPolicies[i]))
                            return "allowedCompactionPolicies: string[] expected";
                }
                if (message.defaultPartitioningPolicy != null && message.hasOwnProperty("defaultPartitioningPolicy"))
                    if (!$util.isString(message.defaultPartitioningPolicy))
                        return "defaultPartitioningPolicy: string expected";
                if (message.allowedPartitioningPolicies != null && message.hasOwnProperty("allowedPartitioningPolicies")) {
                    if (!Array.isArray(message.allowedPartitioningPolicies))
                        return "allowedPartitioningPolicies: array expected";
                    for (var i = 0; i < message.allowedPartitioningPolicies.length; ++i)
                        if (!$util.isString(message.allowedPartitioningPolicies[i]))
                            return "allowedPartitioningPolicies: string[] expected";
                }
                if (message.defaultExecutionPolicy != null && message.hasOwnProperty("defaultExecutionPolicy"))
                    if (!$util.isString(message.defaultExecutionPolicy))
                        return "defaultExecutionPolicy: string expected";
                if (message.allowedExecutionPolicies != null && message.hasOwnProperty("allowedExecutionPolicies")) {
                    if (!Array.isArray(message.allowedExecutionPolicies))
                        return "allowedExecutionPolicies: array expected";
                    for (var i = 0; i < message.allowedExecutionPolicies.length; ++i)
                        if (!$util.isString(message.allowedExecutionPolicies[i]))
                            return "allowedExecutionPolicies: string[] expected";
                }
                if (message.defaultReplicationPolicy != null && message.hasOwnProperty("defaultReplicationPolicy"))
                    if (!$util.isString(message.defaultReplicationPolicy))
                        return "defaultReplicationPolicy: string expected";
                if (message.allowedReplicationPolicies != null && message.hasOwnProperty("allowedReplicationPolicies")) {
                    if (!Array.isArray(message.allowedReplicationPolicies))
                        return "allowedReplicationPolicies: array expected";
                    for (var i = 0; i < message.allowedReplicationPolicies.length; ++i)
                        if (!$util.isString(message.allowedReplicationPolicies[i]))
                            return "allowedReplicationPolicies: string[] expected";
                }
                if (message.defaultCachingPolicy != null && message.hasOwnProperty("defaultCachingPolicy"))
                    if (!$util.isString(message.defaultCachingPolicy))
                        return "defaultCachingPolicy: string expected";
                if (message.allowedCachingPolicies != null && message.hasOwnProperty("allowedCachingPolicies")) {
                    if (!Array.isArray(message.allowedCachingPolicies))
                        return "allowedCachingPolicies: array expected";
                    for (var i = 0; i < message.allowedCachingPolicies.length; ++i)
                        if (!$util.isString(message.allowedCachingPolicies[i]))
                            return "allowedCachingPolicies: string[] expected";
                }
                return null;
            };

            /**
             * Creates a TableProfileDescription message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.TableProfileDescription
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.TableProfileDescription} TableProfileDescription
             */
            TableProfileDescription.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.TableProfileDescription)
                    return object;
                var message = new $root.Ydb.Table.TableProfileDescription();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.labels) {
                    if (typeof object.labels !== "object")
                        throw TypeError(".Ydb.Table.TableProfileDescription.labels: object expected");
                    message.labels = {};
                    for (var keys = Object.keys(object.labels), i = 0; i < keys.length; ++i)
                        message.labels[keys[i]] = String(object.labels[keys[i]]);
                }
                if (object.defaultStoragePolicy != null)
                    message.defaultStoragePolicy = String(object.defaultStoragePolicy);
                if (object.allowedStoragePolicies) {
                    if (!Array.isArray(object.allowedStoragePolicies))
                        throw TypeError(".Ydb.Table.TableProfileDescription.allowedStoragePolicies: array expected");
                    message.allowedStoragePolicies = [];
                    for (var i = 0; i < object.allowedStoragePolicies.length; ++i)
                        message.allowedStoragePolicies[i] = String(object.allowedStoragePolicies[i]);
                }
                if (object.defaultCompactionPolicy != null)
                    message.defaultCompactionPolicy = String(object.defaultCompactionPolicy);
                if (object.allowedCompactionPolicies) {
                    if (!Array.isArray(object.allowedCompactionPolicies))
                        throw TypeError(".Ydb.Table.TableProfileDescription.allowedCompactionPolicies: array expected");
                    message.allowedCompactionPolicies = [];
                    for (var i = 0; i < object.allowedCompactionPolicies.length; ++i)
                        message.allowedCompactionPolicies[i] = String(object.allowedCompactionPolicies[i]);
                }
                if (object.defaultPartitioningPolicy != null)
                    message.defaultPartitioningPolicy = String(object.defaultPartitioningPolicy);
                if (object.allowedPartitioningPolicies) {
                    if (!Array.isArray(object.allowedPartitioningPolicies))
                        throw TypeError(".Ydb.Table.TableProfileDescription.allowedPartitioningPolicies: array expected");
                    message.allowedPartitioningPolicies = [];
                    for (var i = 0; i < object.allowedPartitioningPolicies.length; ++i)
                        message.allowedPartitioningPolicies[i] = String(object.allowedPartitioningPolicies[i]);
                }
                if (object.defaultExecutionPolicy != null)
                    message.defaultExecutionPolicy = String(object.defaultExecutionPolicy);
                if (object.allowedExecutionPolicies) {
                    if (!Array.isArray(object.allowedExecutionPolicies))
                        throw TypeError(".Ydb.Table.TableProfileDescription.allowedExecutionPolicies: array expected");
                    message.allowedExecutionPolicies = [];
                    for (var i = 0; i < object.allowedExecutionPolicies.length; ++i)
                        message.allowedExecutionPolicies[i] = String(object.allowedExecutionPolicies[i]);
                }
                if (object.defaultReplicationPolicy != null)
                    message.defaultReplicationPolicy = String(object.defaultReplicationPolicy);
                if (object.allowedReplicationPolicies) {
                    if (!Array.isArray(object.allowedReplicationPolicies))
                        throw TypeError(".Ydb.Table.TableProfileDescription.allowedReplicationPolicies: array expected");
                    message.allowedReplicationPolicies = [];
                    for (var i = 0; i < object.allowedReplicationPolicies.length; ++i)
                        message.allowedReplicationPolicies[i] = String(object.allowedReplicationPolicies[i]);
                }
                if (object.defaultCachingPolicy != null)
                    message.defaultCachingPolicy = String(object.defaultCachingPolicy);
                if (object.allowedCachingPolicies) {
                    if (!Array.isArray(object.allowedCachingPolicies))
                        throw TypeError(".Ydb.Table.TableProfileDescription.allowedCachingPolicies: array expected");
                    message.allowedCachingPolicies = [];
                    for (var i = 0; i < object.allowedCachingPolicies.length; ++i)
                        message.allowedCachingPolicies[i] = String(object.allowedCachingPolicies[i]);
                }
                return message;
            };

            /**
             * Creates a plain object from a TableProfileDescription message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.TableProfileDescription
             * @static
             * @param {Ydb.Table.TableProfileDescription} message TableProfileDescription
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            TableProfileDescription.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.allowedStoragePolicies = [];
                    object.allowedCompactionPolicies = [];
                    object.allowedPartitioningPolicies = [];
                    object.allowedExecutionPolicies = [];
                    object.allowedReplicationPolicies = [];
                    object.allowedCachingPolicies = [];
                }
                if (options.objects || options.defaults)
                    object.labels = {};
                if (options.defaults) {
                    object.name = "";
                    object.defaultStoragePolicy = "";
                    object.defaultCompactionPolicy = "";
                    object.defaultPartitioningPolicy = "";
                    object.defaultExecutionPolicy = "";
                    object.defaultReplicationPolicy = "";
                    object.defaultCachingPolicy = "";
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                var keys2;
                if (message.labels && (keys2 = Object.keys(message.labels)).length) {
                    object.labels = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.labels[keys2[j]] = message.labels[keys2[j]];
                }
                if (message.defaultStoragePolicy != null && message.hasOwnProperty("defaultStoragePolicy"))
                    object.defaultStoragePolicy = message.defaultStoragePolicy;
                if (message.allowedStoragePolicies && message.allowedStoragePolicies.length) {
                    object.allowedStoragePolicies = [];
                    for (var j = 0; j < message.allowedStoragePolicies.length; ++j)
                        object.allowedStoragePolicies[j] = message.allowedStoragePolicies[j];
                }
                if (message.defaultCompactionPolicy != null && message.hasOwnProperty("defaultCompactionPolicy"))
                    object.defaultCompactionPolicy = message.defaultCompactionPolicy;
                if (message.allowedCompactionPolicies && message.allowedCompactionPolicies.length) {
                    object.allowedCompactionPolicies = [];
                    for (var j = 0; j < message.allowedCompactionPolicies.length; ++j)
                        object.allowedCompactionPolicies[j] = message.allowedCompactionPolicies[j];
                }
                if (message.defaultPartitioningPolicy != null && message.hasOwnProperty("defaultPartitioningPolicy"))
                    object.defaultPartitioningPolicy = message.defaultPartitioningPolicy;
                if (message.allowedPartitioningPolicies && message.allowedPartitioningPolicies.length) {
                    object.allowedPartitioningPolicies = [];
                    for (var j = 0; j < message.allowedPartitioningPolicies.length; ++j)
                        object.allowedPartitioningPolicies[j] = message.allowedPartitioningPolicies[j];
                }
                if (message.defaultExecutionPolicy != null && message.hasOwnProperty("defaultExecutionPolicy"))
                    object.defaultExecutionPolicy = message.defaultExecutionPolicy;
                if (message.allowedExecutionPolicies && message.allowedExecutionPolicies.length) {
                    object.allowedExecutionPolicies = [];
                    for (var j = 0; j < message.allowedExecutionPolicies.length; ++j)
                        object.allowedExecutionPolicies[j] = message.allowedExecutionPolicies[j];
                }
                if (message.defaultReplicationPolicy != null && message.hasOwnProperty("defaultReplicationPolicy"))
                    object.defaultReplicationPolicy = message.defaultReplicationPolicy;
                if (message.allowedReplicationPolicies && message.allowedReplicationPolicies.length) {
                    object.allowedReplicationPolicies = [];
                    for (var j = 0; j < message.allowedReplicationPolicies.length; ++j)
                        object.allowedReplicationPolicies[j] = message.allowedReplicationPolicies[j];
                }
                if (message.defaultCachingPolicy != null && message.hasOwnProperty("defaultCachingPolicy"))
                    object.defaultCachingPolicy = message.defaultCachingPolicy;
                if (message.allowedCachingPolicies && message.allowedCachingPolicies.length) {
                    object.allowedCachingPolicies = [];
                    for (var j = 0; j < message.allowedCachingPolicies.length; ++j)
                        object.allowedCachingPolicies[j] = message.allowedCachingPolicies[j];
                }
                return object;
            };

            /**
             * Converts this TableProfileDescription to JSON.
             * @function toJSON
             * @memberof Ydb.Table.TableProfileDescription
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            TableProfileDescription.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return TableProfileDescription;
        })();

        Table.DescribeTableOptionsRequest = (function() {

            /**
             * Properties of a DescribeTableOptionsRequest.
             * @memberof Ydb.Table
             * @interface IDescribeTableOptionsRequest
             * @property {Ydb.Operations.IOperationParams|null} [operationParams] DescribeTableOptionsRequest operationParams
             */

            /**
             * Constructs a new DescribeTableOptionsRequest.
             * @memberof Ydb.Table
             * @classdesc Represents a DescribeTableOptionsRequest.
             * @implements IDescribeTableOptionsRequest
             * @constructor
             * @param {Ydb.Table.IDescribeTableOptionsRequest=} [properties] Properties to set
             */
            function DescribeTableOptionsRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DescribeTableOptionsRequest operationParams.
             * @member {Ydb.Operations.IOperationParams|null|undefined} operationParams
             * @memberof Ydb.Table.DescribeTableOptionsRequest
             * @instance
             */
            DescribeTableOptionsRequest.prototype.operationParams = null;

            /**
             * Creates a new DescribeTableOptionsRequest instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.DescribeTableOptionsRequest
             * @static
             * @param {Ydb.Table.IDescribeTableOptionsRequest=} [properties] Properties to set
             * @returns {Ydb.Table.DescribeTableOptionsRequest} DescribeTableOptionsRequest instance
             */
            DescribeTableOptionsRequest.create = function create(properties) {
                return new DescribeTableOptionsRequest(properties);
            };

            /**
             * Encodes the specified DescribeTableOptionsRequest message. Does not implicitly {@link Ydb.Table.DescribeTableOptionsRequest.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.DescribeTableOptionsRequest
             * @static
             * @param {Ydb.Table.IDescribeTableOptionsRequest} message DescribeTableOptionsRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DescribeTableOptionsRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.operationParams != null && Object.hasOwnProperty.call(message, "operationParams"))
                    $root.Ydb.Operations.OperationParams.encode(message.operationParams, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified DescribeTableOptionsRequest message, length delimited. Does not implicitly {@link Ydb.Table.DescribeTableOptionsRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.DescribeTableOptionsRequest
             * @static
             * @param {Ydb.Table.IDescribeTableOptionsRequest} message DescribeTableOptionsRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DescribeTableOptionsRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DescribeTableOptionsRequest message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.DescribeTableOptionsRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.DescribeTableOptionsRequest} DescribeTableOptionsRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DescribeTableOptionsRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.DescribeTableOptionsRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.operationParams = $root.Ydb.Operations.OperationParams.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DescribeTableOptionsRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.DescribeTableOptionsRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.DescribeTableOptionsRequest} DescribeTableOptionsRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DescribeTableOptionsRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DescribeTableOptionsRequest message.
             * @function verify
             * @memberof Ydb.Table.DescribeTableOptionsRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DescribeTableOptionsRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.operationParams != null && message.hasOwnProperty("operationParams")) {
                    var error = $root.Ydb.Operations.OperationParams.verify(message.operationParams);
                    if (error)
                        return "operationParams." + error;
                }
                return null;
            };

            /**
             * Creates a DescribeTableOptionsRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.DescribeTableOptionsRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.DescribeTableOptionsRequest} DescribeTableOptionsRequest
             */
            DescribeTableOptionsRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.DescribeTableOptionsRequest)
                    return object;
                var message = new $root.Ydb.Table.DescribeTableOptionsRequest();
                if (object.operationParams != null) {
                    if (typeof object.operationParams !== "object")
                        throw TypeError(".Ydb.Table.DescribeTableOptionsRequest.operationParams: object expected");
                    message.operationParams = $root.Ydb.Operations.OperationParams.fromObject(object.operationParams);
                }
                return message;
            };

            /**
             * Creates a plain object from a DescribeTableOptionsRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.DescribeTableOptionsRequest
             * @static
             * @param {Ydb.Table.DescribeTableOptionsRequest} message DescribeTableOptionsRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DescribeTableOptionsRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.operationParams = null;
                if (message.operationParams != null && message.hasOwnProperty("operationParams"))
                    object.operationParams = $root.Ydb.Operations.OperationParams.toObject(message.operationParams, options);
                return object;
            };

            /**
             * Converts this DescribeTableOptionsRequest to JSON.
             * @function toJSON
             * @memberof Ydb.Table.DescribeTableOptionsRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DescribeTableOptionsRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DescribeTableOptionsRequest;
        })();

        Table.DescribeTableOptionsResponse = (function() {

            /**
             * Properties of a DescribeTableOptionsResponse.
             * @memberof Ydb.Table
             * @interface IDescribeTableOptionsResponse
             * @property {Ydb.Operations.IOperation|null} [operation] DescribeTableOptionsResponse operation
             */

            /**
             * Constructs a new DescribeTableOptionsResponse.
             * @memberof Ydb.Table
             * @classdesc Represents a DescribeTableOptionsResponse.
             * @implements IDescribeTableOptionsResponse
             * @constructor
             * @param {Ydb.Table.IDescribeTableOptionsResponse=} [properties] Properties to set
             */
            function DescribeTableOptionsResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DescribeTableOptionsResponse operation.
             * @member {Ydb.Operations.IOperation|null|undefined} operation
             * @memberof Ydb.Table.DescribeTableOptionsResponse
             * @instance
             */
            DescribeTableOptionsResponse.prototype.operation = null;

            /**
             * Creates a new DescribeTableOptionsResponse instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.DescribeTableOptionsResponse
             * @static
             * @param {Ydb.Table.IDescribeTableOptionsResponse=} [properties] Properties to set
             * @returns {Ydb.Table.DescribeTableOptionsResponse} DescribeTableOptionsResponse instance
             */
            DescribeTableOptionsResponse.create = function create(properties) {
                return new DescribeTableOptionsResponse(properties);
            };

            /**
             * Encodes the specified DescribeTableOptionsResponse message. Does not implicitly {@link Ydb.Table.DescribeTableOptionsResponse.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.DescribeTableOptionsResponse
             * @static
             * @param {Ydb.Table.IDescribeTableOptionsResponse} message DescribeTableOptionsResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DescribeTableOptionsResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.operation != null && Object.hasOwnProperty.call(message, "operation"))
                    $root.Ydb.Operations.Operation.encode(message.operation, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified DescribeTableOptionsResponse message, length delimited. Does not implicitly {@link Ydb.Table.DescribeTableOptionsResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.DescribeTableOptionsResponse
             * @static
             * @param {Ydb.Table.IDescribeTableOptionsResponse} message DescribeTableOptionsResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DescribeTableOptionsResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DescribeTableOptionsResponse message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.DescribeTableOptionsResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.DescribeTableOptionsResponse} DescribeTableOptionsResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DescribeTableOptionsResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.DescribeTableOptionsResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.operation = $root.Ydb.Operations.Operation.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DescribeTableOptionsResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.DescribeTableOptionsResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.DescribeTableOptionsResponse} DescribeTableOptionsResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DescribeTableOptionsResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DescribeTableOptionsResponse message.
             * @function verify
             * @memberof Ydb.Table.DescribeTableOptionsResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DescribeTableOptionsResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.operation != null && message.hasOwnProperty("operation")) {
                    var error = $root.Ydb.Operations.Operation.verify(message.operation);
                    if (error)
                        return "operation." + error;
                }
                return null;
            };

            /**
             * Creates a DescribeTableOptionsResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.DescribeTableOptionsResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.DescribeTableOptionsResponse} DescribeTableOptionsResponse
             */
            DescribeTableOptionsResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.DescribeTableOptionsResponse)
                    return object;
                var message = new $root.Ydb.Table.DescribeTableOptionsResponse();
                if (object.operation != null) {
                    if (typeof object.operation !== "object")
                        throw TypeError(".Ydb.Table.DescribeTableOptionsResponse.operation: object expected");
                    message.operation = $root.Ydb.Operations.Operation.fromObject(object.operation);
                }
                return message;
            };

            /**
             * Creates a plain object from a DescribeTableOptionsResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.DescribeTableOptionsResponse
             * @static
             * @param {Ydb.Table.DescribeTableOptionsResponse} message DescribeTableOptionsResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DescribeTableOptionsResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.operation = null;
                if (message.operation != null && message.hasOwnProperty("operation"))
                    object.operation = $root.Ydb.Operations.Operation.toObject(message.operation, options);
                return object;
            };

            /**
             * Converts this DescribeTableOptionsResponse to JSON.
             * @function toJSON
             * @memberof Ydb.Table.DescribeTableOptionsResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DescribeTableOptionsResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DescribeTableOptionsResponse;
        })();

        Table.DescribeTableOptionsResult = (function() {

            /**
             * Properties of a DescribeTableOptionsResult.
             * @memberof Ydb.Table
             * @interface IDescribeTableOptionsResult
             * @property {Array.<Ydb.Table.ITableProfileDescription>|null} [tableProfilePresets] DescribeTableOptionsResult tableProfilePresets
             * @property {Array.<Ydb.Table.IStoragePolicyDescription>|null} [storagePolicyPresets] DescribeTableOptionsResult storagePolicyPresets
             * @property {Array.<Ydb.Table.ICompactionPolicyDescription>|null} [compactionPolicyPresets] DescribeTableOptionsResult compactionPolicyPresets
             * @property {Array.<Ydb.Table.IPartitioningPolicyDescription>|null} [partitioningPolicyPresets] DescribeTableOptionsResult partitioningPolicyPresets
             * @property {Array.<Ydb.Table.IExecutionPolicyDescription>|null} [executionPolicyPresets] DescribeTableOptionsResult executionPolicyPresets
             * @property {Array.<Ydb.Table.IReplicationPolicyDescription>|null} [replicationPolicyPresets] DescribeTableOptionsResult replicationPolicyPresets
             * @property {Array.<Ydb.Table.ICachingPolicyDescription>|null} [cachingPolicyPresets] DescribeTableOptionsResult cachingPolicyPresets
             */

            /**
             * Constructs a new DescribeTableOptionsResult.
             * @memberof Ydb.Table
             * @classdesc Represents a DescribeTableOptionsResult.
             * @implements IDescribeTableOptionsResult
             * @constructor
             * @param {Ydb.Table.IDescribeTableOptionsResult=} [properties] Properties to set
             */
            function DescribeTableOptionsResult(properties) {
                this.tableProfilePresets = [];
                this.storagePolicyPresets = [];
                this.compactionPolicyPresets = [];
                this.partitioningPolicyPresets = [];
                this.executionPolicyPresets = [];
                this.replicationPolicyPresets = [];
                this.cachingPolicyPresets = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DescribeTableOptionsResult tableProfilePresets.
             * @member {Array.<Ydb.Table.ITableProfileDescription>} tableProfilePresets
             * @memberof Ydb.Table.DescribeTableOptionsResult
             * @instance
             */
            DescribeTableOptionsResult.prototype.tableProfilePresets = $util.emptyArray;

            /**
             * DescribeTableOptionsResult storagePolicyPresets.
             * @member {Array.<Ydb.Table.IStoragePolicyDescription>} storagePolicyPresets
             * @memberof Ydb.Table.DescribeTableOptionsResult
             * @instance
             */
            DescribeTableOptionsResult.prototype.storagePolicyPresets = $util.emptyArray;

            /**
             * DescribeTableOptionsResult compactionPolicyPresets.
             * @member {Array.<Ydb.Table.ICompactionPolicyDescription>} compactionPolicyPresets
             * @memberof Ydb.Table.DescribeTableOptionsResult
             * @instance
             */
            DescribeTableOptionsResult.prototype.compactionPolicyPresets = $util.emptyArray;

            /**
             * DescribeTableOptionsResult partitioningPolicyPresets.
             * @member {Array.<Ydb.Table.IPartitioningPolicyDescription>} partitioningPolicyPresets
             * @memberof Ydb.Table.DescribeTableOptionsResult
             * @instance
             */
            DescribeTableOptionsResult.prototype.partitioningPolicyPresets = $util.emptyArray;

            /**
             * DescribeTableOptionsResult executionPolicyPresets.
             * @member {Array.<Ydb.Table.IExecutionPolicyDescription>} executionPolicyPresets
             * @memberof Ydb.Table.DescribeTableOptionsResult
             * @instance
             */
            DescribeTableOptionsResult.prototype.executionPolicyPresets = $util.emptyArray;

            /**
             * DescribeTableOptionsResult replicationPolicyPresets.
             * @member {Array.<Ydb.Table.IReplicationPolicyDescription>} replicationPolicyPresets
             * @memberof Ydb.Table.DescribeTableOptionsResult
             * @instance
             */
            DescribeTableOptionsResult.prototype.replicationPolicyPresets = $util.emptyArray;

            /**
             * DescribeTableOptionsResult cachingPolicyPresets.
             * @member {Array.<Ydb.Table.ICachingPolicyDescription>} cachingPolicyPresets
             * @memberof Ydb.Table.DescribeTableOptionsResult
             * @instance
             */
            DescribeTableOptionsResult.prototype.cachingPolicyPresets = $util.emptyArray;

            /**
             * Creates a new DescribeTableOptionsResult instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.DescribeTableOptionsResult
             * @static
             * @param {Ydb.Table.IDescribeTableOptionsResult=} [properties] Properties to set
             * @returns {Ydb.Table.DescribeTableOptionsResult} DescribeTableOptionsResult instance
             */
            DescribeTableOptionsResult.create = function create(properties) {
                return new DescribeTableOptionsResult(properties);
            };

            /**
             * Encodes the specified DescribeTableOptionsResult message. Does not implicitly {@link Ydb.Table.DescribeTableOptionsResult.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.DescribeTableOptionsResult
             * @static
             * @param {Ydb.Table.IDescribeTableOptionsResult} message DescribeTableOptionsResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DescribeTableOptionsResult.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.tableProfilePresets != null && message.tableProfilePresets.length)
                    for (var i = 0; i < message.tableProfilePresets.length; ++i)
                        $root.Ydb.Table.TableProfileDescription.encode(message.tableProfilePresets[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.storagePolicyPresets != null && message.storagePolicyPresets.length)
                    for (var i = 0; i < message.storagePolicyPresets.length; ++i)
                        $root.Ydb.Table.StoragePolicyDescription.encode(message.storagePolicyPresets[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.compactionPolicyPresets != null && message.compactionPolicyPresets.length)
                    for (var i = 0; i < message.compactionPolicyPresets.length; ++i)
                        $root.Ydb.Table.CompactionPolicyDescription.encode(message.compactionPolicyPresets[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.partitioningPolicyPresets != null && message.partitioningPolicyPresets.length)
                    for (var i = 0; i < message.partitioningPolicyPresets.length; ++i)
                        $root.Ydb.Table.PartitioningPolicyDescription.encode(message.partitioningPolicyPresets[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.executionPolicyPresets != null && message.executionPolicyPresets.length)
                    for (var i = 0; i < message.executionPolicyPresets.length; ++i)
                        $root.Ydb.Table.ExecutionPolicyDescription.encode(message.executionPolicyPresets[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.replicationPolicyPresets != null && message.replicationPolicyPresets.length)
                    for (var i = 0; i < message.replicationPolicyPresets.length; ++i)
                        $root.Ydb.Table.ReplicationPolicyDescription.encode(message.replicationPolicyPresets[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.cachingPolicyPresets != null && message.cachingPolicyPresets.length)
                    for (var i = 0; i < message.cachingPolicyPresets.length; ++i)
                        $root.Ydb.Table.CachingPolicyDescription.encode(message.cachingPolicyPresets[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified DescribeTableOptionsResult message, length delimited. Does not implicitly {@link Ydb.Table.DescribeTableOptionsResult.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.DescribeTableOptionsResult
             * @static
             * @param {Ydb.Table.IDescribeTableOptionsResult} message DescribeTableOptionsResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DescribeTableOptionsResult.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DescribeTableOptionsResult message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.DescribeTableOptionsResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.DescribeTableOptionsResult} DescribeTableOptionsResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DescribeTableOptionsResult.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.DescribeTableOptionsResult();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.tableProfilePresets && message.tableProfilePresets.length))
                            message.tableProfilePresets = [];
                        message.tableProfilePresets.push($root.Ydb.Table.TableProfileDescription.decode(reader, reader.uint32()));
                        break;
                    case 2:
                        if (!(message.storagePolicyPresets && message.storagePolicyPresets.length))
                            message.storagePolicyPresets = [];
                        message.storagePolicyPresets.push($root.Ydb.Table.StoragePolicyDescription.decode(reader, reader.uint32()));
                        break;
                    case 3:
                        if (!(message.compactionPolicyPresets && message.compactionPolicyPresets.length))
                            message.compactionPolicyPresets = [];
                        message.compactionPolicyPresets.push($root.Ydb.Table.CompactionPolicyDescription.decode(reader, reader.uint32()));
                        break;
                    case 4:
                        if (!(message.partitioningPolicyPresets && message.partitioningPolicyPresets.length))
                            message.partitioningPolicyPresets = [];
                        message.partitioningPolicyPresets.push($root.Ydb.Table.PartitioningPolicyDescription.decode(reader, reader.uint32()));
                        break;
                    case 5:
                        if (!(message.executionPolicyPresets && message.executionPolicyPresets.length))
                            message.executionPolicyPresets = [];
                        message.executionPolicyPresets.push($root.Ydb.Table.ExecutionPolicyDescription.decode(reader, reader.uint32()));
                        break;
                    case 6:
                        if (!(message.replicationPolicyPresets && message.replicationPolicyPresets.length))
                            message.replicationPolicyPresets = [];
                        message.replicationPolicyPresets.push($root.Ydb.Table.ReplicationPolicyDescription.decode(reader, reader.uint32()));
                        break;
                    case 7:
                        if (!(message.cachingPolicyPresets && message.cachingPolicyPresets.length))
                            message.cachingPolicyPresets = [];
                        message.cachingPolicyPresets.push($root.Ydb.Table.CachingPolicyDescription.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DescribeTableOptionsResult message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.DescribeTableOptionsResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.DescribeTableOptionsResult} DescribeTableOptionsResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DescribeTableOptionsResult.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DescribeTableOptionsResult message.
             * @function verify
             * @memberof Ydb.Table.DescribeTableOptionsResult
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DescribeTableOptionsResult.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.tableProfilePresets != null && message.hasOwnProperty("tableProfilePresets")) {
                    if (!Array.isArray(message.tableProfilePresets))
                        return "tableProfilePresets: array expected";
                    for (var i = 0; i < message.tableProfilePresets.length; ++i) {
                        var error = $root.Ydb.Table.TableProfileDescription.verify(message.tableProfilePresets[i]);
                        if (error)
                            return "tableProfilePresets." + error;
                    }
                }
                if (message.storagePolicyPresets != null && message.hasOwnProperty("storagePolicyPresets")) {
                    if (!Array.isArray(message.storagePolicyPresets))
                        return "storagePolicyPresets: array expected";
                    for (var i = 0; i < message.storagePolicyPresets.length; ++i) {
                        var error = $root.Ydb.Table.StoragePolicyDescription.verify(message.storagePolicyPresets[i]);
                        if (error)
                            return "storagePolicyPresets." + error;
                    }
                }
                if (message.compactionPolicyPresets != null && message.hasOwnProperty("compactionPolicyPresets")) {
                    if (!Array.isArray(message.compactionPolicyPresets))
                        return "compactionPolicyPresets: array expected";
                    for (var i = 0; i < message.compactionPolicyPresets.length; ++i) {
                        var error = $root.Ydb.Table.CompactionPolicyDescription.verify(message.compactionPolicyPresets[i]);
                        if (error)
                            return "compactionPolicyPresets." + error;
                    }
                }
                if (message.partitioningPolicyPresets != null && message.hasOwnProperty("partitioningPolicyPresets")) {
                    if (!Array.isArray(message.partitioningPolicyPresets))
                        return "partitioningPolicyPresets: array expected";
                    for (var i = 0; i < message.partitioningPolicyPresets.length; ++i) {
                        var error = $root.Ydb.Table.PartitioningPolicyDescription.verify(message.partitioningPolicyPresets[i]);
                        if (error)
                            return "partitioningPolicyPresets." + error;
                    }
                }
                if (message.executionPolicyPresets != null && message.hasOwnProperty("executionPolicyPresets")) {
                    if (!Array.isArray(message.executionPolicyPresets))
                        return "executionPolicyPresets: array expected";
                    for (var i = 0; i < message.executionPolicyPresets.length; ++i) {
                        var error = $root.Ydb.Table.ExecutionPolicyDescription.verify(message.executionPolicyPresets[i]);
                        if (error)
                            return "executionPolicyPresets." + error;
                    }
                }
                if (message.replicationPolicyPresets != null && message.hasOwnProperty("replicationPolicyPresets")) {
                    if (!Array.isArray(message.replicationPolicyPresets))
                        return "replicationPolicyPresets: array expected";
                    for (var i = 0; i < message.replicationPolicyPresets.length; ++i) {
                        var error = $root.Ydb.Table.ReplicationPolicyDescription.verify(message.replicationPolicyPresets[i]);
                        if (error)
                            return "replicationPolicyPresets." + error;
                    }
                }
                if (message.cachingPolicyPresets != null && message.hasOwnProperty("cachingPolicyPresets")) {
                    if (!Array.isArray(message.cachingPolicyPresets))
                        return "cachingPolicyPresets: array expected";
                    for (var i = 0; i < message.cachingPolicyPresets.length; ++i) {
                        var error = $root.Ydb.Table.CachingPolicyDescription.verify(message.cachingPolicyPresets[i]);
                        if (error)
                            return "cachingPolicyPresets." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a DescribeTableOptionsResult message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.DescribeTableOptionsResult
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.DescribeTableOptionsResult} DescribeTableOptionsResult
             */
            DescribeTableOptionsResult.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.DescribeTableOptionsResult)
                    return object;
                var message = new $root.Ydb.Table.DescribeTableOptionsResult();
                if (object.tableProfilePresets) {
                    if (!Array.isArray(object.tableProfilePresets))
                        throw TypeError(".Ydb.Table.DescribeTableOptionsResult.tableProfilePresets: array expected");
                    message.tableProfilePresets = [];
                    for (var i = 0; i < object.tableProfilePresets.length; ++i) {
                        if (typeof object.tableProfilePresets[i] !== "object")
                            throw TypeError(".Ydb.Table.DescribeTableOptionsResult.tableProfilePresets: object expected");
                        message.tableProfilePresets[i] = $root.Ydb.Table.TableProfileDescription.fromObject(object.tableProfilePresets[i]);
                    }
                }
                if (object.storagePolicyPresets) {
                    if (!Array.isArray(object.storagePolicyPresets))
                        throw TypeError(".Ydb.Table.DescribeTableOptionsResult.storagePolicyPresets: array expected");
                    message.storagePolicyPresets = [];
                    for (var i = 0; i < object.storagePolicyPresets.length; ++i) {
                        if (typeof object.storagePolicyPresets[i] !== "object")
                            throw TypeError(".Ydb.Table.DescribeTableOptionsResult.storagePolicyPresets: object expected");
                        message.storagePolicyPresets[i] = $root.Ydb.Table.StoragePolicyDescription.fromObject(object.storagePolicyPresets[i]);
                    }
                }
                if (object.compactionPolicyPresets) {
                    if (!Array.isArray(object.compactionPolicyPresets))
                        throw TypeError(".Ydb.Table.DescribeTableOptionsResult.compactionPolicyPresets: array expected");
                    message.compactionPolicyPresets = [];
                    for (var i = 0; i < object.compactionPolicyPresets.length; ++i) {
                        if (typeof object.compactionPolicyPresets[i] !== "object")
                            throw TypeError(".Ydb.Table.DescribeTableOptionsResult.compactionPolicyPresets: object expected");
                        message.compactionPolicyPresets[i] = $root.Ydb.Table.CompactionPolicyDescription.fromObject(object.compactionPolicyPresets[i]);
                    }
                }
                if (object.partitioningPolicyPresets) {
                    if (!Array.isArray(object.partitioningPolicyPresets))
                        throw TypeError(".Ydb.Table.DescribeTableOptionsResult.partitioningPolicyPresets: array expected");
                    message.partitioningPolicyPresets = [];
                    for (var i = 0; i < object.partitioningPolicyPresets.length; ++i) {
                        if (typeof object.partitioningPolicyPresets[i] !== "object")
                            throw TypeError(".Ydb.Table.DescribeTableOptionsResult.partitioningPolicyPresets: object expected");
                        message.partitioningPolicyPresets[i] = $root.Ydb.Table.PartitioningPolicyDescription.fromObject(object.partitioningPolicyPresets[i]);
                    }
                }
                if (object.executionPolicyPresets) {
                    if (!Array.isArray(object.executionPolicyPresets))
                        throw TypeError(".Ydb.Table.DescribeTableOptionsResult.executionPolicyPresets: array expected");
                    message.executionPolicyPresets = [];
                    for (var i = 0; i < object.executionPolicyPresets.length; ++i) {
                        if (typeof object.executionPolicyPresets[i] !== "object")
                            throw TypeError(".Ydb.Table.DescribeTableOptionsResult.executionPolicyPresets: object expected");
                        message.executionPolicyPresets[i] = $root.Ydb.Table.ExecutionPolicyDescription.fromObject(object.executionPolicyPresets[i]);
                    }
                }
                if (object.replicationPolicyPresets) {
                    if (!Array.isArray(object.replicationPolicyPresets))
                        throw TypeError(".Ydb.Table.DescribeTableOptionsResult.replicationPolicyPresets: array expected");
                    message.replicationPolicyPresets = [];
                    for (var i = 0; i < object.replicationPolicyPresets.length; ++i) {
                        if (typeof object.replicationPolicyPresets[i] !== "object")
                            throw TypeError(".Ydb.Table.DescribeTableOptionsResult.replicationPolicyPresets: object expected");
                        message.replicationPolicyPresets[i] = $root.Ydb.Table.ReplicationPolicyDescription.fromObject(object.replicationPolicyPresets[i]);
                    }
                }
                if (object.cachingPolicyPresets) {
                    if (!Array.isArray(object.cachingPolicyPresets))
                        throw TypeError(".Ydb.Table.DescribeTableOptionsResult.cachingPolicyPresets: array expected");
                    message.cachingPolicyPresets = [];
                    for (var i = 0; i < object.cachingPolicyPresets.length; ++i) {
                        if (typeof object.cachingPolicyPresets[i] !== "object")
                            throw TypeError(".Ydb.Table.DescribeTableOptionsResult.cachingPolicyPresets: object expected");
                        message.cachingPolicyPresets[i] = $root.Ydb.Table.CachingPolicyDescription.fromObject(object.cachingPolicyPresets[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a DescribeTableOptionsResult message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.DescribeTableOptionsResult
             * @static
             * @param {Ydb.Table.DescribeTableOptionsResult} message DescribeTableOptionsResult
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DescribeTableOptionsResult.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.tableProfilePresets = [];
                    object.storagePolicyPresets = [];
                    object.compactionPolicyPresets = [];
                    object.partitioningPolicyPresets = [];
                    object.executionPolicyPresets = [];
                    object.replicationPolicyPresets = [];
                    object.cachingPolicyPresets = [];
                }
                if (message.tableProfilePresets && message.tableProfilePresets.length) {
                    object.tableProfilePresets = [];
                    for (var j = 0; j < message.tableProfilePresets.length; ++j)
                        object.tableProfilePresets[j] = $root.Ydb.Table.TableProfileDescription.toObject(message.tableProfilePresets[j], options);
                }
                if (message.storagePolicyPresets && message.storagePolicyPresets.length) {
                    object.storagePolicyPresets = [];
                    for (var j = 0; j < message.storagePolicyPresets.length; ++j)
                        object.storagePolicyPresets[j] = $root.Ydb.Table.StoragePolicyDescription.toObject(message.storagePolicyPresets[j], options);
                }
                if (message.compactionPolicyPresets && message.compactionPolicyPresets.length) {
                    object.compactionPolicyPresets = [];
                    for (var j = 0; j < message.compactionPolicyPresets.length; ++j)
                        object.compactionPolicyPresets[j] = $root.Ydb.Table.CompactionPolicyDescription.toObject(message.compactionPolicyPresets[j], options);
                }
                if (message.partitioningPolicyPresets && message.partitioningPolicyPresets.length) {
                    object.partitioningPolicyPresets = [];
                    for (var j = 0; j < message.partitioningPolicyPresets.length; ++j)
                        object.partitioningPolicyPresets[j] = $root.Ydb.Table.PartitioningPolicyDescription.toObject(message.partitioningPolicyPresets[j], options);
                }
                if (message.executionPolicyPresets && message.executionPolicyPresets.length) {
                    object.executionPolicyPresets = [];
                    for (var j = 0; j < message.executionPolicyPresets.length; ++j)
                        object.executionPolicyPresets[j] = $root.Ydb.Table.ExecutionPolicyDescription.toObject(message.executionPolicyPresets[j], options);
                }
                if (message.replicationPolicyPresets && message.replicationPolicyPresets.length) {
                    object.replicationPolicyPresets = [];
                    for (var j = 0; j < message.replicationPolicyPresets.length; ++j)
                        object.replicationPolicyPresets[j] = $root.Ydb.Table.ReplicationPolicyDescription.toObject(message.replicationPolicyPresets[j], options);
                }
                if (message.cachingPolicyPresets && message.cachingPolicyPresets.length) {
                    object.cachingPolicyPresets = [];
                    for (var j = 0; j < message.cachingPolicyPresets.length; ++j)
                        object.cachingPolicyPresets[j] = $root.Ydb.Table.CachingPolicyDescription.toObject(message.cachingPolicyPresets[j], options);
                }
                return object;
            };

            /**
             * Converts this DescribeTableOptionsResult to JSON.
             * @function toJSON
             * @memberof Ydb.Table.DescribeTableOptionsResult
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DescribeTableOptionsResult.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DescribeTableOptionsResult;
        })();

        Table.KeyRange = (function() {

            /**
             * Properties of a KeyRange.
             * @memberof Ydb.Table
             * @interface IKeyRange
             * @property {Ydb.ITypedValue|null} [greater] KeyRange greater
             * @property {Ydb.ITypedValue|null} [greaterOrEqual] KeyRange greaterOrEqual
             * @property {Ydb.ITypedValue|null} [less] KeyRange less
             * @property {Ydb.ITypedValue|null} [lessOrEqual] KeyRange lessOrEqual
             */

            /**
             * Constructs a new KeyRange.
             * @memberof Ydb.Table
             * @classdesc Represents a KeyRange.
             * @implements IKeyRange
             * @constructor
             * @param {Ydb.Table.IKeyRange=} [properties] Properties to set
             */
            function KeyRange(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * KeyRange greater.
             * @member {Ydb.ITypedValue|null|undefined} greater
             * @memberof Ydb.Table.KeyRange
             * @instance
             */
            KeyRange.prototype.greater = null;

            /**
             * KeyRange greaterOrEqual.
             * @member {Ydb.ITypedValue|null|undefined} greaterOrEqual
             * @memberof Ydb.Table.KeyRange
             * @instance
             */
            KeyRange.prototype.greaterOrEqual = null;

            /**
             * KeyRange less.
             * @member {Ydb.ITypedValue|null|undefined} less
             * @memberof Ydb.Table.KeyRange
             * @instance
             */
            KeyRange.prototype.less = null;

            /**
             * KeyRange lessOrEqual.
             * @member {Ydb.ITypedValue|null|undefined} lessOrEqual
             * @memberof Ydb.Table.KeyRange
             * @instance
             */
            KeyRange.prototype.lessOrEqual = null;

            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;

            /**
             * KeyRange fromBound.
             * @member {"greater"|"greaterOrEqual"|undefined} fromBound
             * @memberof Ydb.Table.KeyRange
             * @instance
             */
            Object.defineProperty(KeyRange.prototype, "fromBound", {
                get: $util.oneOfGetter($oneOfFields = ["greater", "greaterOrEqual"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * KeyRange toBound.
             * @member {"less"|"lessOrEqual"|undefined} toBound
             * @memberof Ydb.Table.KeyRange
             * @instance
             */
            Object.defineProperty(KeyRange.prototype, "toBound", {
                get: $util.oneOfGetter($oneOfFields = ["less", "lessOrEqual"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new KeyRange instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.KeyRange
             * @static
             * @param {Ydb.Table.IKeyRange=} [properties] Properties to set
             * @returns {Ydb.Table.KeyRange} KeyRange instance
             */
            KeyRange.create = function create(properties) {
                return new KeyRange(properties);
            };

            /**
             * Encodes the specified KeyRange message. Does not implicitly {@link Ydb.Table.KeyRange.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.KeyRange
             * @static
             * @param {Ydb.Table.IKeyRange} message KeyRange message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KeyRange.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.greater != null && Object.hasOwnProperty.call(message, "greater"))
                    $root.Ydb.TypedValue.encode(message.greater, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.greaterOrEqual != null && Object.hasOwnProperty.call(message, "greaterOrEqual"))
                    $root.Ydb.TypedValue.encode(message.greaterOrEqual, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.less != null && Object.hasOwnProperty.call(message, "less"))
                    $root.Ydb.TypedValue.encode(message.less, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.lessOrEqual != null && Object.hasOwnProperty.call(message, "lessOrEqual"))
                    $root.Ydb.TypedValue.encode(message.lessOrEqual, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified KeyRange message, length delimited. Does not implicitly {@link Ydb.Table.KeyRange.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.KeyRange
             * @static
             * @param {Ydb.Table.IKeyRange} message KeyRange message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KeyRange.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a KeyRange message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.KeyRange
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.KeyRange} KeyRange
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KeyRange.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.KeyRange();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.greater = $root.Ydb.TypedValue.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.greaterOrEqual = $root.Ydb.TypedValue.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.less = $root.Ydb.TypedValue.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.lessOrEqual = $root.Ydb.TypedValue.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a KeyRange message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.KeyRange
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.KeyRange} KeyRange
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KeyRange.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a KeyRange message.
             * @function verify
             * @memberof Ydb.Table.KeyRange
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            KeyRange.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.greater != null && message.hasOwnProperty("greater")) {
                    properties.fromBound = 1;
                    {
                        var error = $root.Ydb.TypedValue.verify(message.greater);
                        if (error)
                            return "greater." + error;
                    }
                }
                if (message.greaterOrEqual != null && message.hasOwnProperty("greaterOrEqual")) {
                    if (properties.fromBound === 1)
                        return "fromBound: multiple values";
                    properties.fromBound = 1;
                    {
                        var error = $root.Ydb.TypedValue.verify(message.greaterOrEqual);
                        if (error)
                            return "greaterOrEqual." + error;
                    }
                }
                if (message.less != null && message.hasOwnProperty("less")) {
                    properties.toBound = 1;
                    {
                        var error = $root.Ydb.TypedValue.verify(message.less);
                        if (error)
                            return "less." + error;
                    }
                }
                if (message.lessOrEqual != null && message.hasOwnProperty("lessOrEqual")) {
                    if (properties.toBound === 1)
                        return "toBound: multiple values";
                    properties.toBound = 1;
                    {
                        var error = $root.Ydb.TypedValue.verify(message.lessOrEqual);
                        if (error)
                            return "lessOrEqual." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a KeyRange message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.KeyRange
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.KeyRange} KeyRange
             */
            KeyRange.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.KeyRange)
                    return object;
                var message = new $root.Ydb.Table.KeyRange();
                if (object.greater != null) {
                    if (typeof object.greater !== "object")
                        throw TypeError(".Ydb.Table.KeyRange.greater: object expected");
                    message.greater = $root.Ydb.TypedValue.fromObject(object.greater);
                }
                if (object.greaterOrEqual != null) {
                    if (typeof object.greaterOrEqual !== "object")
                        throw TypeError(".Ydb.Table.KeyRange.greaterOrEqual: object expected");
                    message.greaterOrEqual = $root.Ydb.TypedValue.fromObject(object.greaterOrEqual);
                }
                if (object.less != null) {
                    if (typeof object.less !== "object")
                        throw TypeError(".Ydb.Table.KeyRange.less: object expected");
                    message.less = $root.Ydb.TypedValue.fromObject(object.less);
                }
                if (object.lessOrEqual != null) {
                    if (typeof object.lessOrEqual !== "object")
                        throw TypeError(".Ydb.Table.KeyRange.lessOrEqual: object expected");
                    message.lessOrEqual = $root.Ydb.TypedValue.fromObject(object.lessOrEqual);
                }
                return message;
            };

            /**
             * Creates a plain object from a KeyRange message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.KeyRange
             * @static
             * @param {Ydb.Table.KeyRange} message KeyRange
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            KeyRange.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (message.greater != null && message.hasOwnProperty("greater")) {
                    object.greater = $root.Ydb.TypedValue.toObject(message.greater, options);
                    if (options.oneofs)
                        object.fromBound = "greater";
                }
                if (message.greaterOrEqual != null && message.hasOwnProperty("greaterOrEqual")) {
                    object.greaterOrEqual = $root.Ydb.TypedValue.toObject(message.greaterOrEqual, options);
                    if (options.oneofs)
                        object.fromBound = "greaterOrEqual";
                }
                if (message.less != null && message.hasOwnProperty("less")) {
                    object.less = $root.Ydb.TypedValue.toObject(message.less, options);
                    if (options.oneofs)
                        object.toBound = "less";
                }
                if (message.lessOrEqual != null && message.hasOwnProperty("lessOrEqual")) {
                    object.lessOrEqual = $root.Ydb.TypedValue.toObject(message.lessOrEqual, options);
                    if (options.oneofs)
                        object.toBound = "lessOrEqual";
                }
                return object;
            };

            /**
             * Converts this KeyRange to JSON.
             * @function toJSON
             * @memberof Ydb.Table.KeyRange
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            KeyRange.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return KeyRange;
        })();

        Table.ReadTableRequest = (function() {

            /**
             * Properties of a ReadTableRequest.
             * @memberof Ydb.Table
             * @interface IReadTableRequest
             * @property {string|null} [sessionId] ReadTableRequest sessionId
             * @property {string|null} [path] ReadTableRequest path
             * @property {Ydb.Table.IKeyRange|null} [keyRange] ReadTableRequest keyRange
             * @property {Array.<string>|null} [columns] ReadTableRequest columns
             * @property {boolean|null} [ordered] ReadTableRequest ordered
             * @property {number|Long|null} [rowLimit] ReadTableRequest rowLimit
             * @property {Ydb.FeatureFlag.Status|null} [useSnapshot] ReadTableRequest useSnapshot
             */

            /**
             * Constructs a new ReadTableRequest.
             * @memberof Ydb.Table
             * @classdesc Represents a ReadTableRequest.
             * @implements IReadTableRequest
             * @constructor
             * @param {Ydb.Table.IReadTableRequest=} [properties] Properties to set
             */
            function ReadTableRequest(properties) {
                this.columns = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ReadTableRequest sessionId.
             * @member {string} sessionId
             * @memberof Ydb.Table.ReadTableRequest
             * @instance
             */
            ReadTableRequest.prototype.sessionId = "";

            /**
             * ReadTableRequest path.
             * @member {string} path
             * @memberof Ydb.Table.ReadTableRequest
             * @instance
             */
            ReadTableRequest.prototype.path = "";

            /**
             * ReadTableRequest keyRange.
             * @member {Ydb.Table.IKeyRange|null|undefined} keyRange
             * @memberof Ydb.Table.ReadTableRequest
             * @instance
             */
            ReadTableRequest.prototype.keyRange = null;

            /**
             * ReadTableRequest columns.
             * @member {Array.<string>} columns
             * @memberof Ydb.Table.ReadTableRequest
             * @instance
             */
            ReadTableRequest.prototype.columns = $util.emptyArray;

            /**
             * ReadTableRequest ordered.
             * @member {boolean} ordered
             * @memberof Ydb.Table.ReadTableRequest
             * @instance
             */
            ReadTableRequest.prototype.ordered = false;

            /**
             * ReadTableRequest rowLimit.
             * @member {number|Long} rowLimit
             * @memberof Ydb.Table.ReadTableRequest
             * @instance
             */
            ReadTableRequest.prototype.rowLimit = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * ReadTableRequest useSnapshot.
             * @member {Ydb.FeatureFlag.Status} useSnapshot
             * @memberof Ydb.Table.ReadTableRequest
             * @instance
             */
            ReadTableRequest.prototype.useSnapshot = 0;

            /**
             * Creates a new ReadTableRequest instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.ReadTableRequest
             * @static
             * @param {Ydb.Table.IReadTableRequest=} [properties] Properties to set
             * @returns {Ydb.Table.ReadTableRequest} ReadTableRequest instance
             */
            ReadTableRequest.create = function create(properties) {
                return new ReadTableRequest(properties);
            };

            /**
             * Encodes the specified ReadTableRequest message. Does not implicitly {@link Ydb.Table.ReadTableRequest.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.ReadTableRequest
             * @static
             * @param {Ydb.Table.IReadTableRequest} message ReadTableRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadTableRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.sessionId != null && Object.hasOwnProperty.call(message, "sessionId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.sessionId);
                if (message.path != null && Object.hasOwnProperty.call(message, "path"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.path);
                if (message.keyRange != null && Object.hasOwnProperty.call(message, "keyRange"))
                    $root.Ydb.Table.KeyRange.encode(message.keyRange, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.columns != null && message.columns.length)
                    for (var i = 0; i < message.columns.length; ++i)
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.columns[i]);
                if (message.ordered != null && Object.hasOwnProperty.call(message, "ordered"))
                    writer.uint32(/* id 5, wireType 0 =*/40).bool(message.ordered);
                if (message.rowLimit != null && Object.hasOwnProperty.call(message, "rowLimit"))
                    writer.uint32(/* id 6, wireType 0 =*/48).uint64(message.rowLimit);
                if (message.useSnapshot != null && Object.hasOwnProperty.call(message, "useSnapshot"))
                    writer.uint32(/* id 7, wireType 0 =*/56).int32(message.useSnapshot);
                return writer;
            };

            /**
             * Encodes the specified ReadTableRequest message, length delimited. Does not implicitly {@link Ydb.Table.ReadTableRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.ReadTableRequest
             * @static
             * @param {Ydb.Table.IReadTableRequest} message ReadTableRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadTableRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReadTableRequest message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.ReadTableRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.ReadTableRequest} ReadTableRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadTableRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.ReadTableRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.sessionId = reader.string();
                        break;
                    case 2:
                        message.path = reader.string();
                        break;
                    case 3:
                        message.keyRange = $root.Ydb.Table.KeyRange.decode(reader, reader.uint32());
                        break;
                    case 4:
                        if (!(message.columns && message.columns.length))
                            message.columns = [];
                        message.columns.push(reader.string());
                        break;
                    case 5:
                        message.ordered = reader.bool();
                        break;
                    case 6:
                        message.rowLimit = reader.uint64();
                        break;
                    case 7:
                        message.useSnapshot = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ReadTableRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.ReadTableRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.ReadTableRequest} ReadTableRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadTableRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReadTableRequest message.
             * @function verify
             * @memberof Ydb.Table.ReadTableRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReadTableRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.sessionId != null && message.hasOwnProperty("sessionId"))
                    if (!$util.isString(message.sessionId))
                        return "sessionId: string expected";
                if (message.path != null && message.hasOwnProperty("path"))
                    if (!$util.isString(message.path))
                        return "path: string expected";
                if (message.keyRange != null && message.hasOwnProperty("keyRange")) {
                    var error = $root.Ydb.Table.KeyRange.verify(message.keyRange);
                    if (error)
                        return "keyRange." + error;
                }
                if (message.columns != null && message.hasOwnProperty("columns")) {
                    if (!Array.isArray(message.columns))
                        return "columns: array expected";
                    for (var i = 0; i < message.columns.length; ++i)
                        if (!$util.isString(message.columns[i]))
                            return "columns: string[] expected";
                }
                if (message.ordered != null && message.hasOwnProperty("ordered"))
                    if (typeof message.ordered !== "boolean")
                        return "ordered: boolean expected";
                if (message.rowLimit != null && message.hasOwnProperty("rowLimit"))
                    if (!$util.isInteger(message.rowLimit) && !(message.rowLimit && $util.isInteger(message.rowLimit.low) && $util.isInteger(message.rowLimit.high)))
                        return "rowLimit: integer|Long expected";
                if (message.useSnapshot != null && message.hasOwnProperty("useSnapshot"))
                    switch (message.useSnapshot) {
                    default:
                        return "useSnapshot: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                return null;
            };

            /**
             * Creates a ReadTableRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.ReadTableRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.ReadTableRequest} ReadTableRequest
             */
            ReadTableRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.ReadTableRequest)
                    return object;
                var message = new $root.Ydb.Table.ReadTableRequest();
                if (object.sessionId != null)
                    message.sessionId = String(object.sessionId);
                if (object.path != null)
                    message.path = String(object.path);
                if (object.keyRange != null) {
                    if (typeof object.keyRange !== "object")
                        throw TypeError(".Ydb.Table.ReadTableRequest.keyRange: object expected");
                    message.keyRange = $root.Ydb.Table.KeyRange.fromObject(object.keyRange);
                }
                if (object.columns) {
                    if (!Array.isArray(object.columns))
                        throw TypeError(".Ydb.Table.ReadTableRequest.columns: array expected");
                    message.columns = [];
                    for (var i = 0; i < object.columns.length; ++i)
                        message.columns[i] = String(object.columns[i]);
                }
                if (object.ordered != null)
                    message.ordered = Boolean(object.ordered);
                if (object.rowLimit != null)
                    if ($util.Long)
                        (message.rowLimit = $util.Long.fromValue(object.rowLimit)).unsigned = true;
                    else if (typeof object.rowLimit === "string")
                        message.rowLimit = parseInt(object.rowLimit, 10);
                    else if (typeof object.rowLimit === "number")
                        message.rowLimit = object.rowLimit;
                    else if (typeof object.rowLimit === "object")
                        message.rowLimit = new $util.LongBits(object.rowLimit.low >>> 0, object.rowLimit.high >>> 0).toNumber(true);
                switch (object.useSnapshot) {
                case "STATUS_UNSPECIFIED":
                case 0:
                    message.useSnapshot = 0;
                    break;
                case "ENABLED":
                case 1:
                    message.useSnapshot = 1;
                    break;
                case "DISABLED":
                case 2:
                    message.useSnapshot = 2;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from a ReadTableRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.ReadTableRequest
             * @static
             * @param {Ydb.Table.ReadTableRequest} message ReadTableRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReadTableRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.columns = [];
                if (options.defaults) {
                    object.sessionId = "";
                    object.path = "";
                    object.keyRange = null;
                    object.ordered = false;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.rowLimit = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.rowLimit = options.longs === String ? "0" : 0;
                    object.useSnapshot = options.enums === String ? "STATUS_UNSPECIFIED" : 0;
                }
                if (message.sessionId != null && message.hasOwnProperty("sessionId"))
                    object.sessionId = message.sessionId;
                if (message.path != null && message.hasOwnProperty("path"))
                    object.path = message.path;
                if (message.keyRange != null && message.hasOwnProperty("keyRange"))
                    object.keyRange = $root.Ydb.Table.KeyRange.toObject(message.keyRange, options);
                if (message.columns && message.columns.length) {
                    object.columns = [];
                    for (var j = 0; j < message.columns.length; ++j)
                        object.columns[j] = message.columns[j];
                }
                if (message.ordered != null && message.hasOwnProperty("ordered"))
                    object.ordered = message.ordered;
                if (message.rowLimit != null && message.hasOwnProperty("rowLimit"))
                    if (typeof message.rowLimit === "number")
                        object.rowLimit = options.longs === String ? String(message.rowLimit) : message.rowLimit;
                    else
                        object.rowLimit = options.longs === String ? $util.Long.prototype.toString.call(message.rowLimit) : options.longs === Number ? new $util.LongBits(message.rowLimit.low >>> 0, message.rowLimit.high >>> 0).toNumber(true) : message.rowLimit;
                if (message.useSnapshot != null && message.hasOwnProperty("useSnapshot"))
                    object.useSnapshot = options.enums === String ? $root.Ydb.FeatureFlag.Status[message.useSnapshot] : message.useSnapshot;
                return object;
            };

            /**
             * Converts this ReadTableRequest to JSON.
             * @function toJSON
             * @memberof Ydb.Table.ReadTableRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReadTableRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ReadTableRequest;
        })();

        Table.ReadTableResponse = (function() {

            /**
             * Properties of a ReadTableResponse.
             * @memberof Ydb.Table
             * @interface IReadTableResponse
             * @property {Ydb.StatusIds.StatusCode|null} [status] ReadTableResponse status
             * @property {Array.<Ydb.Issue.IIssueMessage>|null} [issues] ReadTableResponse issues
             * @property {Ydb.Table.IReadTableResult|null} [result] ReadTableResponse result
             */

            /**
             * Constructs a new ReadTableResponse.
             * @memberof Ydb.Table
             * @classdesc Represents a ReadTableResponse.
             * @implements IReadTableResponse
             * @constructor
             * @param {Ydb.Table.IReadTableResponse=} [properties] Properties to set
             */
            function ReadTableResponse(properties) {
                this.issues = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ReadTableResponse status.
             * @member {Ydb.StatusIds.StatusCode} status
             * @memberof Ydb.Table.ReadTableResponse
             * @instance
             */
            ReadTableResponse.prototype.status = 0;

            /**
             * ReadTableResponse issues.
             * @member {Array.<Ydb.Issue.IIssueMessage>} issues
             * @memberof Ydb.Table.ReadTableResponse
             * @instance
             */
            ReadTableResponse.prototype.issues = $util.emptyArray;

            /**
             * ReadTableResponse result.
             * @member {Ydb.Table.IReadTableResult|null|undefined} result
             * @memberof Ydb.Table.ReadTableResponse
             * @instance
             */
            ReadTableResponse.prototype.result = null;

            /**
             * Creates a new ReadTableResponse instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.ReadTableResponse
             * @static
             * @param {Ydb.Table.IReadTableResponse=} [properties] Properties to set
             * @returns {Ydb.Table.ReadTableResponse} ReadTableResponse instance
             */
            ReadTableResponse.create = function create(properties) {
                return new ReadTableResponse(properties);
            };

            /**
             * Encodes the specified ReadTableResponse message. Does not implicitly {@link Ydb.Table.ReadTableResponse.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.ReadTableResponse
             * @static
             * @param {Ydb.Table.IReadTableResponse} message ReadTableResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadTableResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.status);
                if (message.issues != null && message.issues.length)
                    for (var i = 0; i < message.issues.length; ++i)
                        $root.Ydb.Issue.IssueMessage.encode(message.issues[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.result != null && Object.hasOwnProperty.call(message, "result"))
                    $root.Ydb.Table.ReadTableResult.encode(message.result, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ReadTableResponse message, length delimited. Does not implicitly {@link Ydb.Table.ReadTableResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.ReadTableResponse
             * @static
             * @param {Ydb.Table.IReadTableResponse} message ReadTableResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadTableResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReadTableResponse message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.ReadTableResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.ReadTableResponse} ReadTableResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadTableResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.ReadTableResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.status = reader.int32();
                        break;
                    case 2:
                        if (!(message.issues && message.issues.length))
                            message.issues = [];
                        message.issues.push($root.Ydb.Issue.IssueMessage.decode(reader, reader.uint32()));
                        break;
                    case 3:
                        message.result = $root.Ydb.Table.ReadTableResult.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ReadTableResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.ReadTableResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.ReadTableResponse} ReadTableResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadTableResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReadTableResponse message.
             * @function verify
             * @memberof Ydb.Table.ReadTableResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReadTableResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.status != null && message.hasOwnProperty("status"))
                    switch (message.status) {
                    default:
                        return "status: enum value expected";
                    case 0:
                    case 400000:
                    case 400010:
                    case 400020:
                    case 400030:
                    case 400040:
                    case 400050:
                    case 400060:
                    case 400070:
                    case 400080:
                    case 400090:
                    case 400100:
                    case 400120:
                    case 400130:
                    case 400140:
                    case 400150:
                    case 400160:
                    case 400170:
                    case 400180:
                    case 400190:
                        break;
                    }
                if (message.issues != null && message.hasOwnProperty("issues")) {
                    if (!Array.isArray(message.issues))
                        return "issues: array expected";
                    for (var i = 0; i < message.issues.length; ++i) {
                        var error = $root.Ydb.Issue.IssueMessage.verify(message.issues[i]);
                        if (error)
                            return "issues." + error;
                    }
                }
                if (message.result != null && message.hasOwnProperty("result")) {
                    var error = $root.Ydb.Table.ReadTableResult.verify(message.result);
                    if (error)
                        return "result." + error;
                }
                return null;
            };

            /**
             * Creates a ReadTableResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.ReadTableResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.ReadTableResponse} ReadTableResponse
             */
            ReadTableResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.ReadTableResponse)
                    return object;
                var message = new $root.Ydb.Table.ReadTableResponse();
                switch (object.status) {
                case "STATUS_CODE_UNSPECIFIED":
                case 0:
                    message.status = 0;
                    break;
                case "SUCCESS":
                case 400000:
                    message.status = 400000;
                    break;
                case "BAD_REQUEST":
                case 400010:
                    message.status = 400010;
                    break;
                case "UNAUTHORIZED":
                case 400020:
                    message.status = 400020;
                    break;
                case "INTERNAL_ERROR":
                case 400030:
                    message.status = 400030;
                    break;
                case "ABORTED":
                case 400040:
                    message.status = 400040;
                    break;
                case "UNAVAILABLE":
                case 400050:
                    message.status = 400050;
                    break;
                case "OVERLOADED":
                case 400060:
                    message.status = 400060;
                    break;
                case "SCHEME_ERROR":
                case 400070:
                    message.status = 400070;
                    break;
                case "GENERIC_ERROR":
                case 400080:
                    message.status = 400080;
                    break;
                case "TIMEOUT":
                case 400090:
                    message.status = 400090;
                    break;
                case "BAD_SESSION":
                case 400100:
                    message.status = 400100;
                    break;
                case "PRECONDITION_FAILED":
                case 400120:
                    message.status = 400120;
                    break;
                case "ALREADY_EXISTS":
                case 400130:
                    message.status = 400130;
                    break;
                case "NOT_FOUND":
                case 400140:
                    message.status = 400140;
                    break;
                case "SESSION_EXPIRED":
                case 400150:
                    message.status = 400150;
                    break;
                case "CANCELLED":
                case 400160:
                    message.status = 400160;
                    break;
                case "UNDETERMINED":
                case 400170:
                    message.status = 400170;
                    break;
                case "UNSUPPORTED":
                case 400180:
                    message.status = 400180;
                    break;
                case "SESSION_BUSY":
                case 400190:
                    message.status = 400190;
                    break;
                }
                if (object.issues) {
                    if (!Array.isArray(object.issues))
                        throw TypeError(".Ydb.Table.ReadTableResponse.issues: array expected");
                    message.issues = [];
                    for (var i = 0; i < object.issues.length; ++i) {
                        if (typeof object.issues[i] !== "object")
                            throw TypeError(".Ydb.Table.ReadTableResponse.issues: object expected");
                        message.issues[i] = $root.Ydb.Issue.IssueMessage.fromObject(object.issues[i]);
                    }
                }
                if (object.result != null) {
                    if (typeof object.result !== "object")
                        throw TypeError(".Ydb.Table.ReadTableResponse.result: object expected");
                    message.result = $root.Ydb.Table.ReadTableResult.fromObject(object.result);
                }
                return message;
            };

            /**
             * Creates a plain object from a ReadTableResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.ReadTableResponse
             * @static
             * @param {Ydb.Table.ReadTableResponse} message ReadTableResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReadTableResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.issues = [];
                if (options.defaults) {
                    object.status = options.enums === String ? "STATUS_CODE_UNSPECIFIED" : 0;
                    object.result = null;
                }
                if (message.status != null && message.hasOwnProperty("status"))
                    object.status = options.enums === String ? $root.Ydb.StatusIds.StatusCode[message.status] : message.status;
                if (message.issues && message.issues.length) {
                    object.issues = [];
                    for (var j = 0; j < message.issues.length; ++j)
                        object.issues[j] = $root.Ydb.Issue.IssueMessage.toObject(message.issues[j], options);
                }
                if (message.result != null && message.hasOwnProperty("result"))
                    object.result = $root.Ydb.Table.ReadTableResult.toObject(message.result, options);
                return object;
            };

            /**
             * Converts this ReadTableResponse to JSON.
             * @function toJSON
             * @memberof Ydb.Table.ReadTableResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReadTableResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ReadTableResponse;
        })();

        Table.ReadTableResult = (function() {

            /**
             * Properties of a ReadTableResult.
             * @memberof Ydb.Table
             * @interface IReadTableResult
             * @property {Ydb.IResultSet|null} [resultSet] ReadTableResult resultSet
             */

            /**
             * Constructs a new ReadTableResult.
             * @memberof Ydb.Table
             * @classdesc Represents a ReadTableResult.
             * @implements IReadTableResult
             * @constructor
             * @param {Ydb.Table.IReadTableResult=} [properties] Properties to set
             */
            function ReadTableResult(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ReadTableResult resultSet.
             * @member {Ydb.IResultSet|null|undefined} resultSet
             * @memberof Ydb.Table.ReadTableResult
             * @instance
             */
            ReadTableResult.prototype.resultSet = null;

            /**
             * Creates a new ReadTableResult instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.ReadTableResult
             * @static
             * @param {Ydb.Table.IReadTableResult=} [properties] Properties to set
             * @returns {Ydb.Table.ReadTableResult} ReadTableResult instance
             */
            ReadTableResult.create = function create(properties) {
                return new ReadTableResult(properties);
            };

            /**
             * Encodes the specified ReadTableResult message. Does not implicitly {@link Ydb.Table.ReadTableResult.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.ReadTableResult
             * @static
             * @param {Ydb.Table.IReadTableResult} message ReadTableResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadTableResult.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.resultSet != null && Object.hasOwnProperty.call(message, "resultSet"))
                    $root.Ydb.ResultSet.encode(message.resultSet, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ReadTableResult message, length delimited. Does not implicitly {@link Ydb.Table.ReadTableResult.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.ReadTableResult
             * @static
             * @param {Ydb.Table.IReadTableResult} message ReadTableResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadTableResult.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReadTableResult message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.ReadTableResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.ReadTableResult} ReadTableResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadTableResult.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.ReadTableResult();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.resultSet = $root.Ydb.ResultSet.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ReadTableResult message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.ReadTableResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.ReadTableResult} ReadTableResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadTableResult.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReadTableResult message.
             * @function verify
             * @memberof Ydb.Table.ReadTableResult
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReadTableResult.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.resultSet != null && message.hasOwnProperty("resultSet")) {
                    var error = $root.Ydb.ResultSet.verify(message.resultSet);
                    if (error)
                        return "resultSet." + error;
                }
                return null;
            };

            /**
             * Creates a ReadTableResult message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.ReadTableResult
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.ReadTableResult} ReadTableResult
             */
            ReadTableResult.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.ReadTableResult)
                    return object;
                var message = new $root.Ydb.Table.ReadTableResult();
                if (object.resultSet != null) {
                    if (typeof object.resultSet !== "object")
                        throw TypeError(".Ydb.Table.ReadTableResult.resultSet: object expected");
                    message.resultSet = $root.Ydb.ResultSet.fromObject(object.resultSet);
                }
                return message;
            };

            /**
             * Creates a plain object from a ReadTableResult message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.ReadTableResult
             * @static
             * @param {Ydb.Table.ReadTableResult} message ReadTableResult
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReadTableResult.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.resultSet = null;
                if (message.resultSet != null && message.hasOwnProperty("resultSet"))
                    object.resultSet = $root.Ydb.ResultSet.toObject(message.resultSet, options);
                return object;
            };

            /**
             * Converts this ReadTableResult to JSON.
             * @function toJSON
             * @memberof Ydb.Table.ReadTableResult
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReadTableResult.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ReadTableResult;
        })();

        Table.BulkUpsertRequest = (function() {

            /**
             * Properties of a BulkUpsertRequest.
             * @memberof Ydb.Table
             * @interface IBulkUpsertRequest
             * @property {string|null} [table] BulkUpsertRequest table
             * @property {Ydb.ITypedValue|null} [rows] BulkUpsertRequest rows
             * @property {Ydb.Operations.IOperationParams|null} [operationParams] BulkUpsertRequest operationParams
             */

            /**
             * Constructs a new BulkUpsertRequest.
             * @memberof Ydb.Table
             * @classdesc Represents a BulkUpsertRequest.
             * @implements IBulkUpsertRequest
             * @constructor
             * @param {Ydb.Table.IBulkUpsertRequest=} [properties] Properties to set
             */
            function BulkUpsertRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * BulkUpsertRequest table.
             * @member {string} table
             * @memberof Ydb.Table.BulkUpsertRequest
             * @instance
             */
            BulkUpsertRequest.prototype.table = "";

            /**
             * BulkUpsertRequest rows.
             * @member {Ydb.ITypedValue|null|undefined} rows
             * @memberof Ydb.Table.BulkUpsertRequest
             * @instance
             */
            BulkUpsertRequest.prototype.rows = null;

            /**
             * BulkUpsertRequest operationParams.
             * @member {Ydb.Operations.IOperationParams|null|undefined} operationParams
             * @memberof Ydb.Table.BulkUpsertRequest
             * @instance
             */
            BulkUpsertRequest.prototype.operationParams = null;

            /**
             * Creates a new BulkUpsertRequest instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.BulkUpsertRequest
             * @static
             * @param {Ydb.Table.IBulkUpsertRequest=} [properties] Properties to set
             * @returns {Ydb.Table.BulkUpsertRequest} BulkUpsertRequest instance
             */
            BulkUpsertRequest.create = function create(properties) {
                return new BulkUpsertRequest(properties);
            };

            /**
             * Encodes the specified BulkUpsertRequest message. Does not implicitly {@link Ydb.Table.BulkUpsertRequest.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.BulkUpsertRequest
             * @static
             * @param {Ydb.Table.IBulkUpsertRequest} message BulkUpsertRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BulkUpsertRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.table != null && Object.hasOwnProperty.call(message, "table"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.table);
                if (message.rows != null && Object.hasOwnProperty.call(message, "rows"))
                    $root.Ydb.TypedValue.encode(message.rows, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.operationParams != null && Object.hasOwnProperty.call(message, "operationParams"))
                    $root.Ydb.Operations.OperationParams.encode(message.operationParams, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified BulkUpsertRequest message, length delimited. Does not implicitly {@link Ydb.Table.BulkUpsertRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.BulkUpsertRequest
             * @static
             * @param {Ydb.Table.IBulkUpsertRequest} message BulkUpsertRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BulkUpsertRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BulkUpsertRequest message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.BulkUpsertRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.BulkUpsertRequest} BulkUpsertRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BulkUpsertRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.BulkUpsertRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.table = reader.string();
                        break;
                    case 2:
                        message.rows = $root.Ydb.TypedValue.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.operationParams = $root.Ydb.Operations.OperationParams.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a BulkUpsertRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.BulkUpsertRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.BulkUpsertRequest} BulkUpsertRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BulkUpsertRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BulkUpsertRequest message.
             * @function verify
             * @memberof Ydb.Table.BulkUpsertRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BulkUpsertRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.table != null && message.hasOwnProperty("table"))
                    if (!$util.isString(message.table))
                        return "table: string expected";
                if (message.rows != null && message.hasOwnProperty("rows")) {
                    var error = $root.Ydb.TypedValue.verify(message.rows);
                    if (error)
                        return "rows." + error;
                }
                if (message.operationParams != null && message.hasOwnProperty("operationParams")) {
                    var error = $root.Ydb.Operations.OperationParams.verify(message.operationParams);
                    if (error)
                        return "operationParams." + error;
                }
                return null;
            };

            /**
             * Creates a BulkUpsertRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.BulkUpsertRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.BulkUpsertRequest} BulkUpsertRequest
             */
            BulkUpsertRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.BulkUpsertRequest)
                    return object;
                var message = new $root.Ydb.Table.BulkUpsertRequest();
                if (object.table != null)
                    message.table = String(object.table);
                if (object.rows != null) {
                    if (typeof object.rows !== "object")
                        throw TypeError(".Ydb.Table.BulkUpsertRequest.rows: object expected");
                    message.rows = $root.Ydb.TypedValue.fromObject(object.rows);
                }
                if (object.operationParams != null) {
                    if (typeof object.operationParams !== "object")
                        throw TypeError(".Ydb.Table.BulkUpsertRequest.operationParams: object expected");
                    message.operationParams = $root.Ydb.Operations.OperationParams.fromObject(object.operationParams);
                }
                return message;
            };

            /**
             * Creates a plain object from a BulkUpsertRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.BulkUpsertRequest
             * @static
             * @param {Ydb.Table.BulkUpsertRequest} message BulkUpsertRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BulkUpsertRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.table = "";
                    object.rows = null;
                    object.operationParams = null;
                }
                if (message.table != null && message.hasOwnProperty("table"))
                    object.table = message.table;
                if (message.rows != null && message.hasOwnProperty("rows"))
                    object.rows = $root.Ydb.TypedValue.toObject(message.rows, options);
                if (message.operationParams != null && message.hasOwnProperty("operationParams"))
                    object.operationParams = $root.Ydb.Operations.OperationParams.toObject(message.operationParams, options);
                return object;
            };

            /**
             * Converts this BulkUpsertRequest to JSON.
             * @function toJSON
             * @memberof Ydb.Table.BulkUpsertRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BulkUpsertRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return BulkUpsertRequest;
        })();

        Table.BulkUpsertResponse = (function() {

            /**
             * Properties of a BulkUpsertResponse.
             * @memberof Ydb.Table
             * @interface IBulkUpsertResponse
             * @property {Ydb.Operations.IOperation|null} [operation] BulkUpsertResponse operation
             */

            /**
             * Constructs a new BulkUpsertResponse.
             * @memberof Ydb.Table
             * @classdesc Represents a BulkUpsertResponse.
             * @implements IBulkUpsertResponse
             * @constructor
             * @param {Ydb.Table.IBulkUpsertResponse=} [properties] Properties to set
             */
            function BulkUpsertResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * BulkUpsertResponse operation.
             * @member {Ydb.Operations.IOperation|null|undefined} operation
             * @memberof Ydb.Table.BulkUpsertResponse
             * @instance
             */
            BulkUpsertResponse.prototype.operation = null;

            /**
             * Creates a new BulkUpsertResponse instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.BulkUpsertResponse
             * @static
             * @param {Ydb.Table.IBulkUpsertResponse=} [properties] Properties to set
             * @returns {Ydb.Table.BulkUpsertResponse} BulkUpsertResponse instance
             */
            BulkUpsertResponse.create = function create(properties) {
                return new BulkUpsertResponse(properties);
            };

            /**
             * Encodes the specified BulkUpsertResponse message. Does not implicitly {@link Ydb.Table.BulkUpsertResponse.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.BulkUpsertResponse
             * @static
             * @param {Ydb.Table.IBulkUpsertResponse} message BulkUpsertResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BulkUpsertResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.operation != null && Object.hasOwnProperty.call(message, "operation"))
                    $root.Ydb.Operations.Operation.encode(message.operation, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified BulkUpsertResponse message, length delimited. Does not implicitly {@link Ydb.Table.BulkUpsertResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.BulkUpsertResponse
             * @static
             * @param {Ydb.Table.IBulkUpsertResponse} message BulkUpsertResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BulkUpsertResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BulkUpsertResponse message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.BulkUpsertResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.BulkUpsertResponse} BulkUpsertResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BulkUpsertResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.BulkUpsertResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.operation = $root.Ydb.Operations.Operation.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a BulkUpsertResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.BulkUpsertResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.BulkUpsertResponse} BulkUpsertResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BulkUpsertResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BulkUpsertResponse message.
             * @function verify
             * @memberof Ydb.Table.BulkUpsertResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BulkUpsertResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.operation != null && message.hasOwnProperty("operation")) {
                    var error = $root.Ydb.Operations.Operation.verify(message.operation);
                    if (error)
                        return "operation." + error;
                }
                return null;
            };

            /**
             * Creates a BulkUpsertResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.BulkUpsertResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.BulkUpsertResponse} BulkUpsertResponse
             */
            BulkUpsertResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.BulkUpsertResponse)
                    return object;
                var message = new $root.Ydb.Table.BulkUpsertResponse();
                if (object.operation != null) {
                    if (typeof object.operation !== "object")
                        throw TypeError(".Ydb.Table.BulkUpsertResponse.operation: object expected");
                    message.operation = $root.Ydb.Operations.Operation.fromObject(object.operation);
                }
                return message;
            };

            /**
             * Creates a plain object from a BulkUpsertResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.BulkUpsertResponse
             * @static
             * @param {Ydb.Table.BulkUpsertResponse} message BulkUpsertResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BulkUpsertResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.operation = null;
                if (message.operation != null && message.hasOwnProperty("operation"))
                    object.operation = $root.Ydb.Operations.Operation.toObject(message.operation, options);
                return object;
            };

            /**
             * Converts this BulkUpsertResponse to JSON.
             * @function toJSON
             * @memberof Ydb.Table.BulkUpsertResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BulkUpsertResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return BulkUpsertResponse;
        })();

        Table.BulkUpsertResult = (function() {

            /**
             * Properties of a BulkUpsertResult.
             * @memberof Ydb.Table
             * @interface IBulkUpsertResult
             */

            /**
             * Constructs a new BulkUpsertResult.
             * @memberof Ydb.Table
             * @classdesc Represents a BulkUpsertResult.
             * @implements IBulkUpsertResult
             * @constructor
             * @param {Ydb.Table.IBulkUpsertResult=} [properties] Properties to set
             */
            function BulkUpsertResult(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new BulkUpsertResult instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.BulkUpsertResult
             * @static
             * @param {Ydb.Table.IBulkUpsertResult=} [properties] Properties to set
             * @returns {Ydb.Table.BulkUpsertResult} BulkUpsertResult instance
             */
            BulkUpsertResult.create = function create(properties) {
                return new BulkUpsertResult(properties);
            };

            /**
             * Encodes the specified BulkUpsertResult message. Does not implicitly {@link Ydb.Table.BulkUpsertResult.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.BulkUpsertResult
             * @static
             * @param {Ydb.Table.IBulkUpsertResult} message BulkUpsertResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BulkUpsertResult.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified BulkUpsertResult message, length delimited. Does not implicitly {@link Ydb.Table.BulkUpsertResult.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.BulkUpsertResult
             * @static
             * @param {Ydb.Table.IBulkUpsertResult} message BulkUpsertResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BulkUpsertResult.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BulkUpsertResult message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.BulkUpsertResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.BulkUpsertResult} BulkUpsertResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BulkUpsertResult.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.BulkUpsertResult();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a BulkUpsertResult message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.BulkUpsertResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.BulkUpsertResult} BulkUpsertResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BulkUpsertResult.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BulkUpsertResult message.
             * @function verify
             * @memberof Ydb.Table.BulkUpsertResult
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BulkUpsertResult.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a BulkUpsertResult message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.BulkUpsertResult
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.BulkUpsertResult} BulkUpsertResult
             */
            BulkUpsertResult.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.BulkUpsertResult)
                    return object;
                return new $root.Ydb.Table.BulkUpsertResult();
            };

            /**
             * Creates a plain object from a BulkUpsertResult message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.BulkUpsertResult
             * @static
             * @param {Ydb.Table.BulkUpsertResult} message BulkUpsertResult
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BulkUpsertResult.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this BulkUpsertResult to JSON.
             * @function toJSON
             * @memberof Ydb.Table.BulkUpsertResult
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BulkUpsertResult.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return BulkUpsertResult;
        })();

        Table.ExecuteScanQueryRequest = (function() {

            /**
             * Properties of an ExecuteScanQueryRequest.
             * @memberof Ydb.Table
             * @interface IExecuteScanQueryRequest
             * @property {Ydb.Table.IQuery|null} [query] ExecuteScanQueryRequest query
             * @property {Object.<string,Ydb.ITypedValue>|null} [parameters] ExecuteScanQueryRequest parameters
             * @property {Ydb.Table.ExecuteScanQueryRequest.Mode|null} [mode] ExecuteScanQueryRequest mode
             * @property {Ydb.Table.QueryStatsCollection.Mode|null} [collectStats] ExecuteScanQueryRequest collectStats
             */

            /**
             * Constructs a new ExecuteScanQueryRequest.
             * @memberof Ydb.Table
             * @classdesc Represents an ExecuteScanQueryRequest.
             * @implements IExecuteScanQueryRequest
             * @constructor
             * @param {Ydb.Table.IExecuteScanQueryRequest=} [properties] Properties to set
             */
            function ExecuteScanQueryRequest(properties) {
                this.parameters = {};
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ExecuteScanQueryRequest query.
             * @member {Ydb.Table.IQuery|null|undefined} query
             * @memberof Ydb.Table.ExecuteScanQueryRequest
             * @instance
             */
            ExecuteScanQueryRequest.prototype.query = null;

            /**
             * ExecuteScanQueryRequest parameters.
             * @member {Object.<string,Ydb.ITypedValue>} parameters
             * @memberof Ydb.Table.ExecuteScanQueryRequest
             * @instance
             */
            ExecuteScanQueryRequest.prototype.parameters = $util.emptyObject;

            /**
             * ExecuteScanQueryRequest mode.
             * @member {Ydb.Table.ExecuteScanQueryRequest.Mode} mode
             * @memberof Ydb.Table.ExecuteScanQueryRequest
             * @instance
             */
            ExecuteScanQueryRequest.prototype.mode = 0;

            /**
             * ExecuteScanQueryRequest collectStats.
             * @member {Ydb.Table.QueryStatsCollection.Mode} collectStats
             * @memberof Ydb.Table.ExecuteScanQueryRequest
             * @instance
             */
            ExecuteScanQueryRequest.prototype.collectStats = 0;

            /**
             * Creates a new ExecuteScanQueryRequest instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.ExecuteScanQueryRequest
             * @static
             * @param {Ydb.Table.IExecuteScanQueryRequest=} [properties] Properties to set
             * @returns {Ydb.Table.ExecuteScanQueryRequest} ExecuteScanQueryRequest instance
             */
            ExecuteScanQueryRequest.create = function create(properties) {
                return new ExecuteScanQueryRequest(properties);
            };

            /**
             * Encodes the specified ExecuteScanQueryRequest message. Does not implicitly {@link Ydb.Table.ExecuteScanQueryRequest.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.ExecuteScanQueryRequest
             * @static
             * @param {Ydb.Table.IExecuteScanQueryRequest} message ExecuteScanQueryRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExecuteScanQueryRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.query != null && Object.hasOwnProperty.call(message, "query"))
                    $root.Ydb.Table.Query.encode(message.query, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.parameters != null && Object.hasOwnProperty.call(message, "parameters"))
                    for (var keys = Object.keys(message.parameters), i = 0; i < keys.length; ++i) {
                        writer.uint32(/* id 4, wireType 2 =*/34).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                        $root.Ydb.TypedValue.encode(message.parameters[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                    }
                if (message.mode != null && Object.hasOwnProperty.call(message, "mode"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int32(message.mode);
                if (message.collectStats != null && Object.hasOwnProperty.call(message, "collectStats"))
                    writer.uint32(/* id 8, wireType 0 =*/64).int32(message.collectStats);
                return writer;
            };

            /**
             * Encodes the specified ExecuteScanQueryRequest message, length delimited. Does not implicitly {@link Ydb.Table.ExecuteScanQueryRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.ExecuteScanQueryRequest
             * @static
             * @param {Ydb.Table.IExecuteScanQueryRequest} message ExecuteScanQueryRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExecuteScanQueryRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ExecuteScanQueryRequest message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.ExecuteScanQueryRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.ExecuteScanQueryRequest} ExecuteScanQueryRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExecuteScanQueryRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.ExecuteScanQueryRequest(), key, value;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 3:
                        message.query = $root.Ydb.Table.Query.decode(reader, reader.uint32());
                        break;
                    case 4:
                        if (message.parameters === $util.emptyObject)
                            message.parameters = {};
                        var end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = null;
                        while (reader.pos < end2) {
                            var tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = $root.Ydb.TypedValue.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.parameters[key] = value;
                        break;
                    case 6:
                        message.mode = reader.int32();
                        break;
                    case 8:
                        message.collectStats = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an ExecuteScanQueryRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.ExecuteScanQueryRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.ExecuteScanQueryRequest} ExecuteScanQueryRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExecuteScanQueryRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ExecuteScanQueryRequest message.
             * @function verify
             * @memberof Ydb.Table.ExecuteScanQueryRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ExecuteScanQueryRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.query != null && message.hasOwnProperty("query")) {
                    var error = $root.Ydb.Table.Query.verify(message.query);
                    if (error)
                        return "query." + error;
                }
                if (message.parameters != null && message.hasOwnProperty("parameters")) {
                    if (!$util.isObject(message.parameters))
                        return "parameters: object expected";
                    var key = Object.keys(message.parameters);
                    for (var i = 0; i < key.length; ++i) {
                        var error = $root.Ydb.TypedValue.verify(message.parameters[key[i]]);
                        if (error)
                            return "parameters." + error;
                    }
                }
                if (message.mode != null && message.hasOwnProperty("mode"))
                    switch (message.mode) {
                    default:
                        return "mode: enum value expected";
                    case 0:
                    case 1:
                    case 3:
                        break;
                    }
                if (message.collectStats != null && message.hasOwnProperty("collectStats"))
                    switch (message.collectStats) {
                    default:
                        return "collectStats: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                        break;
                    }
                return null;
            };

            /**
             * Creates an ExecuteScanQueryRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.ExecuteScanQueryRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.ExecuteScanQueryRequest} ExecuteScanQueryRequest
             */
            ExecuteScanQueryRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.ExecuteScanQueryRequest)
                    return object;
                var message = new $root.Ydb.Table.ExecuteScanQueryRequest();
                if (object.query != null) {
                    if (typeof object.query !== "object")
                        throw TypeError(".Ydb.Table.ExecuteScanQueryRequest.query: object expected");
                    message.query = $root.Ydb.Table.Query.fromObject(object.query);
                }
                if (object.parameters) {
                    if (typeof object.parameters !== "object")
                        throw TypeError(".Ydb.Table.ExecuteScanQueryRequest.parameters: object expected");
                    message.parameters = {};
                    for (var keys = Object.keys(object.parameters), i = 0; i < keys.length; ++i) {
                        if (typeof object.parameters[keys[i]] !== "object")
                            throw TypeError(".Ydb.Table.ExecuteScanQueryRequest.parameters: object expected");
                        message.parameters[keys[i]] = $root.Ydb.TypedValue.fromObject(object.parameters[keys[i]]);
                    }
                }
                switch (object.mode) {
                case "MODE_UNSPECIFIED":
                case 0:
                    message.mode = 0;
                    break;
                case "MODE_EXPLAIN":
                case 1:
                    message.mode = 1;
                    break;
                case "MODE_EXEC":
                case 3:
                    message.mode = 3;
                    break;
                }
                switch (object.collectStats) {
                case "STATS_COLLECTION_UNSPECIFIED":
                case 0:
                    message.collectStats = 0;
                    break;
                case "STATS_COLLECTION_NONE":
                case 1:
                    message.collectStats = 1;
                    break;
                case "STATS_COLLECTION_BASIC":
                case 2:
                    message.collectStats = 2;
                    break;
                case "STATS_COLLECTION_FULL":
                case 3:
                    message.collectStats = 3;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from an ExecuteScanQueryRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.ExecuteScanQueryRequest
             * @static
             * @param {Ydb.Table.ExecuteScanQueryRequest} message ExecuteScanQueryRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ExecuteScanQueryRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.objects || options.defaults)
                    object.parameters = {};
                if (options.defaults) {
                    object.query = null;
                    object.mode = options.enums === String ? "MODE_UNSPECIFIED" : 0;
                    object.collectStats = options.enums === String ? "STATS_COLLECTION_UNSPECIFIED" : 0;
                }
                if (message.query != null && message.hasOwnProperty("query"))
                    object.query = $root.Ydb.Table.Query.toObject(message.query, options);
                var keys2;
                if (message.parameters && (keys2 = Object.keys(message.parameters)).length) {
                    object.parameters = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.parameters[keys2[j]] = $root.Ydb.TypedValue.toObject(message.parameters[keys2[j]], options);
                }
                if (message.mode != null && message.hasOwnProperty("mode"))
                    object.mode = options.enums === String ? $root.Ydb.Table.ExecuteScanQueryRequest.Mode[message.mode] : message.mode;
                if (message.collectStats != null && message.hasOwnProperty("collectStats"))
                    object.collectStats = options.enums === String ? $root.Ydb.Table.QueryStatsCollection.Mode[message.collectStats] : message.collectStats;
                return object;
            };

            /**
             * Converts this ExecuteScanQueryRequest to JSON.
             * @function toJSON
             * @memberof Ydb.Table.ExecuteScanQueryRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ExecuteScanQueryRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Mode enum.
             * @name Ydb.Table.ExecuteScanQueryRequest.Mode
             * @enum {number}
             * @property {number} MODE_UNSPECIFIED=0 MODE_UNSPECIFIED value
             * @property {number} MODE_EXPLAIN=1 MODE_EXPLAIN value
             * @property {number} MODE_EXEC=3 MODE_EXEC value
             */
            ExecuteScanQueryRequest.Mode = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "MODE_UNSPECIFIED"] = 0;
                values[valuesById[1] = "MODE_EXPLAIN"] = 1;
                values[valuesById[3] = "MODE_EXEC"] = 3;
                return values;
            })();

            return ExecuteScanQueryRequest;
        })();

        Table.ExecuteScanQueryPartialResponse = (function() {

            /**
             * Properties of an ExecuteScanQueryPartialResponse.
             * @memberof Ydb.Table
             * @interface IExecuteScanQueryPartialResponse
             * @property {Ydb.StatusIds.StatusCode|null} [status] ExecuteScanQueryPartialResponse status
             * @property {Array.<Ydb.Issue.IIssueMessage>|null} [issues] ExecuteScanQueryPartialResponse issues
             * @property {Ydb.Table.IExecuteScanQueryPartialResult|null} [result] ExecuteScanQueryPartialResponse result
             */

            /**
             * Constructs a new ExecuteScanQueryPartialResponse.
             * @memberof Ydb.Table
             * @classdesc Represents an ExecuteScanQueryPartialResponse.
             * @implements IExecuteScanQueryPartialResponse
             * @constructor
             * @param {Ydb.Table.IExecuteScanQueryPartialResponse=} [properties] Properties to set
             */
            function ExecuteScanQueryPartialResponse(properties) {
                this.issues = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ExecuteScanQueryPartialResponse status.
             * @member {Ydb.StatusIds.StatusCode} status
             * @memberof Ydb.Table.ExecuteScanQueryPartialResponse
             * @instance
             */
            ExecuteScanQueryPartialResponse.prototype.status = 0;

            /**
             * ExecuteScanQueryPartialResponse issues.
             * @member {Array.<Ydb.Issue.IIssueMessage>} issues
             * @memberof Ydb.Table.ExecuteScanQueryPartialResponse
             * @instance
             */
            ExecuteScanQueryPartialResponse.prototype.issues = $util.emptyArray;

            /**
             * ExecuteScanQueryPartialResponse result.
             * @member {Ydb.Table.IExecuteScanQueryPartialResult|null|undefined} result
             * @memberof Ydb.Table.ExecuteScanQueryPartialResponse
             * @instance
             */
            ExecuteScanQueryPartialResponse.prototype.result = null;

            /**
             * Creates a new ExecuteScanQueryPartialResponse instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.ExecuteScanQueryPartialResponse
             * @static
             * @param {Ydb.Table.IExecuteScanQueryPartialResponse=} [properties] Properties to set
             * @returns {Ydb.Table.ExecuteScanQueryPartialResponse} ExecuteScanQueryPartialResponse instance
             */
            ExecuteScanQueryPartialResponse.create = function create(properties) {
                return new ExecuteScanQueryPartialResponse(properties);
            };

            /**
             * Encodes the specified ExecuteScanQueryPartialResponse message. Does not implicitly {@link Ydb.Table.ExecuteScanQueryPartialResponse.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.ExecuteScanQueryPartialResponse
             * @static
             * @param {Ydb.Table.IExecuteScanQueryPartialResponse} message ExecuteScanQueryPartialResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExecuteScanQueryPartialResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.status);
                if (message.issues != null && message.issues.length)
                    for (var i = 0; i < message.issues.length; ++i)
                        $root.Ydb.Issue.IssueMessage.encode(message.issues[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.result != null && Object.hasOwnProperty.call(message, "result"))
                    $root.Ydb.Table.ExecuteScanQueryPartialResult.encode(message.result, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ExecuteScanQueryPartialResponse message, length delimited. Does not implicitly {@link Ydb.Table.ExecuteScanQueryPartialResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.ExecuteScanQueryPartialResponse
             * @static
             * @param {Ydb.Table.IExecuteScanQueryPartialResponse} message ExecuteScanQueryPartialResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExecuteScanQueryPartialResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ExecuteScanQueryPartialResponse message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.ExecuteScanQueryPartialResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.ExecuteScanQueryPartialResponse} ExecuteScanQueryPartialResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExecuteScanQueryPartialResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.ExecuteScanQueryPartialResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.status = reader.int32();
                        break;
                    case 2:
                        if (!(message.issues && message.issues.length))
                            message.issues = [];
                        message.issues.push($root.Ydb.Issue.IssueMessage.decode(reader, reader.uint32()));
                        break;
                    case 3:
                        message.result = $root.Ydb.Table.ExecuteScanQueryPartialResult.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an ExecuteScanQueryPartialResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.ExecuteScanQueryPartialResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.ExecuteScanQueryPartialResponse} ExecuteScanQueryPartialResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExecuteScanQueryPartialResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ExecuteScanQueryPartialResponse message.
             * @function verify
             * @memberof Ydb.Table.ExecuteScanQueryPartialResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ExecuteScanQueryPartialResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.status != null && message.hasOwnProperty("status"))
                    switch (message.status) {
                    default:
                        return "status: enum value expected";
                    case 0:
                    case 400000:
                    case 400010:
                    case 400020:
                    case 400030:
                    case 400040:
                    case 400050:
                    case 400060:
                    case 400070:
                    case 400080:
                    case 400090:
                    case 400100:
                    case 400120:
                    case 400130:
                    case 400140:
                    case 400150:
                    case 400160:
                    case 400170:
                    case 400180:
                    case 400190:
                        break;
                    }
                if (message.issues != null && message.hasOwnProperty("issues")) {
                    if (!Array.isArray(message.issues))
                        return "issues: array expected";
                    for (var i = 0; i < message.issues.length; ++i) {
                        var error = $root.Ydb.Issue.IssueMessage.verify(message.issues[i]);
                        if (error)
                            return "issues." + error;
                    }
                }
                if (message.result != null && message.hasOwnProperty("result")) {
                    var error = $root.Ydb.Table.ExecuteScanQueryPartialResult.verify(message.result);
                    if (error)
                        return "result." + error;
                }
                return null;
            };

            /**
             * Creates an ExecuteScanQueryPartialResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.ExecuteScanQueryPartialResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.ExecuteScanQueryPartialResponse} ExecuteScanQueryPartialResponse
             */
            ExecuteScanQueryPartialResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.ExecuteScanQueryPartialResponse)
                    return object;
                var message = new $root.Ydb.Table.ExecuteScanQueryPartialResponse();
                switch (object.status) {
                case "STATUS_CODE_UNSPECIFIED":
                case 0:
                    message.status = 0;
                    break;
                case "SUCCESS":
                case 400000:
                    message.status = 400000;
                    break;
                case "BAD_REQUEST":
                case 400010:
                    message.status = 400010;
                    break;
                case "UNAUTHORIZED":
                case 400020:
                    message.status = 400020;
                    break;
                case "INTERNAL_ERROR":
                case 400030:
                    message.status = 400030;
                    break;
                case "ABORTED":
                case 400040:
                    message.status = 400040;
                    break;
                case "UNAVAILABLE":
                case 400050:
                    message.status = 400050;
                    break;
                case "OVERLOADED":
                case 400060:
                    message.status = 400060;
                    break;
                case "SCHEME_ERROR":
                case 400070:
                    message.status = 400070;
                    break;
                case "GENERIC_ERROR":
                case 400080:
                    message.status = 400080;
                    break;
                case "TIMEOUT":
                case 400090:
                    message.status = 400090;
                    break;
                case "BAD_SESSION":
                case 400100:
                    message.status = 400100;
                    break;
                case "PRECONDITION_FAILED":
                case 400120:
                    message.status = 400120;
                    break;
                case "ALREADY_EXISTS":
                case 400130:
                    message.status = 400130;
                    break;
                case "NOT_FOUND":
                case 400140:
                    message.status = 400140;
                    break;
                case "SESSION_EXPIRED":
                case 400150:
                    message.status = 400150;
                    break;
                case "CANCELLED":
                case 400160:
                    message.status = 400160;
                    break;
                case "UNDETERMINED":
                case 400170:
                    message.status = 400170;
                    break;
                case "UNSUPPORTED":
                case 400180:
                    message.status = 400180;
                    break;
                case "SESSION_BUSY":
                case 400190:
                    message.status = 400190;
                    break;
                }
                if (object.issues) {
                    if (!Array.isArray(object.issues))
                        throw TypeError(".Ydb.Table.ExecuteScanQueryPartialResponse.issues: array expected");
                    message.issues = [];
                    for (var i = 0; i < object.issues.length; ++i) {
                        if (typeof object.issues[i] !== "object")
                            throw TypeError(".Ydb.Table.ExecuteScanQueryPartialResponse.issues: object expected");
                        message.issues[i] = $root.Ydb.Issue.IssueMessage.fromObject(object.issues[i]);
                    }
                }
                if (object.result != null) {
                    if (typeof object.result !== "object")
                        throw TypeError(".Ydb.Table.ExecuteScanQueryPartialResponse.result: object expected");
                    message.result = $root.Ydb.Table.ExecuteScanQueryPartialResult.fromObject(object.result);
                }
                return message;
            };

            /**
             * Creates a plain object from an ExecuteScanQueryPartialResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.ExecuteScanQueryPartialResponse
             * @static
             * @param {Ydb.Table.ExecuteScanQueryPartialResponse} message ExecuteScanQueryPartialResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ExecuteScanQueryPartialResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.issues = [];
                if (options.defaults) {
                    object.status = options.enums === String ? "STATUS_CODE_UNSPECIFIED" : 0;
                    object.result = null;
                }
                if (message.status != null && message.hasOwnProperty("status"))
                    object.status = options.enums === String ? $root.Ydb.StatusIds.StatusCode[message.status] : message.status;
                if (message.issues && message.issues.length) {
                    object.issues = [];
                    for (var j = 0; j < message.issues.length; ++j)
                        object.issues[j] = $root.Ydb.Issue.IssueMessage.toObject(message.issues[j], options);
                }
                if (message.result != null && message.hasOwnProperty("result"))
                    object.result = $root.Ydb.Table.ExecuteScanQueryPartialResult.toObject(message.result, options);
                return object;
            };

            /**
             * Converts this ExecuteScanQueryPartialResponse to JSON.
             * @function toJSON
             * @memberof Ydb.Table.ExecuteScanQueryPartialResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ExecuteScanQueryPartialResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ExecuteScanQueryPartialResponse;
        })();

        Table.ExecuteScanQueryPartialResult = (function() {

            /**
             * Properties of an ExecuteScanQueryPartialResult.
             * @memberof Ydb.Table
             * @interface IExecuteScanQueryPartialResult
             * @property {Ydb.IResultSet|null} [resultSet] ExecuteScanQueryPartialResult resultSet
             * @property {Ydb.TableStats.IQueryStats|null} [queryStats] ExecuteScanQueryPartialResult queryStats
             */

            /**
             * Constructs a new ExecuteScanQueryPartialResult.
             * @memberof Ydb.Table
             * @classdesc Represents an ExecuteScanQueryPartialResult.
             * @implements IExecuteScanQueryPartialResult
             * @constructor
             * @param {Ydb.Table.IExecuteScanQueryPartialResult=} [properties] Properties to set
             */
            function ExecuteScanQueryPartialResult(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ExecuteScanQueryPartialResult resultSet.
             * @member {Ydb.IResultSet|null|undefined} resultSet
             * @memberof Ydb.Table.ExecuteScanQueryPartialResult
             * @instance
             */
            ExecuteScanQueryPartialResult.prototype.resultSet = null;

            /**
             * ExecuteScanQueryPartialResult queryStats.
             * @member {Ydb.TableStats.IQueryStats|null|undefined} queryStats
             * @memberof Ydb.Table.ExecuteScanQueryPartialResult
             * @instance
             */
            ExecuteScanQueryPartialResult.prototype.queryStats = null;

            /**
             * Creates a new ExecuteScanQueryPartialResult instance using the specified properties.
             * @function create
             * @memberof Ydb.Table.ExecuteScanQueryPartialResult
             * @static
             * @param {Ydb.Table.IExecuteScanQueryPartialResult=} [properties] Properties to set
             * @returns {Ydb.Table.ExecuteScanQueryPartialResult} ExecuteScanQueryPartialResult instance
             */
            ExecuteScanQueryPartialResult.create = function create(properties) {
                return new ExecuteScanQueryPartialResult(properties);
            };

            /**
             * Encodes the specified ExecuteScanQueryPartialResult message. Does not implicitly {@link Ydb.Table.ExecuteScanQueryPartialResult.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Table.ExecuteScanQueryPartialResult
             * @static
             * @param {Ydb.Table.IExecuteScanQueryPartialResult} message ExecuteScanQueryPartialResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExecuteScanQueryPartialResult.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.resultSet != null && Object.hasOwnProperty.call(message, "resultSet"))
                    $root.Ydb.ResultSet.encode(message.resultSet, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.queryStats != null && Object.hasOwnProperty.call(message, "queryStats"))
                    $root.Ydb.TableStats.QueryStats.encode(message.queryStats, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ExecuteScanQueryPartialResult message, length delimited. Does not implicitly {@link Ydb.Table.ExecuteScanQueryPartialResult.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Table.ExecuteScanQueryPartialResult
             * @static
             * @param {Ydb.Table.IExecuteScanQueryPartialResult} message ExecuteScanQueryPartialResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExecuteScanQueryPartialResult.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ExecuteScanQueryPartialResult message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Table.ExecuteScanQueryPartialResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Table.ExecuteScanQueryPartialResult} ExecuteScanQueryPartialResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExecuteScanQueryPartialResult.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Table.ExecuteScanQueryPartialResult();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.resultSet = $root.Ydb.ResultSet.decode(reader, reader.uint32());
                        break;
                    case 6:
                        message.queryStats = $root.Ydb.TableStats.QueryStats.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an ExecuteScanQueryPartialResult message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Table.ExecuteScanQueryPartialResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Table.ExecuteScanQueryPartialResult} ExecuteScanQueryPartialResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExecuteScanQueryPartialResult.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ExecuteScanQueryPartialResult message.
             * @function verify
             * @memberof Ydb.Table.ExecuteScanQueryPartialResult
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ExecuteScanQueryPartialResult.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.resultSet != null && message.hasOwnProperty("resultSet")) {
                    var error = $root.Ydb.ResultSet.verify(message.resultSet);
                    if (error)
                        return "resultSet." + error;
                }
                if (message.queryStats != null && message.hasOwnProperty("queryStats")) {
                    var error = $root.Ydb.TableStats.QueryStats.verify(message.queryStats);
                    if (error)
                        return "queryStats." + error;
                }
                return null;
            };

            /**
             * Creates an ExecuteScanQueryPartialResult message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Table.ExecuteScanQueryPartialResult
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Table.ExecuteScanQueryPartialResult} ExecuteScanQueryPartialResult
             */
            ExecuteScanQueryPartialResult.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Table.ExecuteScanQueryPartialResult)
                    return object;
                var message = new $root.Ydb.Table.ExecuteScanQueryPartialResult();
                if (object.resultSet != null) {
                    if (typeof object.resultSet !== "object")
                        throw TypeError(".Ydb.Table.ExecuteScanQueryPartialResult.resultSet: object expected");
                    message.resultSet = $root.Ydb.ResultSet.fromObject(object.resultSet);
                }
                if (object.queryStats != null) {
                    if (typeof object.queryStats !== "object")
                        throw TypeError(".Ydb.Table.ExecuteScanQueryPartialResult.queryStats: object expected");
                    message.queryStats = $root.Ydb.TableStats.QueryStats.fromObject(object.queryStats);
                }
                return message;
            };

            /**
             * Creates a plain object from an ExecuteScanQueryPartialResult message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Table.ExecuteScanQueryPartialResult
             * @static
             * @param {Ydb.Table.ExecuteScanQueryPartialResult} message ExecuteScanQueryPartialResult
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ExecuteScanQueryPartialResult.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.resultSet = null;
                    object.queryStats = null;
                }
                if (message.resultSet != null && message.hasOwnProperty("resultSet"))
                    object.resultSet = $root.Ydb.ResultSet.toObject(message.resultSet, options);
                if (message.queryStats != null && message.hasOwnProperty("queryStats"))
                    object.queryStats = $root.Ydb.TableStats.QueryStats.toObject(message.queryStats, options);
                return object;
            };

            /**
             * Converts this ExecuteScanQueryPartialResult to JSON.
             * @function toJSON
             * @memberof Ydb.Table.ExecuteScanQueryPartialResult
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ExecuteScanQueryPartialResult.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ExecuteScanQueryPartialResult;
        })();

        return Table;
    })();

    Ydb.Limit = (function() {

        /**
         * Properties of a Limit.
         * @memberof Ydb
         * @interface ILimit
         * @property {Ydb.Limit.IRange|null} [range] Limit range
         * @property {number|null} [lt] Limit lt
         * @property {number|null} [le] Limit le
         * @property {number|null} [eq] Limit eq
         * @property {number|null} [ge] Limit ge
         * @property {number|null} [gt] Limit gt
         */

        /**
         * Constructs a new Limit.
         * @memberof Ydb
         * @classdesc Represents a Limit.
         * @implements ILimit
         * @constructor
         * @param {Ydb.ILimit=} [properties] Properties to set
         */
        function Limit(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Limit range.
         * @member {Ydb.Limit.IRange|null|undefined} range
         * @memberof Ydb.Limit
         * @instance
         */
        Limit.prototype.range = null;

        /**
         * Limit lt.
         * @member {number|null|undefined} lt
         * @memberof Ydb.Limit
         * @instance
         */
        Limit.prototype.lt = null;

        /**
         * Limit le.
         * @member {number|null|undefined} le
         * @memberof Ydb.Limit
         * @instance
         */
        Limit.prototype.le = null;

        /**
         * Limit eq.
         * @member {number|null|undefined} eq
         * @memberof Ydb.Limit
         * @instance
         */
        Limit.prototype.eq = null;

        /**
         * Limit ge.
         * @member {number|null|undefined} ge
         * @memberof Ydb.Limit
         * @instance
         */
        Limit.prototype.ge = null;

        /**
         * Limit gt.
         * @member {number|null|undefined} gt
         * @memberof Ydb.Limit
         * @instance
         */
        Limit.prototype.gt = null;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * Limit kind.
         * @member {"range"|"lt"|"le"|"eq"|"ge"|"gt"|undefined} kind
         * @memberof Ydb.Limit
         * @instance
         */
        Object.defineProperty(Limit.prototype, "kind", {
            get: $util.oneOfGetter($oneOfFields = ["range", "lt", "le", "eq", "ge", "gt"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new Limit instance using the specified properties.
         * @function create
         * @memberof Ydb.Limit
         * @static
         * @param {Ydb.ILimit=} [properties] Properties to set
         * @returns {Ydb.Limit} Limit instance
         */
        Limit.create = function create(properties) {
            return new Limit(properties);
        };

        /**
         * Encodes the specified Limit message. Does not implicitly {@link Ydb.Limit.verify|verify} messages.
         * @function encode
         * @memberof Ydb.Limit
         * @static
         * @param {Ydb.ILimit} message Limit message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Limit.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.range != null && Object.hasOwnProperty.call(message, "range"))
                $root.Ydb.Limit.Range.encode(message.range, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.lt != null && Object.hasOwnProperty.call(message, "lt"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.lt);
            if (message.le != null && Object.hasOwnProperty.call(message, "le"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.le);
            if (message.eq != null && Object.hasOwnProperty.call(message, "eq"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.eq);
            if (message.ge != null && Object.hasOwnProperty.call(message, "ge"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.ge);
            if (message.gt != null && Object.hasOwnProperty.call(message, "gt"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.gt);
            return writer;
        };

        /**
         * Encodes the specified Limit message, length delimited. Does not implicitly {@link Ydb.Limit.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Ydb.Limit
         * @static
         * @param {Ydb.ILimit} message Limit message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Limit.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Limit message from the specified reader or buffer.
         * @function decode
         * @memberof Ydb.Limit
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Ydb.Limit} Limit
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Limit.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Limit();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.range = $root.Ydb.Limit.Range.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.lt = reader.uint32();
                    break;
                case 3:
                    message.le = reader.uint32();
                    break;
                case 4:
                    message.eq = reader.uint32();
                    break;
                case 5:
                    message.ge = reader.uint32();
                    break;
                case 6:
                    message.gt = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Limit message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Ydb.Limit
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Ydb.Limit} Limit
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Limit.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Limit message.
         * @function verify
         * @memberof Ydb.Limit
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Limit.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.range != null && message.hasOwnProperty("range")) {
                properties.kind = 1;
                {
                    var error = $root.Ydb.Limit.Range.verify(message.range);
                    if (error)
                        return "range." + error;
                }
            }
            if (message.lt != null && message.hasOwnProperty("lt")) {
                if (properties.kind === 1)
                    return "kind: multiple values";
                properties.kind = 1;
                if (!$util.isInteger(message.lt))
                    return "lt: integer expected";
            }
            if (message.le != null && message.hasOwnProperty("le")) {
                if (properties.kind === 1)
                    return "kind: multiple values";
                properties.kind = 1;
                if (!$util.isInteger(message.le))
                    return "le: integer expected";
            }
            if (message.eq != null && message.hasOwnProperty("eq")) {
                if (properties.kind === 1)
                    return "kind: multiple values";
                properties.kind = 1;
                if (!$util.isInteger(message.eq))
                    return "eq: integer expected";
            }
            if (message.ge != null && message.hasOwnProperty("ge")) {
                if (properties.kind === 1)
                    return "kind: multiple values";
                properties.kind = 1;
                if (!$util.isInteger(message.ge))
                    return "ge: integer expected";
            }
            if (message.gt != null && message.hasOwnProperty("gt")) {
                if (properties.kind === 1)
                    return "kind: multiple values";
                properties.kind = 1;
                if (!$util.isInteger(message.gt))
                    return "gt: integer expected";
            }
            return null;
        };

        /**
         * Creates a Limit message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Ydb.Limit
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Ydb.Limit} Limit
         */
        Limit.fromObject = function fromObject(object) {
            if (object instanceof $root.Ydb.Limit)
                return object;
            var message = new $root.Ydb.Limit();
            if (object.range != null) {
                if (typeof object.range !== "object")
                    throw TypeError(".Ydb.Limit.range: object expected");
                message.range = $root.Ydb.Limit.Range.fromObject(object.range);
            }
            if (object.lt != null)
                message.lt = object.lt >>> 0;
            if (object.le != null)
                message.le = object.le >>> 0;
            if (object.eq != null)
                message.eq = object.eq >>> 0;
            if (object.ge != null)
                message.ge = object.ge >>> 0;
            if (object.gt != null)
                message.gt = object.gt >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a Limit message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Ydb.Limit
         * @static
         * @param {Ydb.Limit} message Limit
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Limit.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (message.range != null && message.hasOwnProperty("range")) {
                object.range = $root.Ydb.Limit.Range.toObject(message.range, options);
                if (options.oneofs)
                    object.kind = "range";
            }
            if (message.lt != null && message.hasOwnProperty("lt")) {
                object.lt = message.lt;
                if (options.oneofs)
                    object.kind = "lt";
            }
            if (message.le != null && message.hasOwnProperty("le")) {
                object.le = message.le;
                if (options.oneofs)
                    object.kind = "le";
            }
            if (message.eq != null && message.hasOwnProperty("eq")) {
                object.eq = message.eq;
                if (options.oneofs)
                    object.kind = "eq";
            }
            if (message.ge != null && message.hasOwnProperty("ge")) {
                object.ge = message.ge;
                if (options.oneofs)
                    object.kind = "ge";
            }
            if (message.gt != null && message.hasOwnProperty("gt")) {
                object.gt = message.gt;
                if (options.oneofs)
                    object.kind = "gt";
            }
            return object;
        };

        /**
         * Converts this Limit to JSON.
         * @function toJSON
         * @memberof Ydb.Limit
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Limit.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        Limit.Range = (function() {

            /**
             * Properties of a Range.
             * @memberof Ydb.Limit
             * @interface IRange
             * @property {number|null} [min] Range min
             * @property {number|null} [max] Range max
             */

            /**
             * Constructs a new Range.
             * @memberof Ydb.Limit
             * @classdesc Represents a Range.
             * @implements IRange
             * @constructor
             * @param {Ydb.Limit.IRange=} [properties] Properties to set
             */
            function Range(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Range min.
             * @member {number} min
             * @memberof Ydb.Limit.Range
             * @instance
             */
            Range.prototype.min = 0;

            /**
             * Range max.
             * @member {number} max
             * @memberof Ydb.Limit.Range
             * @instance
             */
            Range.prototype.max = 0;

            /**
             * Creates a new Range instance using the specified properties.
             * @function create
             * @memberof Ydb.Limit.Range
             * @static
             * @param {Ydb.Limit.IRange=} [properties] Properties to set
             * @returns {Ydb.Limit.Range} Range instance
             */
            Range.create = function create(properties) {
                return new Range(properties);
            };

            /**
             * Encodes the specified Range message. Does not implicitly {@link Ydb.Limit.Range.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Limit.Range
             * @static
             * @param {Ydb.Limit.IRange} message Range message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Range.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.min != null && Object.hasOwnProperty.call(message, "min"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.min);
                if (message.max != null && Object.hasOwnProperty.call(message, "max"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.max);
                return writer;
            };

            /**
             * Encodes the specified Range message, length delimited. Does not implicitly {@link Ydb.Limit.Range.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Limit.Range
             * @static
             * @param {Ydb.Limit.IRange} message Range message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Range.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Range message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Limit.Range
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Limit.Range} Range
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Range.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Limit.Range();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.min = reader.uint32();
                        break;
                    case 2:
                        message.max = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Range message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Limit.Range
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Limit.Range} Range
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Range.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Range message.
             * @function verify
             * @memberof Ydb.Limit.Range
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Range.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.min != null && message.hasOwnProperty("min"))
                    if (!$util.isInteger(message.min))
                        return "min: integer expected";
                if (message.max != null && message.hasOwnProperty("max"))
                    if (!$util.isInteger(message.max))
                        return "max: integer expected";
                return null;
            };

            /**
             * Creates a Range message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Limit.Range
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Limit.Range} Range
             */
            Range.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Limit.Range)
                    return object;
                var message = new $root.Ydb.Limit.Range();
                if (object.min != null)
                    message.min = object.min >>> 0;
                if (object.max != null)
                    message.max = object.max >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a Range message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Limit.Range
             * @static
             * @param {Ydb.Limit.Range} message Range
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Range.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.min = 0;
                    object.max = 0;
                }
                if (message.min != null && message.hasOwnProperty("min"))
                    object.min = message.min;
                if (message.max != null && message.hasOwnProperty("max"))
                    object.max = message.max;
                return object;
            };

            /**
             * Converts this Range to JSON.
             * @function toJSON
             * @memberof Ydb.Limit.Range
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Range.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Range;
        })();

        return Limit;
    })();

    Ydb.MapKey = (function() {

        /**
         * Properties of a MapKey.
         * @memberof Ydb
         * @interface IMapKey
         * @property {Ydb.ILimit|null} [length] MapKey length
         * @property {string|null} [value] MapKey value
         */

        /**
         * Constructs a new MapKey.
         * @memberof Ydb
         * @classdesc Represents a MapKey.
         * @implements IMapKey
         * @constructor
         * @param {Ydb.IMapKey=} [properties] Properties to set
         */
        function MapKey(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MapKey length.
         * @member {Ydb.ILimit|null|undefined} length
         * @memberof Ydb.MapKey
         * @instance
         */
        MapKey.prototype.length = null;

        /**
         * MapKey value.
         * @member {string} value
         * @memberof Ydb.MapKey
         * @instance
         */
        MapKey.prototype.value = "";

        /**
         * Creates a new MapKey instance using the specified properties.
         * @function create
         * @memberof Ydb.MapKey
         * @static
         * @param {Ydb.IMapKey=} [properties] Properties to set
         * @returns {Ydb.MapKey} MapKey instance
         */
        MapKey.create = function create(properties) {
            return new MapKey(properties);
        };

        /**
         * Encodes the specified MapKey message. Does not implicitly {@link Ydb.MapKey.verify|verify} messages.
         * @function encode
         * @memberof Ydb.MapKey
         * @static
         * @param {Ydb.IMapKey} message MapKey message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MapKey.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.length != null && Object.hasOwnProperty.call(message, "length"))
                $root.Ydb.Limit.encode(message.length, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.value);
            return writer;
        };

        /**
         * Encodes the specified MapKey message, length delimited. Does not implicitly {@link Ydb.MapKey.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Ydb.MapKey
         * @static
         * @param {Ydb.IMapKey} message MapKey message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MapKey.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MapKey message from the specified reader or buffer.
         * @function decode
         * @memberof Ydb.MapKey
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Ydb.MapKey} MapKey
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MapKey.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.MapKey();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.length = $root.Ydb.Limit.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.value = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MapKey message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Ydb.MapKey
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Ydb.MapKey} MapKey
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MapKey.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MapKey message.
         * @function verify
         * @memberof Ydb.MapKey
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MapKey.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.length != null && message.hasOwnProperty("length")) {
                var error = $root.Ydb.Limit.verify(message.length);
                if (error)
                    return "length." + error;
            }
            if (message.value != null && message.hasOwnProperty("value"))
                if (!$util.isString(message.value))
                    return "value: string expected";
            return null;
        };

        /**
         * Creates a MapKey message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Ydb.MapKey
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Ydb.MapKey} MapKey
         */
        MapKey.fromObject = function fromObject(object) {
            if (object instanceof $root.Ydb.MapKey)
                return object;
            var message = new $root.Ydb.MapKey();
            if (object.length != null) {
                if (typeof object.length !== "object")
                    throw TypeError(".Ydb.MapKey.length: object expected");
                message.length = $root.Ydb.Limit.fromObject(object.length);
            }
            if (object.value != null)
                message.value = String(object.value);
            return message;
        };

        /**
         * Creates a plain object from a MapKey message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Ydb.MapKey
         * @static
         * @param {Ydb.MapKey} message MapKey
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MapKey.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.length = null;
                object.value = "";
            }
            if (message.length != null && message.hasOwnProperty("length"))
                object.length = $root.Ydb.Limit.toObject(message.length, options);
            if (message.value != null && message.hasOwnProperty("value"))
                object.value = message.value;
            return object;
        };

        /**
         * Converts this MapKey to JSON.
         * @function toJSON
         * @memberof Ydb.MapKey
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MapKey.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MapKey;
    })();

    Ydb.FeatureFlag = (function() {

        /**
         * Properties of a FeatureFlag.
         * @memberof Ydb
         * @interface IFeatureFlag
         */

        /**
         * Constructs a new FeatureFlag.
         * @memberof Ydb
         * @classdesc Represents a FeatureFlag.
         * @implements IFeatureFlag
         * @constructor
         * @param {Ydb.IFeatureFlag=} [properties] Properties to set
         */
        function FeatureFlag(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new FeatureFlag instance using the specified properties.
         * @function create
         * @memberof Ydb.FeatureFlag
         * @static
         * @param {Ydb.IFeatureFlag=} [properties] Properties to set
         * @returns {Ydb.FeatureFlag} FeatureFlag instance
         */
        FeatureFlag.create = function create(properties) {
            return new FeatureFlag(properties);
        };

        /**
         * Encodes the specified FeatureFlag message. Does not implicitly {@link Ydb.FeatureFlag.verify|verify} messages.
         * @function encode
         * @memberof Ydb.FeatureFlag
         * @static
         * @param {Ydb.IFeatureFlag} message FeatureFlag message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FeatureFlag.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified FeatureFlag message, length delimited. Does not implicitly {@link Ydb.FeatureFlag.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Ydb.FeatureFlag
         * @static
         * @param {Ydb.IFeatureFlag} message FeatureFlag message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FeatureFlag.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FeatureFlag message from the specified reader or buffer.
         * @function decode
         * @memberof Ydb.FeatureFlag
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Ydb.FeatureFlag} FeatureFlag
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FeatureFlag.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.FeatureFlag();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FeatureFlag message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Ydb.FeatureFlag
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Ydb.FeatureFlag} FeatureFlag
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FeatureFlag.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FeatureFlag message.
         * @function verify
         * @memberof Ydb.FeatureFlag
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FeatureFlag.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a FeatureFlag message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Ydb.FeatureFlag
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Ydb.FeatureFlag} FeatureFlag
         */
        FeatureFlag.fromObject = function fromObject(object) {
            if (object instanceof $root.Ydb.FeatureFlag)
                return object;
            return new $root.Ydb.FeatureFlag();
        };

        /**
         * Creates a plain object from a FeatureFlag message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Ydb.FeatureFlag
         * @static
         * @param {Ydb.FeatureFlag} message FeatureFlag
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FeatureFlag.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this FeatureFlag to JSON.
         * @function toJSON
         * @memberof Ydb.FeatureFlag
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FeatureFlag.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Status enum.
         * @name Ydb.FeatureFlag.Status
         * @enum {number}
         * @property {number} STATUS_UNSPECIFIED=0 STATUS_UNSPECIFIED value
         * @property {number} ENABLED=1 ENABLED value
         * @property {number} DISABLED=2 DISABLED value
         */
        FeatureFlag.Status = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "STATUS_UNSPECIFIED"] = 0;
            values[valuesById[1] = "ENABLED"] = 1;
            values[valuesById[2] = "DISABLED"] = 2;
            return values;
        })();

        return FeatureFlag;
    })();

    Ydb.CostInfo = (function() {

        /**
         * Properties of a CostInfo.
         * @memberof Ydb
         * @interface ICostInfo
         * @property {number|null} [consumedUnits] CostInfo consumedUnits
         */

        /**
         * Constructs a new CostInfo.
         * @memberof Ydb
         * @classdesc Represents a CostInfo.
         * @implements ICostInfo
         * @constructor
         * @param {Ydb.ICostInfo=} [properties] Properties to set
         */
        function CostInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CostInfo consumedUnits.
         * @member {number} consumedUnits
         * @memberof Ydb.CostInfo
         * @instance
         */
        CostInfo.prototype.consumedUnits = 0;

        /**
         * Creates a new CostInfo instance using the specified properties.
         * @function create
         * @memberof Ydb.CostInfo
         * @static
         * @param {Ydb.ICostInfo=} [properties] Properties to set
         * @returns {Ydb.CostInfo} CostInfo instance
         */
        CostInfo.create = function create(properties) {
            return new CostInfo(properties);
        };

        /**
         * Encodes the specified CostInfo message. Does not implicitly {@link Ydb.CostInfo.verify|verify} messages.
         * @function encode
         * @memberof Ydb.CostInfo
         * @static
         * @param {Ydb.ICostInfo} message CostInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CostInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.consumedUnits != null && Object.hasOwnProperty.call(message, "consumedUnits"))
                writer.uint32(/* id 1, wireType 1 =*/9).double(message.consumedUnits);
            return writer;
        };

        /**
         * Encodes the specified CostInfo message, length delimited. Does not implicitly {@link Ydb.CostInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Ydb.CostInfo
         * @static
         * @param {Ydb.ICostInfo} message CostInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CostInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CostInfo message from the specified reader or buffer.
         * @function decode
         * @memberof Ydb.CostInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Ydb.CostInfo} CostInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CostInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.CostInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.consumedUnits = reader.double();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CostInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Ydb.CostInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Ydb.CostInfo} CostInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CostInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CostInfo message.
         * @function verify
         * @memberof Ydb.CostInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CostInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.consumedUnits != null && message.hasOwnProperty("consumedUnits"))
                if (typeof message.consumedUnits !== "number")
                    return "consumedUnits: number expected";
            return null;
        };

        /**
         * Creates a CostInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Ydb.CostInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Ydb.CostInfo} CostInfo
         */
        CostInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.Ydb.CostInfo)
                return object;
            var message = new $root.Ydb.CostInfo();
            if (object.consumedUnits != null)
                message.consumedUnits = Number(object.consumedUnits);
            return message;
        };

        /**
         * Creates a plain object from a CostInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Ydb.CostInfo
         * @static
         * @param {Ydb.CostInfo} message CostInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CostInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.consumedUnits = 0;
            if (message.consumedUnits != null && message.hasOwnProperty("consumedUnits"))
                object.consumedUnits = options.json && !isFinite(message.consumedUnits) ? String(message.consumedUnits) : message.consumedUnits;
            return object;
        };

        /**
         * Converts this CostInfo to JSON.
         * @function toJSON
         * @memberof Ydb.CostInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CostInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CostInfo;
    })();

    Ydb.Issue = (function() {

        /**
         * Namespace Issue.
         * @memberof Ydb
         * @namespace
         */
        var Issue = {};

        Issue.IssueMessage = (function() {

            /**
             * Properties of an IssueMessage.
             * @memberof Ydb.Issue
             * @interface IIssueMessage
             * @property {Ydb.Issue.IssueMessage.IPosition|null} [position] IssueMessage position
             * @property {string|null} [message] IssueMessage message
             * @property {Ydb.Issue.IssueMessage.IPosition|null} [endPosition] IssueMessage endPosition
             * @property {number|null} [issueCode] IssueMessage issueCode
             * @property {number|null} [severity] IssueMessage severity
             * @property {Array.<Ydb.Issue.IIssueMessage>|null} [issues] IssueMessage issues
             */

            /**
             * Constructs a new IssueMessage.
             * @memberof Ydb.Issue
             * @classdesc Represents an IssueMessage.
             * @implements IIssueMessage
             * @constructor
             * @param {Ydb.Issue.IIssueMessage=} [properties] Properties to set
             */
            function IssueMessage(properties) {
                this.issues = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * IssueMessage position.
             * @member {Ydb.Issue.IssueMessage.IPosition|null|undefined} position
             * @memberof Ydb.Issue.IssueMessage
             * @instance
             */
            IssueMessage.prototype.position = null;

            /**
             * IssueMessage message.
             * @member {string} message
             * @memberof Ydb.Issue.IssueMessage
             * @instance
             */
            IssueMessage.prototype.message = "";

            /**
             * IssueMessage endPosition.
             * @member {Ydb.Issue.IssueMessage.IPosition|null|undefined} endPosition
             * @memberof Ydb.Issue.IssueMessage
             * @instance
             */
            IssueMessage.prototype.endPosition = null;

            /**
             * IssueMessage issueCode.
             * @member {number} issueCode
             * @memberof Ydb.Issue.IssueMessage
             * @instance
             */
            IssueMessage.prototype.issueCode = 0;

            /**
             * IssueMessage severity.
             * @member {number} severity
             * @memberof Ydb.Issue.IssueMessage
             * @instance
             */
            IssueMessage.prototype.severity = 0;

            /**
             * IssueMessage issues.
             * @member {Array.<Ydb.Issue.IIssueMessage>} issues
             * @memberof Ydb.Issue.IssueMessage
             * @instance
             */
            IssueMessage.prototype.issues = $util.emptyArray;

            /**
             * Creates a new IssueMessage instance using the specified properties.
             * @function create
             * @memberof Ydb.Issue.IssueMessage
             * @static
             * @param {Ydb.Issue.IIssueMessage=} [properties] Properties to set
             * @returns {Ydb.Issue.IssueMessage} IssueMessage instance
             */
            IssueMessage.create = function create(properties) {
                return new IssueMessage(properties);
            };

            /**
             * Encodes the specified IssueMessage message. Does not implicitly {@link Ydb.Issue.IssueMessage.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Issue.IssueMessage
             * @static
             * @param {Ydb.Issue.IIssueMessage} message IssueMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            IssueMessage.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.position != null && Object.hasOwnProperty.call(message, "position"))
                    $root.Ydb.Issue.IssueMessage.Position.encode(message.position, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.message != null && Object.hasOwnProperty.call(message, "message"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.message);
                if (message.endPosition != null && Object.hasOwnProperty.call(message, "endPosition"))
                    $root.Ydb.Issue.IssueMessage.Position.encode(message.endPosition, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.issueCode != null && Object.hasOwnProperty.call(message, "issueCode"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.issueCode);
                if (message.severity != null && Object.hasOwnProperty.call(message, "severity"))
                    writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.severity);
                if (message.issues != null && message.issues.length)
                    for (var i = 0; i < message.issues.length; ++i)
                        $root.Ydb.Issue.IssueMessage.encode(message.issues[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified IssueMessage message, length delimited. Does not implicitly {@link Ydb.Issue.IssueMessage.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Issue.IssueMessage
             * @static
             * @param {Ydb.Issue.IIssueMessage} message IssueMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            IssueMessage.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an IssueMessage message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Issue.IssueMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Issue.IssueMessage} IssueMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            IssueMessage.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Issue.IssueMessage();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.position = $root.Ydb.Issue.IssueMessage.Position.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.message = reader.string();
                        break;
                    case 3:
                        message.endPosition = $root.Ydb.Issue.IssueMessage.Position.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.issueCode = reader.uint32();
                        break;
                    case 5:
                        message.severity = reader.uint32();
                        break;
                    case 6:
                        if (!(message.issues && message.issues.length))
                            message.issues = [];
                        message.issues.push($root.Ydb.Issue.IssueMessage.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an IssueMessage message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Issue.IssueMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Issue.IssueMessage} IssueMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            IssueMessage.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an IssueMessage message.
             * @function verify
             * @memberof Ydb.Issue.IssueMessage
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            IssueMessage.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.position != null && message.hasOwnProperty("position")) {
                    var error = $root.Ydb.Issue.IssueMessage.Position.verify(message.position);
                    if (error)
                        return "position." + error;
                }
                if (message.message != null && message.hasOwnProperty("message"))
                    if (!$util.isString(message.message))
                        return "message: string expected";
                if (message.endPosition != null && message.hasOwnProperty("endPosition")) {
                    var error = $root.Ydb.Issue.IssueMessage.Position.verify(message.endPosition);
                    if (error)
                        return "endPosition." + error;
                }
                if (message.issueCode != null && message.hasOwnProperty("issueCode"))
                    if (!$util.isInteger(message.issueCode))
                        return "issueCode: integer expected";
                if (message.severity != null && message.hasOwnProperty("severity"))
                    if (!$util.isInteger(message.severity))
                        return "severity: integer expected";
                if (message.issues != null && message.hasOwnProperty("issues")) {
                    if (!Array.isArray(message.issues))
                        return "issues: array expected";
                    for (var i = 0; i < message.issues.length; ++i) {
                        var error = $root.Ydb.Issue.IssueMessage.verify(message.issues[i]);
                        if (error)
                            return "issues." + error;
                    }
                }
                return null;
            };

            /**
             * Creates an IssueMessage message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Issue.IssueMessage
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Issue.IssueMessage} IssueMessage
             */
            IssueMessage.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Issue.IssueMessage)
                    return object;
                var message = new $root.Ydb.Issue.IssueMessage();
                if (object.position != null) {
                    if (typeof object.position !== "object")
                        throw TypeError(".Ydb.Issue.IssueMessage.position: object expected");
                    message.position = $root.Ydb.Issue.IssueMessage.Position.fromObject(object.position);
                }
                if (object.message != null)
                    message.message = String(object.message);
                if (object.endPosition != null) {
                    if (typeof object.endPosition !== "object")
                        throw TypeError(".Ydb.Issue.IssueMessage.endPosition: object expected");
                    message.endPosition = $root.Ydb.Issue.IssueMessage.Position.fromObject(object.endPosition);
                }
                if (object.issueCode != null)
                    message.issueCode = object.issueCode >>> 0;
                if (object.severity != null)
                    message.severity = object.severity >>> 0;
                if (object.issues) {
                    if (!Array.isArray(object.issues))
                        throw TypeError(".Ydb.Issue.IssueMessage.issues: array expected");
                    message.issues = [];
                    for (var i = 0; i < object.issues.length; ++i) {
                        if (typeof object.issues[i] !== "object")
                            throw TypeError(".Ydb.Issue.IssueMessage.issues: object expected");
                        message.issues[i] = $root.Ydb.Issue.IssueMessage.fromObject(object.issues[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from an IssueMessage message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Issue.IssueMessage
             * @static
             * @param {Ydb.Issue.IssueMessage} message IssueMessage
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            IssueMessage.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.issues = [];
                if (options.defaults) {
                    object.position = null;
                    object.message = "";
                    object.endPosition = null;
                    object.issueCode = 0;
                    object.severity = 0;
                }
                if (message.position != null && message.hasOwnProperty("position"))
                    object.position = $root.Ydb.Issue.IssueMessage.Position.toObject(message.position, options);
                if (message.message != null && message.hasOwnProperty("message"))
                    object.message = message.message;
                if (message.endPosition != null && message.hasOwnProperty("endPosition"))
                    object.endPosition = $root.Ydb.Issue.IssueMessage.Position.toObject(message.endPosition, options);
                if (message.issueCode != null && message.hasOwnProperty("issueCode"))
                    object.issueCode = message.issueCode;
                if (message.severity != null && message.hasOwnProperty("severity"))
                    object.severity = message.severity;
                if (message.issues && message.issues.length) {
                    object.issues = [];
                    for (var j = 0; j < message.issues.length; ++j)
                        object.issues[j] = $root.Ydb.Issue.IssueMessage.toObject(message.issues[j], options);
                }
                return object;
            };

            /**
             * Converts this IssueMessage to JSON.
             * @function toJSON
             * @memberof Ydb.Issue.IssueMessage
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            IssueMessage.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            IssueMessage.Position = (function() {

                /**
                 * Properties of a Position.
                 * @memberof Ydb.Issue.IssueMessage
                 * @interface IPosition
                 * @property {number|null} [row] Position row
                 * @property {number|null} [column] Position column
                 * @property {string|null} [file] Position file
                 */

                /**
                 * Constructs a new Position.
                 * @memberof Ydb.Issue.IssueMessage
                 * @classdesc Represents a Position.
                 * @implements IPosition
                 * @constructor
                 * @param {Ydb.Issue.IssueMessage.IPosition=} [properties] Properties to set
                 */
                function Position(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Position row.
                 * @member {number} row
                 * @memberof Ydb.Issue.IssueMessage.Position
                 * @instance
                 */
                Position.prototype.row = 0;

                /**
                 * Position column.
                 * @member {number} column
                 * @memberof Ydb.Issue.IssueMessage.Position
                 * @instance
                 */
                Position.prototype.column = 0;

                /**
                 * Position file.
                 * @member {string} file
                 * @memberof Ydb.Issue.IssueMessage.Position
                 * @instance
                 */
                Position.prototype.file = "";

                /**
                 * Creates a new Position instance using the specified properties.
                 * @function create
                 * @memberof Ydb.Issue.IssueMessage.Position
                 * @static
                 * @param {Ydb.Issue.IssueMessage.IPosition=} [properties] Properties to set
                 * @returns {Ydb.Issue.IssueMessage.Position} Position instance
                 */
                Position.create = function create(properties) {
                    return new Position(properties);
                };

                /**
                 * Encodes the specified Position message. Does not implicitly {@link Ydb.Issue.IssueMessage.Position.verify|verify} messages.
                 * @function encode
                 * @memberof Ydb.Issue.IssueMessage.Position
                 * @static
                 * @param {Ydb.Issue.IssueMessage.IPosition} message Position message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Position.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.row != null && Object.hasOwnProperty.call(message, "row"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.row);
                    if (message.column != null && Object.hasOwnProperty.call(message, "column"))
                        writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.column);
                    if (message.file != null && Object.hasOwnProperty.call(message, "file"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.file);
                    return writer;
                };

                /**
                 * Encodes the specified Position message, length delimited. Does not implicitly {@link Ydb.Issue.IssueMessage.Position.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof Ydb.Issue.IssueMessage.Position
                 * @static
                 * @param {Ydb.Issue.IssueMessage.IPosition} message Position message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Position.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Position message from the specified reader or buffer.
                 * @function decode
                 * @memberof Ydb.Issue.IssueMessage.Position
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {Ydb.Issue.IssueMessage.Position} Position
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Position.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Issue.IssueMessage.Position();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.row = reader.uint32();
                            break;
                        case 2:
                            message.column = reader.uint32();
                            break;
                        case 3:
                            message.file = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Position message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof Ydb.Issue.IssueMessage.Position
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {Ydb.Issue.IssueMessage.Position} Position
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Position.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Position message.
                 * @function verify
                 * @memberof Ydb.Issue.IssueMessage.Position
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Position.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.row != null && message.hasOwnProperty("row"))
                        if (!$util.isInteger(message.row))
                            return "row: integer expected";
                    if (message.column != null && message.hasOwnProperty("column"))
                        if (!$util.isInteger(message.column))
                            return "column: integer expected";
                    if (message.file != null && message.hasOwnProperty("file"))
                        if (!$util.isString(message.file))
                            return "file: string expected";
                    return null;
                };

                /**
                 * Creates a Position message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof Ydb.Issue.IssueMessage.Position
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {Ydb.Issue.IssueMessage.Position} Position
                 */
                Position.fromObject = function fromObject(object) {
                    if (object instanceof $root.Ydb.Issue.IssueMessage.Position)
                        return object;
                    var message = new $root.Ydb.Issue.IssueMessage.Position();
                    if (object.row != null)
                        message.row = object.row >>> 0;
                    if (object.column != null)
                        message.column = object.column >>> 0;
                    if (object.file != null)
                        message.file = String(object.file);
                    return message;
                };

                /**
                 * Creates a plain object from a Position message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof Ydb.Issue.IssueMessage.Position
                 * @static
                 * @param {Ydb.Issue.IssueMessage.Position} message Position
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Position.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.row = 0;
                        object.column = 0;
                        object.file = "";
                    }
                    if (message.row != null && message.hasOwnProperty("row"))
                        object.row = message.row;
                    if (message.column != null && message.hasOwnProperty("column"))
                        object.column = message.column;
                    if (message.file != null && message.hasOwnProperty("file"))
                        object.file = message.file;
                    return object;
                };

                /**
                 * Converts this Position to JSON.
                 * @function toJSON
                 * @memberof Ydb.Issue.IssueMessage.Position
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Position.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Position;
            })();

            return IssueMessage;
        })();

        return Issue;
    })();

    Ydb.Operations = (function() {

        /**
         * Namespace Operations.
         * @memberof Ydb
         * @namespace
         */
        var Operations = {};

        Operations.OperationParams = (function() {

            /**
             * Properties of an OperationParams.
             * @memberof Ydb.Operations
             * @interface IOperationParams
             * @property {Ydb.Operations.OperationParams.OperationMode|null} [operationMode] OperationParams operationMode
             * @property {google.protobuf.IDuration|null} [operationTimeout] OperationParams operationTimeout
             * @property {google.protobuf.IDuration|null} [cancelAfter] OperationParams cancelAfter
             * @property {Object.<string,string>|null} [labels] OperationParams labels
             * @property {Ydb.FeatureFlag.Status|null} [reportCostInfo] OperationParams reportCostInfo
             */

            /**
             * Constructs a new OperationParams.
             * @memberof Ydb.Operations
             * @classdesc Represents an OperationParams.
             * @implements IOperationParams
             * @constructor
             * @param {Ydb.Operations.IOperationParams=} [properties] Properties to set
             */
            function OperationParams(properties) {
                this.labels = {};
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * OperationParams operationMode.
             * @member {Ydb.Operations.OperationParams.OperationMode} operationMode
             * @memberof Ydb.Operations.OperationParams
             * @instance
             */
            OperationParams.prototype.operationMode = 0;

            /**
             * OperationParams operationTimeout.
             * @member {google.protobuf.IDuration|null|undefined} operationTimeout
             * @memberof Ydb.Operations.OperationParams
             * @instance
             */
            OperationParams.prototype.operationTimeout = null;

            /**
             * OperationParams cancelAfter.
             * @member {google.protobuf.IDuration|null|undefined} cancelAfter
             * @memberof Ydb.Operations.OperationParams
             * @instance
             */
            OperationParams.prototype.cancelAfter = null;

            /**
             * OperationParams labels.
             * @member {Object.<string,string>} labels
             * @memberof Ydb.Operations.OperationParams
             * @instance
             */
            OperationParams.prototype.labels = $util.emptyObject;

            /**
             * OperationParams reportCostInfo.
             * @member {Ydb.FeatureFlag.Status} reportCostInfo
             * @memberof Ydb.Operations.OperationParams
             * @instance
             */
            OperationParams.prototype.reportCostInfo = 0;

            /**
             * Creates a new OperationParams instance using the specified properties.
             * @function create
             * @memberof Ydb.Operations.OperationParams
             * @static
             * @param {Ydb.Operations.IOperationParams=} [properties] Properties to set
             * @returns {Ydb.Operations.OperationParams} OperationParams instance
             */
            OperationParams.create = function create(properties) {
                return new OperationParams(properties);
            };

            /**
             * Encodes the specified OperationParams message. Does not implicitly {@link Ydb.Operations.OperationParams.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Operations.OperationParams
             * @static
             * @param {Ydb.Operations.IOperationParams} message OperationParams message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OperationParams.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.operationMode != null && Object.hasOwnProperty.call(message, "operationMode"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.operationMode);
                if (message.operationTimeout != null && Object.hasOwnProperty.call(message, "operationTimeout"))
                    $root.google.protobuf.Duration.encode(message.operationTimeout, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.cancelAfter != null && Object.hasOwnProperty.call(message, "cancelAfter"))
                    $root.google.protobuf.Duration.encode(message.cancelAfter, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.labels != null && Object.hasOwnProperty.call(message, "labels"))
                    for (var keys = Object.keys(message.labels), i = 0; i < keys.length; ++i)
                        writer.uint32(/* id 4, wireType 2 =*/34).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.labels[keys[i]]).ldelim();
                if (message.reportCostInfo != null && Object.hasOwnProperty.call(message, "reportCostInfo"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.reportCostInfo);
                return writer;
            };

            /**
             * Encodes the specified OperationParams message, length delimited. Does not implicitly {@link Ydb.Operations.OperationParams.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Operations.OperationParams
             * @static
             * @param {Ydb.Operations.IOperationParams} message OperationParams message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OperationParams.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an OperationParams message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Operations.OperationParams
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Operations.OperationParams} OperationParams
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OperationParams.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Operations.OperationParams(), key, value;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.operationMode = reader.int32();
                        break;
                    case 2:
                        message.operationTimeout = $root.google.protobuf.Duration.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.cancelAfter = $root.google.protobuf.Duration.decode(reader, reader.uint32());
                        break;
                    case 4:
                        if (message.labels === $util.emptyObject)
                            message.labels = {};
                        var end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = "";
                        while (reader.pos < end2) {
                            var tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = reader.string();
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.labels[key] = value;
                        break;
                    case 5:
                        message.reportCostInfo = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an OperationParams message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Operations.OperationParams
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Operations.OperationParams} OperationParams
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OperationParams.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an OperationParams message.
             * @function verify
             * @memberof Ydb.Operations.OperationParams
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            OperationParams.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.operationMode != null && message.hasOwnProperty("operationMode"))
                    switch (message.operationMode) {
                    default:
                        return "operationMode: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                if (message.operationTimeout != null && message.hasOwnProperty("operationTimeout")) {
                    var error = $root.google.protobuf.Duration.verify(message.operationTimeout);
                    if (error)
                        return "operationTimeout." + error;
                }
                if (message.cancelAfter != null && message.hasOwnProperty("cancelAfter")) {
                    var error = $root.google.protobuf.Duration.verify(message.cancelAfter);
                    if (error)
                        return "cancelAfter." + error;
                }
                if (message.labels != null && message.hasOwnProperty("labels")) {
                    if (!$util.isObject(message.labels))
                        return "labels: object expected";
                    var key = Object.keys(message.labels);
                    for (var i = 0; i < key.length; ++i)
                        if (!$util.isString(message.labels[key[i]]))
                            return "labels: string{k:string} expected";
                }
                if (message.reportCostInfo != null && message.hasOwnProperty("reportCostInfo"))
                    switch (message.reportCostInfo) {
                    default:
                        return "reportCostInfo: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                return null;
            };

            /**
             * Creates an OperationParams message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Operations.OperationParams
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Operations.OperationParams} OperationParams
             */
            OperationParams.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Operations.OperationParams)
                    return object;
                var message = new $root.Ydb.Operations.OperationParams();
                switch (object.operationMode) {
                case "OPERATION_MODE_UNSPECIFIED":
                case 0:
                    message.operationMode = 0;
                    break;
                case "SYNC":
                case 1:
                    message.operationMode = 1;
                    break;
                case "ASYNC":
                case 2:
                    message.operationMode = 2;
                    break;
                }
                if (object.operationTimeout != null) {
                    if (typeof object.operationTimeout !== "object")
                        throw TypeError(".Ydb.Operations.OperationParams.operationTimeout: object expected");
                    message.operationTimeout = $root.google.protobuf.Duration.fromObject(object.operationTimeout);
                }
                if (object.cancelAfter != null) {
                    if (typeof object.cancelAfter !== "object")
                        throw TypeError(".Ydb.Operations.OperationParams.cancelAfter: object expected");
                    message.cancelAfter = $root.google.protobuf.Duration.fromObject(object.cancelAfter);
                }
                if (object.labels) {
                    if (typeof object.labels !== "object")
                        throw TypeError(".Ydb.Operations.OperationParams.labels: object expected");
                    message.labels = {};
                    for (var keys = Object.keys(object.labels), i = 0; i < keys.length; ++i)
                        message.labels[keys[i]] = String(object.labels[keys[i]]);
                }
                switch (object.reportCostInfo) {
                case "STATUS_UNSPECIFIED":
                case 0:
                    message.reportCostInfo = 0;
                    break;
                case "ENABLED":
                case 1:
                    message.reportCostInfo = 1;
                    break;
                case "DISABLED":
                case 2:
                    message.reportCostInfo = 2;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from an OperationParams message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Operations.OperationParams
             * @static
             * @param {Ydb.Operations.OperationParams} message OperationParams
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            OperationParams.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.objects || options.defaults)
                    object.labels = {};
                if (options.defaults) {
                    object.operationMode = options.enums === String ? "OPERATION_MODE_UNSPECIFIED" : 0;
                    object.operationTimeout = null;
                    object.cancelAfter = null;
                    object.reportCostInfo = options.enums === String ? "STATUS_UNSPECIFIED" : 0;
                }
                if (message.operationMode != null && message.hasOwnProperty("operationMode"))
                    object.operationMode = options.enums === String ? $root.Ydb.Operations.OperationParams.OperationMode[message.operationMode] : message.operationMode;
                if (message.operationTimeout != null && message.hasOwnProperty("operationTimeout"))
                    object.operationTimeout = $root.google.protobuf.Duration.toObject(message.operationTimeout, options);
                if (message.cancelAfter != null && message.hasOwnProperty("cancelAfter"))
                    object.cancelAfter = $root.google.protobuf.Duration.toObject(message.cancelAfter, options);
                var keys2;
                if (message.labels && (keys2 = Object.keys(message.labels)).length) {
                    object.labels = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.labels[keys2[j]] = message.labels[keys2[j]];
                }
                if (message.reportCostInfo != null && message.hasOwnProperty("reportCostInfo"))
                    object.reportCostInfo = options.enums === String ? $root.Ydb.FeatureFlag.Status[message.reportCostInfo] : message.reportCostInfo;
                return object;
            };

            /**
             * Converts this OperationParams to JSON.
             * @function toJSON
             * @memberof Ydb.Operations.OperationParams
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            OperationParams.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * OperationMode enum.
             * @name Ydb.Operations.OperationParams.OperationMode
             * @enum {number}
             * @property {number} OPERATION_MODE_UNSPECIFIED=0 OPERATION_MODE_UNSPECIFIED value
             * @property {number} SYNC=1 SYNC value
             * @property {number} ASYNC=2 ASYNC value
             */
            OperationParams.OperationMode = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "OPERATION_MODE_UNSPECIFIED"] = 0;
                values[valuesById[1] = "SYNC"] = 1;
                values[valuesById[2] = "ASYNC"] = 2;
                return values;
            })();

            return OperationParams;
        })();

        Operations.GetOperationRequest = (function() {

            /**
             * Properties of a GetOperationRequest.
             * @memberof Ydb.Operations
             * @interface IGetOperationRequest
             * @property {string|null} [id] GetOperationRequest id
             */

            /**
             * Constructs a new GetOperationRequest.
             * @memberof Ydb.Operations
             * @classdesc Represents a GetOperationRequest.
             * @implements IGetOperationRequest
             * @constructor
             * @param {Ydb.Operations.IGetOperationRequest=} [properties] Properties to set
             */
            function GetOperationRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetOperationRequest id.
             * @member {string} id
             * @memberof Ydb.Operations.GetOperationRequest
             * @instance
             */
            GetOperationRequest.prototype.id = "";

            /**
             * Creates a new GetOperationRequest instance using the specified properties.
             * @function create
             * @memberof Ydb.Operations.GetOperationRequest
             * @static
             * @param {Ydb.Operations.IGetOperationRequest=} [properties] Properties to set
             * @returns {Ydb.Operations.GetOperationRequest} GetOperationRequest instance
             */
            GetOperationRequest.create = function create(properties) {
                return new GetOperationRequest(properties);
            };

            /**
             * Encodes the specified GetOperationRequest message. Does not implicitly {@link Ydb.Operations.GetOperationRequest.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Operations.GetOperationRequest
             * @static
             * @param {Ydb.Operations.IGetOperationRequest} message GetOperationRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetOperationRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                return writer;
            };

            /**
             * Encodes the specified GetOperationRequest message, length delimited. Does not implicitly {@link Ydb.Operations.GetOperationRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Operations.GetOperationRequest
             * @static
             * @param {Ydb.Operations.IGetOperationRequest} message GetOperationRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetOperationRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetOperationRequest message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Operations.GetOperationRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Operations.GetOperationRequest} GetOperationRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetOperationRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Operations.GetOperationRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetOperationRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Operations.GetOperationRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Operations.GetOperationRequest} GetOperationRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetOperationRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetOperationRequest message.
             * @function verify
             * @memberof Ydb.Operations.GetOperationRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetOperationRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isString(message.id))
                        return "id: string expected";
                return null;
            };

            /**
             * Creates a GetOperationRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Operations.GetOperationRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Operations.GetOperationRequest} GetOperationRequest
             */
            GetOperationRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Operations.GetOperationRequest)
                    return object;
                var message = new $root.Ydb.Operations.GetOperationRequest();
                if (object.id != null)
                    message.id = String(object.id);
                return message;
            };

            /**
             * Creates a plain object from a GetOperationRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Operations.GetOperationRequest
             * @static
             * @param {Ydb.Operations.GetOperationRequest} message GetOperationRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetOperationRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.id = "";
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                return object;
            };

            /**
             * Converts this GetOperationRequest to JSON.
             * @function toJSON
             * @memberof Ydb.Operations.GetOperationRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetOperationRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return GetOperationRequest;
        })();

        Operations.GetOperationResponse = (function() {

            /**
             * Properties of a GetOperationResponse.
             * @memberof Ydb.Operations
             * @interface IGetOperationResponse
             * @property {Ydb.Operations.IOperation|null} [operation] GetOperationResponse operation
             */

            /**
             * Constructs a new GetOperationResponse.
             * @memberof Ydb.Operations
             * @classdesc Represents a GetOperationResponse.
             * @implements IGetOperationResponse
             * @constructor
             * @param {Ydb.Operations.IGetOperationResponse=} [properties] Properties to set
             */
            function GetOperationResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetOperationResponse operation.
             * @member {Ydb.Operations.IOperation|null|undefined} operation
             * @memberof Ydb.Operations.GetOperationResponse
             * @instance
             */
            GetOperationResponse.prototype.operation = null;

            /**
             * Creates a new GetOperationResponse instance using the specified properties.
             * @function create
             * @memberof Ydb.Operations.GetOperationResponse
             * @static
             * @param {Ydb.Operations.IGetOperationResponse=} [properties] Properties to set
             * @returns {Ydb.Operations.GetOperationResponse} GetOperationResponse instance
             */
            GetOperationResponse.create = function create(properties) {
                return new GetOperationResponse(properties);
            };

            /**
             * Encodes the specified GetOperationResponse message. Does not implicitly {@link Ydb.Operations.GetOperationResponse.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Operations.GetOperationResponse
             * @static
             * @param {Ydb.Operations.IGetOperationResponse} message GetOperationResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetOperationResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.operation != null && Object.hasOwnProperty.call(message, "operation"))
                    $root.Ydb.Operations.Operation.encode(message.operation, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified GetOperationResponse message, length delimited. Does not implicitly {@link Ydb.Operations.GetOperationResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Operations.GetOperationResponse
             * @static
             * @param {Ydb.Operations.IGetOperationResponse} message GetOperationResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetOperationResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetOperationResponse message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Operations.GetOperationResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Operations.GetOperationResponse} GetOperationResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetOperationResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Operations.GetOperationResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.operation = $root.Ydb.Operations.Operation.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetOperationResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Operations.GetOperationResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Operations.GetOperationResponse} GetOperationResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetOperationResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetOperationResponse message.
             * @function verify
             * @memberof Ydb.Operations.GetOperationResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetOperationResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.operation != null && message.hasOwnProperty("operation")) {
                    var error = $root.Ydb.Operations.Operation.verify(message.operation);
                    if (error)
                        return "operation." + error;
                }
                return null;
            };

            /**
             * Creates a GetOperationResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Operations.GetOperationResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Operations.GetOperationResponse} GetOperationResponse
             */
            GetOperationResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Operations.GetOperationResponse)
                    return object;
                var message = new $root.Ydb.Operations.GetOperationResponse();
                if (object.operation != null) {
                    if (typeof object.operation !== "object")
                        throw TypeError(".Ydb.Operations.GetOperationResponse.operation: object expected");
                    message.operation = $root.Ydb.Operations.Operation.fromObject(object.operation);
                }
                return message;
            };

            /**
             * Creates a plain object from a GetOperationResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Operations.GetOperationResponse
             * @static
             * @param {Ydb.Operations.GetOperationResponse} message GetOperationResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetOperationResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.operation = null;
                if (message.operation != null && message.hasOwnProperty("operation"))
                    object.operation = $root.Ydb.Operations.Operation.toObject(message.operation, options);
                return object;
            };

            /**
             * Converts this GetOperationResponse to JSON.
             * @function toJSON
             * @memberof Ydb.Operations.GetOperationResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetOperationResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return GetOperationResponse;
        })();

        Operations.CancelOperationRequest = (function() {

            /**
             * Properties of a CancelOperationRequest.
             * @memberof Ydb.Operations
             * @interface ICancelOperationRequest
             * @property {string|null} [id] CancelOperationRequest id
             */

            /**
             * Constructs a new CancelOperationRequest.
             * @memberof Ydb.Operations
             * @classdesc Represents a CancelOperationRequest.
             * @implements ICancelOperationRequest
             * @constructor
             * @param {Ydb.Operations.ICancelOperationRequest=} [properties] Properties to set
             */
            function CancelOperationRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CancelOperationRequest id.
             * @member {string} id
             * @memberof Ydb.Operations.CancelOperationRequest
             * @instance
             */
            CancelOperationRequest.prototype.id = "";

            /**
             * Creates a new CancelOperationRequest instance using the specified properties.
             * @function create
             * @memberof Ydb.Operations.CancelOperationRequest
             * @static
             * @param {Ydb.Operations.ICancelOperationRequest=} [properties] Properties to set
             * @returns {Ydb.Operations.CancelOperationRequest} CancelOperationRequest instance
             */
            CancelOperationRequest.create = function create(properties) {
                return new CancelOperationRequest(properties);
            };

            /**
             * Encodes the specified CancelOperationRequest message. Does not implicitly {@link Ydb.Operations.CancelOperationRequest.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Operations.CancelOperationRequest
             * @static
             * @param {Ydb.Operations.ICancelOperationRequest} message CancelOperationRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CancelOperationRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                return writer;
            };

            /**
             * Encodes the specified CancelOperationRequest message, length delimited. Does not implicitly {@link Ydb.Operations.CancelOperationRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Operations.CancelOperationRequest
             * @static
             * @param {Ydb.Operations.ICancelOperationRequest} message CancelOperationRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CancelOperationRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CancelOperationRequest message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Operations.CancelOperationRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Operations.CancelOperationRequest} CancelOperationRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CancelOperationRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Operations.CancelOperationRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a CancelOperationRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Operations.CancelOperationRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Operations.CancelOperationRequest} CancelOperationRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CancelOperationRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CancelOperationRequest message.
             * @function verify
             * @memberof Ydb.Operations.CancelOperationRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CancelOperationRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isString(message.id))
                        return "id: string expected";
                return null;
            };

            /**
             * Creates a CancelOperationRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Operations.CancelOperationRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Operations.CancelOperationRequest} CancelOperationRequest
             */
            CancelOperationRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Operations.CancelOperationRequest)
                    return object;
                var message = new $root.Ydb.Operations.CancelOperationRequest();
                if (object.id != null)
                    message.id = String(object.id);
                return message;
            };

            /**
             * Creates a plain object from a CancelOperationRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Operations.CancelOperationRequest
             * @static
             * @param {Ydb.Operations.CancelOperationRequest} message CancelOperationRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CancelOperationRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.id = "";
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                return object;
            };

            /**
             * Converts this CancelOperationRequest to JSON.
             * @function toJSON
             * @memberof Ydb.Operations.CancelOperationRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CancelOperationRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return CancelOperationRequest;
        })();

        Operations.CancelOperationResponse = (function() {

            /**
             * Properties of a CancelOperationResponse.
             * @memberof Ydb.Operations
             * @interface ICancelOperationResponse
             * @property {Ydb.StatusIds.StatusCode|null} [status] CancelOperationResponse status
             * @property {Array.<Ydb.Issue.IIssueMessage>|null} [issues] CancelOperationResponse issues
             */

            /**
             * Constructs a new CancelOperationResponse.
             * @memberof Ydb.Operations
             * @classdesc Represents a CancelOperationResponse.
             * @implements ICancelOperationResponse
             * @constructor
             * @param {Ydb.Operations.ICancelOperationResponse=} [properties] Properties to set
             */
            function CancelOperationResponse(properties) {
                this.issues = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CancelOperationResponse status.
             * @member {Ydb.StatusIds.StatusCode} status
             * @memberof Ydb.Operations.CancelOperationResponse
             * @instance
             */
            CancelOperationResponse.prototype.status = 0;

            /**
             * CancelOperationResponse issues.
             * @member {Array.<Ydb.Issue.IIssueMessage>} issues
             * @memberof Ydb.Operations.CancelOperationResponse
             * @instance
             */
            CancelOperationResponse.prototype.issues = $util.emptyArray;

            /**
             * Creates a new CancelOperationResponse instance using the specified properties.
             * @function create
             * @memberof Ydb.Operations.CancelOperationResponse
             * @static
             * @param {Ydb.Operations.ICancelOperationResponse=} [properties] Properties to set
             * @returns {Ydb.Operations.CancelOperationResponse} CancelOperationResponse instance
             */
            CancelOperationResponse.create = function create(properties) {
                return new CancelOperationResponse(properties);
            };

            /**
             * Encodes the specified CancelOperationResponse message. Does not implicitly {@link Ydb.Operations.CancelOperationResponse.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Operations.CancelOperationResponse
             * @static
             * @param {Ydb.Operations.ICancelOperationResponse} message CancelOperationResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CancelOperationResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.status);
                if (message.issues != null && message.issues.length)
                    for (var i = 0; i < message.issues.length; ++i)
                        $root.Ydb.Issue.IssueMessage.encode(message.issues[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified CancelOperationResponse message, length delimited. Does not implicitly {@link Ydb.Operations.CancelOperationResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Operations.CancelOperationResponse
             * @static
             * @param {Ydb.Operations.ICancelOperationResponse} message CancelOperationResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CancelOperationResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CancelOperationResponse message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Operations.CancelOperationResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Operations.CancelOperationResponse} CancelOperationResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CancelOperationResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Operations.CancelOperationResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.status = reader.int32();
                        break;
                    case 2:
                        if (!(message.issues && message.issues.length))
                            message.issues = [];
                        message.issues.push($root.Ydb.Issue.IssueMessage.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a CancelOperationResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Operations.CancelOperationResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Operations.CancelOperationResponse} CancelOperationResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CancelOperationResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CancelOperationResponse message.
             * @function verify
             * @memberof Ydb.Operations.CancelOperationResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CancelOperationResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.status != null && message.hasOwnProperty("status"))
                    switch (message.status) {
                    default:
                        return "status: enum value expected";
                    case 0:
                    case 400000:
                    case 400010:
                    case 400020:
                    case 400030:
                    case 400040:
                    case 400050:
                    case 400060:
                    case 400070:
                    case 400080:
                    case 400090:
                    case 400100:
                    case 400120:
                    case 400130:
                    case 400140:
                    case 400150:
                    case 400160:
                    case 400170:
                    case 400180:
                    case 400190:
                        break;
                    }
                if (message.issues != null && message.hasOwnProperty("issues")) {
                    if (!Array.isArray(message.issues))
                        return "issues: array expected";
                    for (var i = 0; i < message.issues.length; ++i) {
                        var error = $root.Ydb.Issue.IssueMessage.verify(message.issues[i]);
                        if (error)
                            return "issues." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a CancelOperationResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Operations.CancelOperationResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Operations.CancelOperationResponse} CancelOperationResponse
             */
            CancelOperationResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Operations.CancelOperationResponse)
                    return object;
                var message = new $root.Ydb.Operations.CancelOperationResponse();
                switch (object.status) {
                case "STATUS_CODE_UNSPECIFIED":
                case 0:
                    message.status = 0;
                    break;
                case "SUCCESS":
                case 400000:
                    message.status = 400000;
                    break;
                case "BAD_REQUEST":
                case 400010:
                    message.status = 400010;
                    break;
                case "UNAUTHORIZED":
                case 400020:
                    message.status = 400020;
                    break;
                case "INTERNAL_ERROR":
                case 400030:
                    message.status = 400030;
                    break;
                case "ABORTED":
                case 400040:
                    message.status = 400040;
                    break;
                case "UNAVAILABLE":
                case 400050:
                    message.status = 400050;
                    break;
                case "OVERLOADED":
                case 400060:
                    message.status = 400060;
                    break;
                case "SCHEME_ERROR":
                case 400070:
                    message.status = 400070;
                    break;
                case "GENERIC_ERROR":
                case 400080:
                    message.status = 400080;
                    break;
                case "TIMEOUT":
                case 400090:
                    message.status = 400090;
                    break;
                case "BAD_SESSION":
                case 400100:
                    message.status = 400100;
                    break;
                case "PRECONDITION_FAILED":
                case 400120:
                    message.status = 400120;
                    break;
                case "ALREADY_EXISTS":
                case 400130:
                    message.status = 400130;
                    break;
                case "NOT_FOUND":
                case 400140:
                    message.status = 400140;
                    break;
                case "SESSION_EXPIRED":
                case 400150:
                    message.status = 400150;
                    break;
                case "CANCELLED":
                case 400160:
                    message.status = 400160;
                    break;
                case "UNDETERMINED":
                case 400170:
                    message.status = 400170;
                    break;
                case "UNSUPPORTED":
                case 400180:
                    message.status = 400180;
                    break;
                case "SESSION_BUSY":
                case 400190:
                    message.status = 400190;
                    break;
                }
                if (object.issues) {
                    if (!Array.isArray(object.issues))
                        throw TypeError(".Ydb.Operations.CancelOperationResponse.issues: array expected");
                    message.issues = [];
                    for (var i = 0; i < object.issues.length; ++i) {
                        if (typeof object.issues[i] !== "object")
                            throw TypeError(".Ydb.Operations.CancelOperationResponse.issues: object expected");
                        message.issues[i] = $root.Ydb.Issue.IssueMessage.fromObject(object.issues[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a CancelOperationResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Operations.CancelOperationResponse
             * @static
             * @param {Ydb.Operations.CancelOperationResponse} message CancelOperationResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CancelOperationResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.issues = [];
                if (options.defaults)
                    object.status = options.enums === String ? "STATUS_CODE_UNSPECIFIED" : 0;
                if (message.status != null && message.hasOwnProperty("status"))
                    object.status = options.enums === String ? $root.Ydb.StatusIds.StatusCode[message.status] : message.status;
                if (message.issues && message.issues.length) {
                    object.issues = [];
                    for (var j = 0; j < message.issues.length; ++j)
                        object.issues[j] = $root.Ydb.Issue.IssueMessage.toObject(message.issues[j], options);
                }
                return object;
            };

            /**
             * Converts this CancelOperationResponse to JSON.
             * @function toJSON
             * @memberof Ydb.Operations.CancelOperationResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CancelOperationResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return CancelOperationResponse;
        })();

        Operations.ForgetOperationRequest = (function() {

            /**
             * Properties of a ForgetOperationRequest.
             * @memberof Ydb.Operations
             * @interface IForgetOperationRequest
             * @property {string|null} [id] ForgetOperationRequest id
             */

            /**
             * Constructs a new ForgetOperationRequest.
             * @memberof Ydb.Operations
             * @classdesc Represents a ForgetOperationRequest.
             * @implements IForgetOperationRequest
             * @constructor
             * @param {Ydb.Operations.IForgetOperationRequest=} [properties] Properties to set
             */
            function ForgetOperationRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ForgetOperationRequest id.
             * @member {string} id
             * @memberof Ydb.Operations.ForgetOperationRequest
             * @instance
             */
            ForgetOperationRequest.prototype.id = "";

            /**
             * Creates a new ForgetOperationRequest instance using the specified properties.
             * @function create
             * @memberof Ydb.Operations.ForgetOperationRequest
             * @static
             * @param {Ydb.Operations.IForgetOperationRequest=} [properties] Properties to set
             * @returns {Ydb.Operations.ForgetOperationRequest} ForgetOperationRequest instance
             */
            ForgetOperationRequest.create = function create(properties) {
                return new ForgetOperationRequest(properties);
            };

            /**
             * Encodes the specified ForgetOperationRequest message. Does not implicitly {@link Ydb.Operations.ForgetOperationRequest.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Operations.ForgetOperationRequest
             * @static
             * @param {Ydb.Operations.IForgetOperationRequest} message ForgetOperationRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ForgetOperationRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                return writer;
            };

            /**
             * Encodes the specified ForgetOperationRequest message, length delimited. Does not implicitly {@link Ydb.Operations.ForgetOperationRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Operations.ForgetOperationRequest
             * @static
             * @param {Ydb.Operations.IForgetOperationRequest} message ForgetOperationRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ForgetOperationRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ForgetOperationRequest message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Operations.ForgetOperationRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Operations.ForgetOperationRequest} ForgetOperationRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ForgetOperationRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Operations.ForgetOperationRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ForgetOperationRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Operations.ForgetOperationRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Operations.ForgetOperationRequest} ForgetOperationRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ForgetOperationRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ForgetOperationRequest message.
             * @function verify
             * @memberof Ydb.Operations.ForgetOperationRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ForgetOperationRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isString(message.id))
                        return "id: string expected";
                return null;
            };

            /**
             * Creates a ForgetOperationRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Operations.ForgetOperationRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Operations.ForgetOperationRequest} ForgetOperationRequest
             */
            ForgetOperationRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Operations.ForgetOperationRequest)
                    return object;
                var message = new $root.Ydb.Operations.ForgetOperationRequest();
                if (object.id != null)
                    message.id = String(object.id);
                return message;
            };

            /**
             * Creates a plain object from a ForgetOperationRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Operations.ForgetOperationRequest
             * @static
             * @param {Ydb.Operations.ForgetOperationRequest} message ForgetOperationRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ForgetOperationRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.id = "";
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                return object;
            };

            /**
             * Converts this ForgetOperationRequest to JSON.
             * @function toJSON
             * @memberof Ydb.Operations.ForgetOperationRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ForgetOperationRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ForgetOperationRequest;
        })();

        Operations.ForgetOperationResponse = (function() {

            /**
             * Properties of a ForgetOperationResponse.
             * @memberof Ydb.Operations
             * @interface IForgetOperationResponse
             * @property {Ydb.StatusIds.StatusCode|null} [status] ForgetOperationResponse status
             * @property {Array.<Ydb.Issue.IIssueMessage>|null} [issues] ForgetOperationResponse issues
             */

            /**
             * Constructs a new ForgetOperationResponse.
             * @memberof Ydb.Operations
             * @classdesc Represents a ForgetOperationResponse.
             * @implements IForgetOperationResponse
             * @constructor
             * @param {Ydb.Operations.IForgetOperationResponse=} [properties] Properties to set
             */
            function ForgetOperationResponse(properties) {
                this.issues = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ForgetOperationResponse status.
             * @member {Ydb.StatusIds.StatusCode} status
             * @memberof Ydb.Operations.ForgetOperationResponse
             * @instance
             */
            ForgetOperationResponse.prototype.status = 0;

            /**
             * ForgetOperationResponse issues.
             * @member {Array.<Ydb.Issue.IIssueMessage>} issues
             * @memberof Ydb.Operations.ForgetOperationResponse
             * @instance
             */
            ForgetOperationResponse.prototype.issues = $util.emptyArray;

            /**
             * Creates a new ForgetOperationResponse instance using the specified properties.
             * @function create
             * @memberof Ydb.Operations.ForgetOperationResponse
             * @static
             * @param {Ydb.Operations.IForgetOperationResponse=} [properties] Properties to set
             * @returns {Ydb.Operations.ForgetOperationResponse} ForgetOperationResponse instance
             */
            ForgetOperationResponse.create = function create(properties) {
                return new ForgetOperationResponse(properties);
            };

            /**
             * Encodes the specified ForgetOperationResponse message. Does not implicitly {@link Ydb.Operations.ForgetOperationResponse.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Operations.ForgetOperationResponse
             * @static
             * @param {Ydb.Operations.IForgetOperationResponse} message ForgetOperationResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ForgetOperationResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.status);
                if (message.issues != null && message.issues.length)
                    for (var i = 0; i < message.issues.length; ++i)
                        $root.Ydb.Issue.IssueMessage.encode(message.issues[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ForgetOperationResponse message, length delimited. Does not implicitly {@link Ydb.Operations.ForgetOperationResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Operations.ForgetOperationResponse
             * @static
             * @param {Ydb.Operations.IForgetOperationResponse} message ForgetOperationResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ForgetOperationResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ForgetOperationResponse message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Operations.ForgetOperationResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Operations.ForgetOperationResponse} ForgetOperationResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ForgetOperationResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Operations.ForgetOperationResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.status = reader.int32();
                        break;
                    case 2:
                        if (!(message.issues && message.issues.length))
                            message.issues = [];
                        message.issues.push($root.Ydb.Issue.IssueMessage.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ForgetOperationResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Operations.ForgetOperationResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Operations.ForgetOperationResponse} ForgetOperationResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ForgetOperationResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ForgetOperationResponse message.
             * @function verify
             * @memberof Ydb.Operations.ForgetOperationResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ForgetOperationResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.status != null && message.hasOwnProperty("status"))
                    switch (message.status) {
                    default:
                        return "status: enum value expected";
                    case 0:
                    case 400000:
                    case 400010:
                    case 400020:
                    case 400030:
                    case 400040:
                    case 400050:
                    case 400060:
                    case 400070:
                    case 400080:
                    case 400090:
                    case 400100:
                    case 400120:
                    case 400130:
                    case 400140:
                    case 400150:
                    case 400160:
                    case 400170:
                    case 400180:
                    case 400190:
                        break;
                    }
                if (message.issues != null && message.hasOwnProperty("issues")) {
                    if (!Array.isArray(message.issues))
                        return "issues: array expected";
                    for (var i = 0; i < message.issues.length; ++i) {
                        var error = $root.Ydb.Issue.IssueMessage.verify(message.issues[i]);
                        if (error)
                            return "issues." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a ForgetOperationResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Operations.ForgetOperationResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Operations.ForgetOperationResponse} ForgetOperationResponse
             */
            ForgetOperationResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Operations.ForgetOperationResponse)
                    return object;
                var message = new $root.Ydb.Operations.ForgetOperationResponse();
                switch (object.status) {
                case "STATUS_CODE_UNSPECIFIED":
                case 0:
                    message.status = 0;
                    break;
                case "SUCCESS":
                case 400000:
                    message.status = 400000;
                    break;
                case "BAD_REQUEST":
                case 400010:
                    message.status = 400010;
                    break;
                case "UNAUTHORIZED":
                case 400020:
                    message.status = 400020;
                    break;
                case "INTERNAL_ERROR":
                case 400030:
                    message.status = 400030;
                    break;
                case "ABORTED":
                case 400040:
                    message.status = 400040;
                    break;
                case "UNAVAILABLE":
                case 400050:
                    message.status = 400050;
                    break;
                case "OVERLOADED":
                case 400060:
                    message.status = 400060;
                    break;
                case "SCHEME_ERROR":
                case 400070:
                    message.status = 400070;
                    break;
                case "GENERIC_ERROR":
                case 400080:
                    message.status = 400080;
                    break;
                case "TIMEOUT":
                case 400090:
                    message.status = 400090;
                    break;
                case "BAD_SESSION":
                case 400100:
                    message.status = 400100;
                    break;
                case "PRECONDITION_FAILED":
                case 400120:
                    message.status = 400120;
                    break;
                case "ALREADY_EXISTS":
                case 400130:
                    message.status = 400130;
                    break;
                case "NOT_FOUND":
                case 400140:
                    message.status = 400140;
                    break;
                case "SESSION_EXPIRED":
                case 400150:
                    message.status = 400150;
                    break;
                case "CANCELLED":
                case 400160:
                    message.status = 400160;
                    break;
                case "UNDETERMINED":
                case 400170:
                    message.status = 400170;
                    break;
                case "UNSUPPORTED":
                case 400180:
                    message.status = 400180;
                    break;
                case "SESSION_BUSY":
                case 400190:
                    message.status = 400190;
                    break;
                }
                if (object.issues) {
                    if (!Array.isArray(object.issues))
                        throw TypeError(".Ydb.Operations.ForgetOperationResponse.issues: array expected");
                    message.issues = [];
                    for (var i = 0; i < object.issues.length; ++i) {
                        if (typeof object.issues[i] !== "object")
                            throw TypeError(".Ydb.Operations.ForgetOperationResponse.issues: object expected");
                        message.issues[i] = $root.Ydb.Issue.IssueMessage.fromObject(object.issues[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a ForgetOperationResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Operations.ForgetOperationResponse
             * @static
             * @param {Ydb.Operations.ForgetOperationResponse} message ForgetOperationResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ForgetOperationResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.issues = [];
                if (options.defaults)
                    object.status = options.enums === String ? "STATUS_CODE_UNSPECIFIED" : 0;
                if (message.status != null && message.hasOwnProperty("status"))
                    object.status = options.enums === String ? $root.Ydb.StatusIds.StatusCode[message.status] : message.status;
                if (message.issues && message.issues.length) {
                    object.issues = [];
                    for (var j = 0; j < message.issues.length; ++j)
                        object.issues[j] = $root.Ydb.Issue.IssueMessage.toObject(message.issues[j], options);
                }
                return object;
            };

            /**
             * Converts this ForgetOperationResponse to JSON.
             * @function toJSON
             * @memberof Ydb.Operations.ForgetOperationResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ForgetOperationResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ForgetOperationResponse;
        })();

        Operations.ListOperationsRequest = (function() {

            /**
             * Properties of a ListOperationsRequest.
             * @memberof Ydb.Operations
             * @interface IListOperationsRequest
             * @property {string|null} [kind] ListOperationsRequest kind
             * @property {number|Long|null} [pageSize] ListOperationsRequest pageSize
             * @property {string|null} [pageToken] ListOperationsRequest pageToken
             */

            /**
             * Constructs a new ListOperationsRequest.
             * @memberof Ydb.Operations
             * @classdesc Represents a ListOperationsRequest.
             * @implements IListOperationsRequest
             * @constructor
             * @param {Ydb.Operations.IListOperationsRequest=} [properties] Properties to set
             */
            function ListOperationsRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ListOperationsRequest kind.
             * @member {string} kind
             * @memberof Ydb.Operations.ListOperationsRequest
             * @instance
             */
            ListOperationsRequest.prototype.kind = "";

            /**
             * ListOperationsRequest pageSize.
             * @member {number|Long} pageSize
             * @memberof Ydb.Operations.ListOperationsRequest
             * @instance
             */
            ListOperationsRequest.prototype.pageSize = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * ListOperationsRequest pageToken.
             * @member {string} pageToken
             * @memberof Ydb.Operations.ListOperationsRequest
             * @instance
             */
            ListOperationsRequest.prototype.pageToken = "";

            /**
             * Creates a new ListOperationsRequest instance using the specified properties.
             * @function create
             * @memberof Ydb.Operations.ListOperationsRequest
             * @static
             * @param {Ydb.Operations.IListOperationsRequest=} [properties] Properties to set
             * @returns {Ydb.Operations.ListOperationsRequest} ListOperationsRequest instance
             */
            ListOperationsRequest.create = function create(properties) {
                return new ListOperationsRequest(properties);
            };

            /**
             * Encodes the specified ListOperationsRequest message. Does not implicitly {@link Ydb.Operations.ListOperationsRequest.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Operations.ListOperationsRequest
             * @static
             * @param {Ydb.Operations.IListOperationsRequest} message ListOperationsRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ListOperationsRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.kind != null && Object.hasOwnProperty.call(message, "kind"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.kind);
                if (message.pageSize != null && Object.hasOwnProperty.call(message, "pageSize"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.pageSize);
                if (message.pageToken != null && Object.hasOwnProperty.call(message, "pageToken"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.pageToken);
                return writer;
            };

            /**
             * Encodes the specified ListOperationsRequest message, length delimited. Does not implicitly {@link Ydb.Operations.ListOperationsRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Operations.ListOperationsRequest
             * @static
             * @param {Ydb.Operations.IListOperationsRequest} message ListOperationsRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ListOperationsRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ListOperationsRequest message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Operations.ListOperationsRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Operations.ListOperationsRequest} ListOperationsRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ListOperationsRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Operations.ListOperationsRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.kind = reader.string();
                        break;
                    case 2:
                        message.pageSize = reader.uint64();
                        break;
                    case 3:
                        message.pageToken = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ListOperationsRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Operations.ListOperationsRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Operations.ListOperationsRequest} ListOperationsRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ListOperationsRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ListOperationsRequest message.
             * @function verify
             * @memberof Ydb.Operations.ListOperationsRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ListOperationsRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.kind != null && message.hasOwnProperty("kind"))
                    if (!$util.isString(message.kind))
                        return "kind: string expected";
                if (message.pageSize != null && message.hasOwnProperty("pageSize"))
                    if (!$util.isInteger(message.pageSize) && !(message.pageSize && $util.isInteger(message.pageSize.low) && $util.isInteger(message.pageSize.high)))
                        return "pageSize: integer|Long expected";
                if (message.pageToken != null && message.hasOwnProperty("pageToken"))
                    if (!$util.isString(message.pageToken))
                        return "pageToken: string expected";
                return null;
            };

            /**
             * Creates a ListOperationsRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Operations.ListOperationsRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Operations.ListOperationsRequest} ListOperationsRequest
             */
            ListOperationsRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Operations.ListOperationsRequest)
                    return object;
                var message = new $root.Ydb.Operations.ListOperationsRequest();
                if (object.kind != null)
                    message.kind = String(object.kind);
                if (object.pageSize != null)
                    if ($util.Long)
                        (message.pageSize = $util.Long.fromValue(object.pageSize)).unsigned = true;
                    else if (typeof object.pageSize === "string")
                        message.pageSize = parseInt(object.pageSize, 10);
                    else if (typeof object.pageSize === "number")
                        message.pageSize = object.pageSize;
                    else if (typeof object.pageSize === "object")
                        message.pageSize = new $util.LongBits(object.pageSize.low >>> 0, object.pageSize.high >>> 0).toNumber(true);
                if (object.pageToken != null)
                    message.pageToken = String(object.pageToken);
                return message;
            };

            /**
             * Creates a plain object from a ListOperationsRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Operations.ListOperationsRequest
             * @static
             * @param {Ydb.Operations.ListOperationsRequest} message ListOperationsRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ListOperationsRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.kind = "";
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.pageSize = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.pageSize = options.longs === String ? "0" : 0;
                    object.pageToken = "";
                }
                if (message.kind != null && message.hasOwnProperty("kind"))
                    object.kind = message.kind;
                if (message.pageSize != null && message.hasOwnProperty("pageSize"))
                    if (typeof message.pageSize === "number")
                        object.pageSize = options.longs === String ? String(message.pageSize) : message.pageSize;
                    else
                        object.pageSize = options.longs === String ? $util.Long.prototype.toString.call(message.pageSize) : options.longs === Number ? new $util.LongBits(message.pageSize.low >>> 0, message.pageSize.high >>> 0).toNumber(true) : message.pageSize;
                if (message.pageToken != null && message.hasOwnProperty("pageToken"))
                    object.pageToken = message.pageToken;
                return object;
            };

            /**
             * Converts this ListOperationsRequest to JSON.
             * @function toJSON
             * @memberof Ydb.Operations.ListOperationsRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ListOperationsRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ListOperationsRequest;
        })();

        Operations.ListOperationsResponse = (function() {

            /**
             * Properties of a ListOperationsResponse.
             * @memberof Ydb.Operations
             * @interface IListOperationsResponse
             * @property {Ydb.StatusIds.StatusCode|null} [status] ListOperationsResponse status
             * @property {Array.<Ydb.Issue.IIssueMessage>|null} [issues] ListOperationsResponse issues
             * @property {Array.<Ydb.Operations.IOperation>|null} [operations] ListOperationsResponse operations
             * @property {string|null} [nextPageToken] ListOperationsResponse nextPageToken
             */

            /**
             * Constructs a new ListOperationsResponse.
             * @memberof Ydb.Operations
             * @classdesc Represents a ListOperationsResponse.
             * @implements IListOperationsResponse
             * @constructor
             * @param {Ydb.Operations.IListOperationsResponse=} [properties] Properties to set
             */
            function ListOperationsResponse(properties) {
                this.issues = [];
                this.operations = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ListOperationsResponse status.
             * @member {Ydb.StatusIds.StatusCode} status
             * @memberof Ydb.Operations.ListOperationsResponse
             * @instance
             */
            ListOperationsResponse.prototype.status = 0;

            /**
             * ListOperationsResponse issues.
             * @member {Array.<Ydb.Issue.IIssueMessage>} issues
             * @memberof Ydb.Operations.ListOperationsResponse
             * @instance
             */
            ListOperationsResponse.prototype.issues = $util.emptyArray;

            /**
             * ListOperationsResponse operations.
             * @member {Array.<Ydb.Operations.IOperation>} operations
             * @memberof Ydb.Operations.ListOperationsResponse
             * @instance
             */
            ListOperationsResponse.prototype.operations = $util.emptyArray;

            /**
             * ListOperationsResponse nextPageToken.
             * @member {string} nextPageToken
             * @memberof Ydb.Operations.ListOperationsResponse
             * @instance
             */
            ListOperationsResponse.prototype.nextPageToken = "";

            /**
             * Creates a new ListOperationsResponse instance using the specified properties.
             * @function create
             * @memberof Ydb.Operations.ListOperationsResponse
             * @static
             * @param {Ydb.Operations.IListOperationsResponse=} [properties] Properties to set
             * @returns {Ydb.Operations.ListOperationsResponse} ListOperationsResponse instance
             */
            ListOperationsResponse.create = function create(properties) {
                return new ListOperationsResponse(properties);
            };

            /**
             * Encodes the specified ListOperationsResponse message. Does not implicitly {@link Ydb.Operations.ListOperationsResponse.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Operations.ListOperationsResponse
             * @static
             * @param {Ydb.Operations.IListOperationsResponse} message ListOperationsResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ListOperationsResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.status);
                if (message.issues != null && message.issues.length)
                    for (var i = 0; i < message.issues.length; ++i)
                        $root.Ydb.Issue.IssueMessage.encode(message.issues[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.operations != null && message.operations.length)
                    for (var i = 0; i < message.operations.length; ++i)
                        $root.Ydb.Operations.Operation.encode(message.operations[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.nextPageToken != null && Object.hasOwnProperty.call(message, "nextPageToken"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.nextPageToken);
                return writer;
            };

            /**
             * Encodes the specified ListOperationsResponse message, length delimited. Does not implicitly {@link Ydb.Operations.ListOperationsResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Operations.ListOperationsResponse
             * @static
             * @param {Ydb.Operations.IListOperationsResponse} message ListOperationsResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ListOperationsResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ListOperationsResponse message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Operations.ListOperationsResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Operations.ListOperationsResponse} ListOperationsResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ListOperationsResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Operations.ListOperationsResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.status = reader.int32();
                        break;
                    case 2:
                        if (!(message.issues && message.issues.length))
                            message.issues = [];
                        message.issues.push($root.Ydb.Issue.IssueMessage.decode(reader, reader.uint32()));
                        break;
                    case 3:
                        if (!(message.operations && message.operations.length))
                            message.operations = [];
                        message.operations.push($root.Ydb.Operations.Operation.decode(reader, reader.uint32()));
                        break;
                    case 4:
                        message.nextPageToken = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ListOperationsResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Operations.ListOperationsResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Operations.ListOperationsResponse} ListOperationsResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ListOperationsResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ListOperationsResponse message.
             * @function verify
             * @memberof Ydb.Operations.ListOperationsResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ListOperationsResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.status != null && message.hasOwnProperty("status"))
                    switch (message.status) {
                    default:
                        return "status: enum value expected";
                    case 0:
                    case 400000:
                    case 400010:
                    case 400020:
                    case 400030:
                    case 400040:
                    case 400050:
                    case 400060:
                    case 400070:
                    case 400080:
                    case 400090:
                    case 400100:
                    case 400120:
                    case 400130:
                    case 400140:
                    case 400150:
                    case 400160:
                    case 400170:
                    case 400180:
                    case 400190:
                        break;
                    }
                if (message.issues != null && message.hasOwnProperty("issues")) {
                    if (!Array.isArray(message.issues))
                        return "issues: array expected";
                    for (var i = 0; i < message.issues.length; ++i) {
                        var error = $root.Ydb.Issue.IssueMessage.verify(message.issues[i]);
                        if (error)
                            return "issues." + error;
                    }
                }
                if (message.operations != null && message.hasOwnProperty("operations")) {
                    if (!Array.isArray(message.operations))
                        return "operations: array expected";
                    for (var i = 0; i < message.operations.length; ++i) {
                        var error = $root.Ydb.Operations.Operation.verify(message.operations[i]);
                        if (error)
                            return "operations." + error;
                    }
                }
                if (message.nextPageToken != null && message.hasOwnProperty("nextPageToken"))
                    if (!$util.isString(message.nextPageToken))
                        return "nextPageToken: string expected";
                return null;
            };

            /**
             * Creates a ListOperationsResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Operations.ListOperationsResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Operations.ListOperationsResponse} ListOperationsResponse
             */
            ListOperationsResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Operations.ListOperationsResponse)
                    return object;
                var message = new $root.Ydb.Operations.ListOperationsResponse();
                switch (object.status) {
                case "STATUS_CODE_UNSPECIFIED":
                case 0:
                    message.status = 0;
                    break;
                case "SUCCESS":
                case 400000:
                    message.status = 400000;
                    break;
                case "BAD_REQUEST":
                case 400010:
                    message.status = 400010;
                    break;
                case "UNAUTHORIZED":
                case 400020:
                    message.status = 400020;
                    break;
                case "INTERNAL_ERROR":
                case 400030:
                    message.status = 400030;
                    break;
                case "ABORTED":
                case 400040:
                    message.status = 400040;
                    break;
                case "UNAVAILABLE":
                case 400050:
                    message.status = 400050;
                    break;
                case "OVERLOADED":
                case 400060:
                    message.status = 400060;
                    break;
                case "SCHEME_ERROR":
                case 400070:
                    message.status = 400070;
                    break;
                case "GENERIC_ERROR":
                case 400080:
                    message.status = 400080;
                    break;
                case "TIMEOUT":
                case 400090:
                    message.status = 400090;
                    break;
                case "BAD_SESSION":
                case 400100:
                    message.status = 400100;
                    break;
                case "PRECONDITION_FAILED":
                case 400120:
                    message.status = 400120;
                    break;
                case "ALREADY_EXISTS":
                case 400130:
                    message.status = 400130;
                    break;
                case "NOT_FOUND":
                case 400140:
                    message.status = 400140;
                    break;
                case "SESSION_EXPIRED":
                case 400150:
                    message.status = 400150;
                    break;
                case "CANCELLED":
                case 400160:
                    message.status = 400160;
                    break;
                case "UNDETERMINED":
                case 400170:
                    message.status = 400170;
                    break;
                case "UNSUPPORTED":
                case 400180:
                    message.status = 400180;
                    break;
                case "SESSION_BUSY":
                case 400190:
                    message.status = 400190;
                    break;
                }
                if (object.issues) {
                    if (!Array.isArray(object.issues))
                        throw TypeError(".Ydb.Operations.ListOperationsResponse.issues: array expected");
                    message.issues = [];
                    for (var i = 0; i < object.issues.length; ++i) {
                        if (typeof object.issues[i] !== "object")
                            throw TypeError(".Ydb.Operations.ListOperationsResponse.issues: object expected");
                        message.issues[i] = $root.Ydb.Issue.IssueMessage.fromObject(object.issues[i]);
                    }
                }
                if (object.operations) {
                    if (!Array.isArray(object.operations))
                        throw TypeError(".Ydb.Operations.ListOperationsResponse.operations: array expected");
                    message.operations = [];
                    for (var i = 0; i < object.operations.length; ++i) {
                        if (typeof object.operations[i] !== "object")
                            throw TypeError(".Ydb.Operations.ListOperationsResponse.operations: object expected");
                        message.operations[i] = $root.Ydb.Operations.Operation.fromObject(object.operations[i]);
                    }
                }
                if (object.nextPageToken != null)
                    message.nextPageToken = String(object.nextPageToken);
                return message;
            };

            /**
             * Creates a plain object from a ListOperationsResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Operations.ListOperationsResponse
             * @static
             * @param {Ydb.Operations.ListOperationsResponse} message ListOperationsResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ListOperationsResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.issues = [];
                    object.operations = [];
                }
                if (options.defaults) {
                    object.status = options.enums === String ? "STATUS_CODE_UNSPECIFIED" : 0;
                    object.nextPageToken = "";
                }
                if (message.status != null && message.hasOwnProperty("status"))
                    object.status = options.enums === String ? $root.Ydb.StatusIds.StatusCode[message.status] : message.status;
                if (message.issues && message.issues.length) {
                    object.issues = [];
                    for (var j = 0; j < message.issues.length; ++j)
                        object.issues[j] = $root.Ydb.Issue.IssueMessage.toObject(message.issues[j], options);
                }
                if (message.operations && message.operations.length) {
                    object.operations = [];
                    for (var j = 0; j < message.operations.length; ++j)
                        object.operations[j] = $root.Ydb.Operations.Operation.toObject(message.operations[j], options);
                }
                if (message.nextPageToken != null && message.hasOwnProperty("nextPageToken"))
                    object.nextPageToken = message.nextPageToken;
                return object;
            };

            /**
             * Converts this ListOperationsResponse to JSON.
             * @function toJSON
             * @memberof Ydb.Operations.ListOperationsResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ListOperationsResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ListOperationsResponse;
        })();

        Operations.Operation = (function() {

            /**
             * Properties of an Operation.
             * @memberof Ydb.Operations
             * @interface IOperation
             * @property {string|null} [id] Operation id
             * @property {boolean|null} [ready] Operation ready
             * @property {Ydb.StatusIds.StatusCode|null} [status] Operation status
             * @property {Array.<Ydb.Issue.IIssueMessage>|null} [issues] Operation issues
             * @property {google.protobuf.IAny|null} [result] Operation result
             * @property {google.protobuf.IAny|null} [metadata] Operation metadata
             * @property {Ydb.ICostInfo|null} [costInfo] Operation costInfo
             */

            /**
             * Constructs a new Operation.
             * @memberof Ydb.Operations
             * @classdesc Represents an Operation.
             * @implements IOperation
             * @constructor
             * @param {Ydb.Operations.IOperation=} [properties] Properties to set
             */
            function Operation(properties) {
                this.issues = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Operation id.
             * @member {string} id
             * @memberof Ydb.Operations.Operation
             * @instance
             */
            Operation.prototype.id = "";

            /**
             * Operation ready.
             * @member {boolean} ready
             * @memberof Ydb.Operations.Operation
             * @instance
             */
            Operation.prototype.ready = false;

            /**
             * Operation status.
             * @member {Ydb.StatusIds.StatusCode} status
             * @memberof Ydb.Operations.Operation
             * @instance
             */
            Operation.prototype.status = 0;

            /**
             * Operation issues.
             * @member {Array.<Ydb.Issue.IIssueMessage>} issues
             * @memberof Ydb.Operations.Operation
             * @instance
             */
            Operation.prototype.issues = $util.emptyArray;

            /**
             * Operation result.
             * @member {google.protobuf.IAny|null|undefined} result
             * @memberof Ydb.Operations.Operation
             * @instance
             */
            Operation.prototype.result = null;

            /**
             * Operation metadata.
             * @member {google.protobuf.IAny|null|undefined} metadata
             * @memberof Ydb.Operations.Operation
             * @instance
             */
            Operation.prototype.metadata = null;

            /**
             * Operation costInfo.
             * @member {Ydb.ICostInfo|null|undefined} costInfo
             * @memberof Ydb.Operations.Operation
             * @instance
             */
            Operation.prototype.costInfo = null;

            /**
             * Creates a new Operation instance using the specified properties.
             * @function create
             * @memberof Ydb.Operations.Operation
             * @static
             * @param {Ydb.Operations.IOperation=} [properties] Properties to set
             * @returns {Ydb.Operations.Operation} Operation instance
             */
            Operation.create = function create(properties) {
                return new Operation(properties);
            };

            /**
             * Encodes the specified Operation message. Does not implicitly {@link Ydb.Operations.Operation.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Operations.Operation
             * @static
             * @param {Ydb.Operations.IOperation} message Operation message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Operation.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                if (message.ready != null && Object.hasOwnProperty.call(message, "ready"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.ready);
                if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.status);
                if (message.issues != null && message.issues.length)
                    for (var i = 0; i < message.issues.length; ++i)
                        $root.Ydb.Issue.IssueMessage.encode(message.issues[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.result != null && Object.hasOwnProperty.call(message, "result"))
                    $root.google.protobuf.Any.encode(message.result, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.metadata != null && Object.hasOwnProperty.call(message, "metadata"))
                    $root.google.protobuf.Any.encode(message.metadata, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.costInfo != null && Object.hasOwnProperty.call(message, "costInfo"))
                    $root.Ydb.CostInfo.encode(message.costInfo, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Operation message, length delimited. Does not implicitly {@link Ydb.Operations.Operation.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Operations.Operation
             * @static
             * @param {Ydb.Operations.IOperation} message Operation message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Operation.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an Operation message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Operations.Operation
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Operations.Operation} Operation
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Operation.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Operations.Operation();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = reader.string();
                        break;
                    case 2:
                        message.ready = reader.bool();
                        break;
                    case 3:
                        message.status = reader.int32();
                        break;
                    case 4:
                        if (!(message.issues && message.issues.length))
                            message.issues = [];
                        message.issues.push($root.Ydb.Issue.IssueMessage.decode(reader, reader.uint32()));
                        break;
                    case 5:
                        message.result = $root.google.protobuf.Any.decode(reader, reader.uint32());
                        break;
                    case 6:
                        message.metadata = $root.google.protobuf.Any.decode(reader, reader.uint32());
                        break;
                    case 7:
                        message.costInfo = $root.Ydb.CostInfo.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an Operation message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Operations.Operation
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Operations.Operation} Operation
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Operation.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an Operation message.
             * @function verify
             * @memberof Ydb.Operations.Operation
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Operation.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isString(message.id))
                        return "id: string expected";
                if (message.ready != null && message.hasOwnProperty("ready"))
                    if (typeof message.ready !== "boolean")
                        return "ready: boolean expected";
                if (message.status != null && message.hasOwnProperty("status"))
                    switch (message.status) {
                    default:
                        return "status: enum value expected";
                    case 0:
                    case 400000:
                    case 400010:
                    case 400020:
                    case 400030:
                    case 400040:
                    case 400050:
                    case 400060:
                    case 400070:
                    case 400080:
                    case 400090:
                    case 400100:
                    case 400120:
                    case 400130:
                    case 400140:
                    case 400150:
                    case 400160:
                    case 400170:
                    case 400180:
                    case 400190:
                        break;
                    }
                if (message.issues != null && message.hasOwnProperty("issues")) {
                    if (!Array.isArray(message.issues))
                        return "issues: array expected";
                    for (var i = 0; i < message.issues.length; ++i) {
                        var error = $root.Ydb.Issue.IssueMessage.verify(message.issues[i]);
                        if (error)
                            return "issues." + error;
                    }
                }
                if (message.result != null && message.hasOwnProperty("result")) {
                    var error = $root.google.protobuf.Any.verify(message.result);
                    if (error)
                        return "result." + error;
                }
                if (message.metadata != null && message.hasOwnProperty("metadata")) {
                    var error = $root.google.protobuf.Any.verify(message.metadata);
                    if (error)
                        return "metadata." + error;
                }
                if (message.costInfo != null && message.hasOwnProperty("costInfo")) {
                    var error = $root.Ydb.CostInfo.verify(message.costInfo);
                    if (error)
                        return "costInfo." + error;
                }
                return null;
            };

            /**
             * Creates an Operation message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Operations.Operation
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Operations.Operation} Operation
             */
            Operation.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Operations.Operation)
                    return object;
                var message = new $root.Ydb.Operations.Operation();
                if (object.id != null)
                    message.id = String(object.id);
                if (object.ready != null)
                    message.ready = Boolean(object.ready);
                switch (object.status) {
                case "STATUS_CODE_UNSPECIFIED":
                case 0:
                    message.status = 0;
                    break;
                case "SUCCESS":
                case 400000:
                    message.status = 400000;
                    break;
                case "BAD_REQUEST":
                case 400010:
                    message.status = 400010;
                    break;
                case "UNAUTHORIZED":
                case 400020:
                    message.status = 400020;
                    break;
                case "INTERNAL_ERROR":
                case 400030:
                    message.status = 400030;
                    break;
                case "ABORTED":
                case 400040:
                    message.status = 400040;
                    break;
                case "UNAVAILABLE":
                case 400050:
                    message.status = 400050;
                    break;
                case "OVERLOADED":
                case 400060:
                    message.status = 400060;
                    break;
                case "SCHEME_ERROR":
                case 400070:
                    message.status = 400070;
                    break;
                case "GENERIC_ERROR":
                case 400080:
                    message.status = 400080;
                    break;
                case "TIMEOUT":
                case 400090:
                    message.status = 400090;
                    break;
                case "BAD_SESSION":
                case 400100:
                    message.status = 400100;
                    break;
                case "PRECONDITION_FAILED":
                case 400120:
                    message.status = 400120;
                    break;
                case "ALREADY_EXISTS":
                case 400130:
                    message.status = 400130;
                    break;
                case "NOT_FOUND":
                case 400140:
                    message.status = 400140;
                    break;
                case "SESSION_EXPIRED":
                case 400150:
                    message.status = 400150;
                    break;
                case "CANCELLED":
                case 400160:
                    message.status = 400160;
                    break;
                case "UNDETERMINED":
                case 400170:
                    message.status = 400170;
                    break;
                case "UNSUPPORTED":
                case 400180:
                    message.status = 400180;
                    break;
                case "SESSION_BUSY":
                case 400190:
                    message.status = 400190;
                    break;
                }
                if (object.issues) {
                    if (!Array.isArray(object.issues))
                        throw TypeError(".Ydb.Operations.Operation.issues: array expected");
                    message.issues = [];
                    for (var i = 0; i < object.issues.length; ++i) {
                        if (typeof object.issues[i] !== "object")
                            throw TypeError(".Ydb.Operations.Operation.issues: object expected");
                        message.issues[i] = $root.Ydb.Issue.IssueMessage.fromObject(object.issues[i]);
                    }
                }
                if (object.result != null) {
                    if (typeof object.result !== "object")
                        throw TypeError(".Ydb.Operations.Operation.result: object expected");
                    message.result = $root.google.protobuf.Any.fromObject(object.result);
                }
                if (object.metadata != null) {
                    if (typeof object.metadata !== "object")
                        throw TypeError(".Ydb.Operations.Operation.metadata: object expected");
                    message.metadata = $root.google.protobuf.Any.fromObject(object.metadata);
                }
                if (object.costInfo != null) {
                    if (typeof object.costInfo !== "object")
                        throw TypeError(".Ydb.Operations.Operation.costInfo: object expected");
                    message.costInfo = $root.Ydb.CostInfo.fromObject(object.costInfo);
                }
                return message;
            };

            /**
             * Creates a plain object from an Operation message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Operations.Operation
             * @static
             * @param {Ydb.Operations.Operation} message Operation
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Operation.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.issues = [];
                if (options.defaults) {
                    object.id = "";
                    object.ready = false;
                    object.status = options.enums === String ? "STATUS_CODE_UNSPECIFIED" : 0;
                    object.result = null;
                    object.metadata = null;
                    object.costInfo = null;
                }
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                if (message.ready != null && message.hasOwnProperty("ready"))
                    object.ready = message.ready;
                if (message.status != null && message.hasOwnProperty("status"))
                    object.status = options.enums === String ? $root.Ydb.StatusIds.StatusCode[message.status] : message.status;
                if (message.issues && message.issues.length) {
                    object.issues = [];
                    for (var j = 0; j < message.issues.length; ++j)
                        object.issues[j] = $root.Ydb.Issue.IssueMessage.toObject(message.issues[j], options);
                }
                if (message.result != null && message.hasOwnProperty("result"))
                    object.result = $root.google.protobuf.Any.toObject(message.result, options);
                if (message.metadata != null && message.hasOwnProperty("metadata"))
                    object.metadata = $root.google.protobuf.Any.toObject(message.metadata, options);
                if (message.costInfo != null && message.hasOwnProperty("costInfo"))
                    object.costInfo = $root.Ydb.CostInfo.toObject(message.costInfo, options);
                return object;
            };

            /**
             * Converts this Operation to JSON.
             * @function toJSON
             * @memberof Ydb.Operations.Operation
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Operation.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Operation;
        })();

        return Operations;
    })();

    Ydb.StatusIds = (function() {

        /**
         * Properties of a StatusIds.
         * @memberof Ydb
         * @interface IStatusIds
         */

        /**
         * Constructs a new StatusIds.
         * @memberof Ydb
         * @classdesc Represents a StatusIds.
         * @implements IStatusIds
         * @constructor
         * @param {Ydb.IStatusIds=} [properties] Properties to set
         */
        function StatusIds(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new StatusIds instance using the specified properties.
         * @function create
         * @memberof Ydb.StatusIds
         * @static
         * @param {Ydb.IStatusIds=} [properties] Properties to set
         * @returns {Ydb.StatusIds} StatusIds instance
         */
        StatusIds.create = function create(properties) {
            return new StatusIds(properties);
        };

        /**
         * Encodes the specified StatusIds message. Does not implicitly {@link Ydb.StatusIds.verify|verify} messages.
         * @function encode
         * @memberof Ydb.StatusIds
         * @static
         * @param {Ydb.IStatusIds} message StatusIds message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StatusIds.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified StatusIds message, length delimited. Does not implicitly {@link Ydb.StatusIds.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Ydb.StatusIds
         * @static
         * @param {Ydb.IStatusIds} message StatusIds message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StatusIds.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a StatusIds message from the specified reader or buffer.
         * @function decode
         * @memberof Ydb.StatusIds
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Ydb.StatusIds} StatusIds
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StatusIds.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.StatusIds();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a StatusIds message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Ydb.StatusIds
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Ydb.StatusIds} StatusIds
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StatusIds.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a StatusIds message.
         * @function verify
         * @memberof Ydb.StatusIds
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        StatusIds.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a StatusIds message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Ydb.StatusIds
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Ydb.StatusIds} StatusIds
         */
        StatusIds.fromObject = function fromObject(object) {
            if (object instanceof $root.Ydb.StatusIds)
                return object;
            return new $root.Ydb.StatusIds();
        };

        /**
         * Creates a plain object from a StatusIds message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Ydb.StatusIds
         * @static
         * @param {Ydb.StatusIds} message StatusIds
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        StatusIds.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this StatusIds to JSON.
         * @function toJSON
         * @memberof Ydb.StatusIds
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        StatusIds.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * StatusCode enum.
         * @name Ydb.StatusIds.StatusCode
         * @enum {number}
         * @property {number} STATUS_CODE_UNSPECIFIED=0 STATUS_CODE_UNSPECIFIED value
         * @property {number} SUCCESS=400000 SUCCESS value
         * @property {number} BAD_REQUEST=400010 BAD_REQUEST value
         * @property {number} UNAUTHORIZED=400020 UNAUTHORIZED value
         * @property {number} INTERNAL_ERROR=400030 INTERNAL_ERROR value
         * @property {number} ABORTED=400040 ABORTED value
         * @property {number} UNAVAILABLE=400050 UNAVAILABLE value
         * @property {number} OVERLOADED=400060 OVERLOADED value
         * @property {number} SCHEME_ERROR=400070 SCHEME_ERROR value
         * @property {number} GENERIC_ERROR=400080 GENERIC_ERROR value
         * @property {number} TIMEOUT=400090 TIMEOUT value
         * @property {number} BAD_SESSION=400100 BAD_SESSION value
         * @property {number} PRECONDITION_FAILED=400120 PRECONDITION_FAILED value
         * @property {number} ALREADY_EXISTS=400130 ALREADY_EXISTS value
         * @property {number} NOT_FOUND=400140 NOT_FOUND value
         * @property {number} SESSION_EXPIRED=400150 SESSION_EXPIRED value
         * @property {number} CANCELLED=400160 CANCELLED value
         * @property {number} UNDETERMINED=400170 UNDETERMINED value
         * @property {number} UNSUPPORTED=400180 UNSUPPORTED value
         * @property {number} SESSION_BUSY=400190 SESSION_BUSY value
         */
        StatusIds.StatusCode = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "STATUS_CODE_UNSPECIFIED"] = 0;
            values[valuesById[400000] = "SUCCESS"] = 400000;
            values[valuesById[400010] = "BAD_REQUEST"] = 400010;
            values[valuesById[400020] = "UNAUTHORIZED"] = 400020;
            values[valuesById[400030] = "INTERNAL_ERROR"] = 400030;
            values[valuesById[400040] = "ABORTED"] = 400040;
            values[valuesById[400050] = "UNAVAILABLE"] = 400050;
            values[valuesById[400060] = "OVERLOADED"] = 400060;
            values[valuesById[400070] = "SCHEME_ERROR"] = 400070;
            values[valuesById[400080] = "GENERIC_ERROR"] = 400080;
            values[valuesById[400090] = "TIMEOUT"] = 400090;
            values[valuesById[400100] = "BAD_SESSION"] = 400100;
            values[valuesById[400120] = "PRECONDITION_FAILED"] = 400120;
            values[valuesById[400130] = "ALREADY_EXISTS"] = 400130;
            values[valuesById[400140] = "NOT_FOUND"] = 400140;
            values[valuesById[400150] = "SESSION_EXPIRED"] = 400150;
            values[valuesById[400160] = "CANCELLED"] = 400160;
            values[valuesById[400170] = "UNDETERMINED"] = 400170;
            values[valuesById[400180] = "UNSUPPORTED"] = 400180;
            values[valuesById[400190] = "SESSION_BUSY"] = 400190;
            return values;
        })();

        return StatusIds;
    })();

    Ydb.TableStats = (function() {

        /**
         * Namespace TableStats.
         * @memberof Ydb
         * @namespace
         */
        var TableStats = {};

        TableStats.OperationStats = (function() {

            /**
             * Properties of an OperationStats.
             * @memberof Ydb.TableStats
             * @interface IOperationStats
             * @property {number|Long|null} [rows] OperationStats rows
             * @property {number|Long|null} [bytes] OperationStats bytes
             */

            /**
             * Constructs a new OperationStats.
             * @memberof Ydb.TableStats
             * @classdesc Represents an OperationStats.
             * @implements IOperationStats
             * @constructor
             * @param {Ydb.TableStats.IOperationStats=} [properties] Properties to set
             */
            function OperationStats(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * OperationStats rows.
             * @member {number|Long} rows
             * @memberof Ydb.TableStats.OperationStats
             * @instance
             */
            OperationStats.prototype.rows = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * OperationStats bytes.
             * @member {number|Long} bytes
             * @memberof Ydb.TableStats.OperationStats
             * @instance
             */
            OperationStats.prototype.bytes = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Creates a new OperationStats instance using the specified properties.
             * @function create
             * @memberof Ydb.TableStats.OperationStats
             * @static
             * @param {Ydb.TableStats.IOperationStats=} [properties] Properties to set
             * @returns {Ydb.TableStats.OperationStats} OperationStats instance
             */
            OperationStats.create = function create(properties) {
                return new OperationStats(properties);
            };

            /**
             * Encodes the specified OperationStats message. Does not implicitly {@link Ydb.TableStats.OperationStats.verify|verify} messages.
             * @function encode
             * @memberof Ydb.TableStats.OperationStats
             * @static
             * @param {Ydb.TableStats.IOperationStats} message OperationStats message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OperationStats.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.rows != null && Object.hasOwnProperty.call(message, "rows"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.rows);
                if (message.bytes != null && Object.hasOwnProperty.call(message, "bytes"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.bytes);
                return writer;
            };

            /**
             * Encodes the specified OperationStats message, length delimited. Does not implicitly {@link Ydb.TableStats.OperationStats.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.TableStats.OperationStats
             * @static
             * @param {Ydb.TableStats.IOperationStats} message OperationStats message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OperationStats.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an OperationStats message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.TableStats.OperationStats
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.TableStats.OperationStats} OperationStats
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OperationStats.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.TableStats.OperationStats();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.rows = reader.uint64();
                        break;
                    case 2:
                        message.bytes = reader.uint64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an OperationStats message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.TableStats.OperationStats
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.TableStats.OperationStats} OperationStats
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OperationStats.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an OperationStats message.
             * @function verify
             * @memberof Ydb.TableStats.OperationStats
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            OperationStats.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.rows != null && message.hasOwnProperty("rows"))
                    if (!$util.isInteger(message.rows) && !(message.rows && $util.isInteger(message.rows.low) && $util.isInteger(message.rows.high)))
                        return "rows: integer|Long expected";
                if (message.bytes != null && message.hasOwnProperty("bytes"))
                    if (!$util.isInteger(message.bytes) && !(message.bytes && $util.isInteger(message.bytes.low) && $util.isInteger(message.bytes.high)))
                        return "bytes: integer|Long expected";
                return null;
            };

            /**
             * Creates an OperationStats message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.TableStats.OperationStats
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.TableStats.OperationStats} OperationStats
             */
            OperationStats.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.TableStats.OperationStats)
                    return object;
                var message = new $root.Ydb.TableStats.OperationStats();
                if (object.rows != null)
                    if ($util.Long)
                        (message.rows = $util.Long.fromValue(object.rows)).unsigned = true;
                    else if (typeof object.rows === "string")
                        message.rows = parseInt(object.rows, 10);
                    else if (typeof object.rows === "number")
                        message.rows = object.rows;
                    else if (typeof object.rows === "object")
                        message.rows = new $util.LongBits(object.rows.low >>> 0, object.rows.high >>> 0).toNumber(true);
                if (object.bytes != null)
                    if ($util.Long)
                        (message.bytes = $util.Long.fromValue(object.bytes)).unsigned = true;
                    else if (typeof object.bytes === "string")
                        message.bytes = parseInt(object.bytes, 10);
                    else if (typeof object.bytes === "number")
                        message.bytes = object.bytes;
                    else if (typeof object.bytes === "object")
                        message.bytes = new $util.LongBits(object.bytes.low >>> 0, object.bytes.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from an OperationStats message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.TableStats.OperationStats
             * @static
             * @param {Ydb.TableStats.OperationStats} message OperationStats
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            OperationStats.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.rows = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.rows = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.bytes = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.bytes = options.longs === String ? "0" : 0;
                }
                if (message.rows != null && message.hasOwnProperty("rows"))
                    if (typeof message.rows === "number")
                        object.rows = options.longs === String ? String(message.rows) : message.rows;
                    else
                        object.rows = options.longs === String ? $util.Long.prototype.toString.call(message.rows) : options.longs === Number ? new $util.LongBits(message.rows.low >>> 0, message.rows.high >>> 0).toNumber(true) : message.rows;
                if (message.bytes != null && message.hasOwnProperty("bytes"))
                    if (typeof message.bytes === "number")
                        object.bytes = options.longs === String ? String(message.bytes) : message.bytes;
                    else
                        object.bytes = options.longs === String ? $util.Long.prototype.toString.call(message.bytes) : options.longs === Number ? new $util.LongBits(message.bytes.low >>> 0, message.bytes.high >>> 0).toNumber(true) : message.bytes;
                return object;
            };

            /**
             * Converts this OperationStats to JSON.
             * @function toJSON
             * @memberof Ydb.TableStats.OperationStats
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            OperationStats.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return OperationStats;
        })();

        TableStats.TableAccessStats = (function() {

            /**
             * Properties of a TableAccessStats.
             * @memberof Ydb.TableStats
             * @interface ITableAccessStats
             * @property {string|null} [name] TableAccessStats name
             * @property {Ydb.TableStats.IOperationStats|null} [reads] TableAccessStats reads
             * @property {Ydb.TableStats.IOperationStats|null} [updates] TableAccessStats updates
             * @property {Ydb.TableStats.IOperationStats|null} [deletes] TableAccessStats deletes
             * @property {number|Long|null} [partitionsCount] TableAccessStats partitionsCount
             */

            /**
             * Constructs a new TableAccessStats.
             * @memberof Ydb.TableStats
             * @classdesc Represents a TableAccessStats.
             * @implements ITableAccessStats
             * @constructor
             * @param {Ydb.TableStats.ITableAccessStats=} [properties] Properties to set
             */
            function TableAccessStats(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * TableAccessStats name.
             * @member {string} name
             * @memberof Ydb.TableStats.TableAccessStats
             * @instance
             */
            TableAccessStats.prototype.name = "";

            /**
             * TableAccessStats reads.
             * @member {Ydb.TableStats.IOperationStats|null|undefined} reads
             * @memberof Ydb.TableStats.TableAccessStats
             * @instance
             */
            TableAccessStats.prototype.reads = null;

            /**
             * TableAccessStats updates.
             * @member {Ydb.TableStats.IOperationStats|null|undefined} updates
             * @memberof Ydb.TableStats.TableAccessStats
             * @instance
             */
            TableAccessStats.prototype.updates = null;

            /**
             * TableAccessStats deletes.
             * @member {Ydb.TableStats.IOperationStats|null|undefined} deletes
             * @memberof Ydb.TableStats.TableAccessStats
             * @instance
             */
            TableAccessStats.prototype.deletes = null;

            /**
             * TableAccessStats partitionsCount.
             * @member {number|Long} partitionsCount
             * @memberof Ydb.TableStats.TableAccessStats
             * @instance
             */
            TableAccessStats.prototype.partitionsCount = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Creates a new TableAccessStats instance using the specified properties.
             * @function create
             * @memberof Ydb.TableStats.TableAccessStats
             * @static
             * @param {Ydb.TableStats.ITableAccessStats=} [properties] Properties to set
             * @returns {Ydb.TableStats.TableAccessStats} TableAccessStats instance
             */
            TableAccessStats.create = function create(properties) {
                return new TableAccessStats(properties);
            };

            /**
             * Encodes the specified TableAccessStats message. Does not implicitly {@link Ydb.TableStats.TableAccessStats.verify|verify} messages.
             * @function encode
             * @memberof Ydb.TableStats.TableAccessStats
             * @static
             * @param {Ydb.TableStats.ITableAccessStats} message TableAccessStats message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TableAccessStats.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.reads != null && Object.hasOwnProperty.call(message, "reads"))
                    $root.Ydb.TableStats.OperationStats.encode(message.reads, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.updates != null && Object.hasOwnProperty.call(message, "updates"))
                    $root.Ydb.TableStats.OperationStats.encode(message.updates, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.deletes != null && Object.hasOwnProperty.call(message, "deletes"))
                    $root.Ydb.TableStats.OperationStats.encode(message.deletes, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.partitionsCount != null && Object.hasOwnProperty.call(message, "partitionsCount"))
                    writer.uint32(/* id 6, wireType 0 =*/48).uint64(message.partitionsCount);
                return writer;
            };

            /**
             * Encodes the specified TableAccessStats message, length delimited. Does not implicitly {@link Ydb.TableStats.TableAccessStats.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.TableStats.TableAccessStats
             * @static
             * @param {Ydb.TableStats.ITableAccessStats} message TableAccessStats message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TableAccessStats.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a TableAccessStats message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.TableStats.TableAccessStats
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.TableStats.TableAccessStats} TableAccessStats
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TableAccessStats.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.TableStats.TableAccessStats();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 3:
                        message.reads = $root.Ydb.TableStats.OperationStats.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.updates = $root.Ydb.TableStats.OperationStats.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.deletes = $root.Ydb.TableStats.OperationStats.decode(reader, reader.uint32());
                        break;
                    case 6:
                        message.partitionsCount = reader.uint64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a TableAccessStats message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.TableStats.TableAccessStats
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.TableStats.TableAccessStats} TableAccessStats
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TableAccessStats.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a TableAccessStats message.
             * @function verify
             * @memberof Ydb.TableStats.TableAccessStats
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TableAccessStats.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.reads != null && message.hasOwnProperty("reads")) {
                    var error = $root.Ydb.TableStats.OperationStats.verify(message.reads);
                    if (error)
                        return "reads." + error;
                }
                if (message.updates != null && message.hasOwnProperty("updates")) {
                    var error = $root.Ydb.TableStats.OperationStats.verify(message.updates);
                    if (error)
                        return "updates." + error;
                }
                if (message.deletes != null && message.hasOwnProperty("deletes")) {
                    var error = $root.Ydb.TableStats.OperationStats.verify(message.deletes);
                    if (error)
                        return "deletes." + error;
                }
                if (message.partitionsCount != null && message.hasOwnProperty("partitionsCount"))
                    if (!$util.isInteger(message.partitionsCount) && !(message.partitionsCount && $util.isInteger(message.partitionsCount.low) && $util.isInteger(message.partitionsCount.high)))
                        return "partitionsCount: integer|Long expected";
                return null;
            };

            /**
             * Creates a TableAccessStats message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.TableStats.TableAccessStats
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.TableStats.TableAccessStats} TableAccessStats
             */
            TableAccessStats.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.TableStats.TableAccessStats)
                    return object;
                var message = new $root.Ydb.TableStats.TableAccessStats();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.reads != null) {
                    if (typeof object.reads !== "object")
                        throw TypeError(".Ydb.TableStats.TableAccessStats.reads: object expected");
                    message.reads = $root.Ydb.TableStats.OperationStats.fromObject(object.reads);
                }
                if (object.updates != null) {
                    if (typeof object.updates !== "object")
                        throw TypeError(".Ydb.TableStats.TableAccessStats.updates: object expected");
                    message.updates = $root.Ydb.TableStats.OperationStats.fromObject(object.updates);
                }
                if (object.deletes != null) {
                    if (typeof object.deletes !== "object")
                        throw TypeError(".Ydb.TableStats.TableAccessStats.deletes: object expected");
                    message.deletes = $root.Ydb.TableStats.OperationStats.fromObject(object.deletes);
                }
                if (object.partitionsCount != null)
                    if ($util.Long)
                        (message.partitionsCount = $util.Long.fromValue(object.partitionsCount)).unsigned = true;
                    else if (typeof object.partitionsCount === "string")
                        message.partitionsCount = parseInt(object.partitionsCount, 10);
                    else if (typeof object.partitionsCount === "number")
                        message.partitionsCount = object.partitionsCount;
                    else if (typeof object.partitionsCount === "object")
                        message.partitionsCount = new $util.LongBits(object.partitionsCount.low >>> 0, object.partitionsCount.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a TableAccessStats message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.TableStats.TableAccessStats
             * @static
             * @param {Ydb.TableStats.TableAccessStats} message TableAccessStats
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            TableAccessStats.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.name = "";
                    object.reads = null;
                    object.updates = null;
                    object.deletes = null;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.partitionsCount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.partitionsCount = options.longs === String ? "0" : 0;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.reads != null && message.hasOwnProperty("reads"))
                    object.reads = $root.Ydb.TableStats.OperationStats.toObject(message.reads, options);
                if (message.updates != null && message.hasOwnProperty("updates"))
                    object.updates = $root.Ydb.TableStats.OperationStats.toObject(message.updates, options);
                if (message.deletes != null && message.hasOwnProperty("deletes"))
                    object.deletes = $root.Ydb.TableStats.OperationStats.toObject(message.deletes, options);
                if (message.partitionsCount != null && message.hasOwnProperty("partitionsCount"))
                    if (typeof message.partitionsCount === "number")
                        object.partitionsCount = options.longs === String ? String(message.partitionsCount) : message.partitionsCount;
                    else
                        object.partitionsCount = options.longs === String ? $util.Long.prototype.toString.call(message.partitionsCount) : options.longs === Number ? new $util.LongBits(message.partitionsCount.low >>> 0, message.partitionsCount.high >>> 0).toNumber(true) : message.partitionsCount;
                return object;
            };

            /**
             * Converts this TableAccessStats to JSON.
             * @function toJSON
             * @memberof Ydb.TableStats.TableAccessStats
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            TableAccessStats.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return TableAccessStats;
        })();

        TableStats.QueryPhaseStats = (function() {

            /**
             * Properties of a QueryPhaseStats.
             * @memberof Ydb.TableStats
             * @interface IQueryPhaseStats
             * @property {number|Long|null} [durationUs] QueryPhaseStats durationUs
             * @property {Array.<Ydb.TableStats.ITableAccessStats>|null} [tableAccess] QueryPhaseStats tableAccess
             * @property {number|Long|null} [cpuTimeUs] QueryPhaseStats cpuTimeUs
             * @property {number|Long|null} [affectedShards] QueryPhaseStats affectedShards
             * @property {boolean|null} [literalPhase] QueryPhaseStats literalPhase
             */

            /**
             * Constructs a new QueryPhaseStats.
             * @memberof Ydb.TableStats
             * @classdesc Represents a QueryPhaseStats.
             * @implements IQueryPhaseStats
             * @constructor
             * @param {Ydb.TableStats.IQueryPhaseStats=} [properties] Properties to set
             */
            function QueryPhaseStats(properties) {
                this.tableAccess = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * QueryPhaseStats durationUs.
             * @member {number|Long} durationUs
             * @memberof Ydb.TableStats.QueryPhaseStats
             * @instance
             */
            QueryPhaseStats.prototype.durationUs = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * QueryPhaseStats tableAccess.
             * @member {Array.<Ydb.TableStats.ITableAccessStats>} tableAccess
             * @memberof Ydb.TableStats.QueryPhaseStats
             * @instance
             */
            QueryPhaseStats.prototype.tableAccess = $util.emptyArray;

            /**
             * QueryPhaseStats cpuTimeUs.
             * @member {number|Long} cpuTimeUs
             * @memberof Ydb.TableStats.QueryPhaseStats
             * @instance
             */
            QueryPhaseStats.prototype.cpuTimeUs = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * QueryPhaseStats affectedShards.
             * @member {number|Long} affectedShards
             * @memberof Ydb.TableStats.QueryPhaseStats
             * @instance
             */
            QueryPhaseStats.prototype.affectedShards = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * QueryPhaseStats literalPhase.
             * @member {boolean} literalPhase
             * @memberof Ydb.TableStats.QueryPhaseStats
             * @instance
             */
            QueryPhaseStats.prototype.literalPhase = false;

            /**
             * Creates a new QueryPhaseStats instance using the specified properties.
             * @function create
             * @memberof Ydb.TableStats.QueryPhaseStats
             * @static
             * @param {Ydb.TableStats.IQueryPhaseStats=} [properties] Properties to set
             * @returns {Ydb.TableStats.QueryPhaseStats} QueryPhaseStats instance
             */
            QueryPhaseStats.create = function create(properties) {
                return new QueryPhaseStats(properties);
            };

            /**
             * Encodes the specified QueryPhaseStats message. Does not implicitly {@link Ydb.TableStats.QueryPhaseStats.verify|verify} messages.
             * @function encode
             * @memberof Ydb.TableStats.QueryPhaseStats
             * @static
             * @param {Ydb.TableStats.IQueryPhaseStats} message QueryPhaseStats message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryPhaseStats.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.durationUs != null && Object.hasOwnProperty.call(message, "durationUs"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.durationUs);
                if (message.tableAccess != null && message.tableAccess.length)
                    for (var i = 0; i < message.tableAccess.length; ++i)
                        $root.Ydb.TableStats.TableAccessStats.encode(message.tableAccess[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.cpuTimeUs != null && Object.hasOwnProperty.call(message, "cpuTimeUs"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.cpuTimeUs);
                if (message.affectedShards != null && Object.hasOwnProperty.call(message, "affectedShards"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.affectedShards);
                if (message.literalPhase != null && Object.hasOwnProperty.call(message, "literalPhase"))
                    writer.uint32(/* id 5, wireType 0 =*/40).bool(message.literalPhase);
                return writer;
            };

            /**
             * Encodes the specified QueryPhaseStats message, length delimited. Does not implicitly {@link Ydb.TableStats.QueryPhaseStats.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.TableStats.QueryPhaseStats
             * @static
             * @param {Ydb.TableStats.IQueryPhaseStats} message QueryPhaseStats message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryPhaseStats.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a QueryPhaseStats message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.TableStats.QueryPhaseStats
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.TableStats.QueryPhaseStats} QueryPhaseStats
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryPhaseStats.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.TableStats.QueryPhaseStats();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.durationUs = reader.uint64();
                        break;
                    case 2:
                        if (!(message.tableAccess && message.tableAccess.length))
                            message.tableAccess = [];
                        message.tableAccess.push($root.Ydb.TableStats.TableAccessStats.decode(reader, reader.uint32()));
                        break;
                    case 3:
                        message.cpuTimeUs = reader.uint64();
                        break;
                    case 4:
                        message.affectedShards = reader.uint64();
                        break;
                    case 5:
                        message.literalPhase = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a QueryPhaseStats message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.TableStats.QueryPhaseStats
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.TableStats.QueryPhaseStats} QueryPhaseStats
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryPhaseStats.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a QueryPhaseStats message.
             * @function verify
             * @memberof Ydb.TableStats.QueryPhaseStats
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            QueryPhaseStats.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.durationUs != null && message.hasOwnProperty("durationUs"))
                    if (!$util.isInteger(message.durationUs) && !(message.durationUs && $util.isInteger(message.durationUs.low) && $util.isInteger(message.durationUs.high)))
                        return "durationUs: integer|Long expected";
                if (message.tableAccess != null && message.hasOwnProperty("tableAccess")) {
                    if (!Array.isArray(message.tableAccess))
                        return "tableAccess: array expected";
                    for (var i = 0; i < message.tableAccess.length; ++i) {
                        var error = $root.Ydb.TableStats.TableAccessStats.verify(message.tableAccess[i]);
                        if (error)
                            return "tableAccess." + error;
                    }
                }
                if (message.cpuTimeUs != null && message.hasOwnProperty("cpuTimeUs"))
                    if (!$util.isInteger(message.cpuTimeUs) && !(message.cpuTimeUs && $util.isInteger(message.cpuTimeUs.low) && $util.isInteger(message.cpuTimeUs.high)))
                        return "cpuTimeUs: integer|Long expected";
                if (message.affectedShards != null && message.hasOwnProperty("affectedShards"))
                    if (!$util.isInteger(message.affectedShards) && !(message.affectedShards && $util.isInteger(message.affectedShards.low) && $util.isInteger(message.affectedShards.high)))
                        return "affectedShards: integer|Long expected";
                if (message.literalPhase != null && message.hasOwnProperty("literalPhase"))
                    if (typeof message.literalPhase !== "boolean")
                        return "literalPhase: boolean expected";
                return null;
            };

            /**
             * Creates a QueryPhaseStats message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.TableStats.QueryPhaseStats
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.TableStats.QueryPhaseStats} QueryPhaseStats
             */
            QueryPhaseStats.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.TableStats.QueryPhaseStats)
                    return object;
                var message = new $root.Ydb.TableStats.QueryPhaseStats();
                if (object.durationUs != null)
                    if ($util.Long)
                        (message.durationUs = $util.Long.fromValue(object.durationUs)).unsigned = true;
                    else if (typeof object.durationUs === "string")
                        message.durationUs = parseInt(object.durationUs, 10);
                    else if (typeof object.durationUs === "number")
                        message.durationUs = object.durationUs;
                    else if (typeof object.durationUs === "object")
                        message.durationUs = new $util.LongBits(object.durationUs.low >>> 0, object.durationUs.high >>> 0).toNumber(true);
                if (object.tableAccess) {
                    if (!Array.isArray(object.tableAccess))
                        throw TypeError(".Ydb.TableStats.QueryPhaseStats.tableAccess: array expected");
                    message.tableAccess = [];
                    for (var i = 0; i < object.tableAccess.length; ++i) {
                        if (typeof object.tableAccess[i] !== "object")
                            throw TypeError(".Ydb.TableStats.QueryPhaseStats.tableAccess: object expected");
                        message.tableAccess[i] = $root.Ydb.TableStats.TableAccessStats.fromObject(object.tableAccess[i]);
                    }
                }
                if (object.cpuTimeUs != null)
                    if ($util.Long)
                        (message.cpuTimeUs = $util.Long.fromValue(object.cpuTimeUs)).unsigned = true;
                    else if (typeof object.cpuTimeUs === "string")
                        message.cpuTimeUs = parseInt(object.cpuTimeUs, 10);
                    else if (typeof object.cpuTimeUs === "number")
                        message.cpuTimeUs = object.cpuTimeUs;
                    else if (typeof object.cpuTimeUs === "object")
                        message.cpuTimeUs = new $util.LongBits(object.cpuTimeUs.low >>> 0, object.cpuTimeUs.high >>> 0).toNumber(true);
                if (object.affectedShards != null)
                    if ($util.Long)
                        (message.affectedShards = $util.Long.fromValue(object.affectedShards)).unsigned = true;
                    else if (typeof object.affectedShards === "string")
                        message.affectedShards = parseInt(object.affectedShards, 10);
                    else if (typeof object.affectedShards === "number")
                        message.affectedShards = object.affectedShards;
                    else if (typeof object.affectedShards === "object")
                        message.affectedShards = new $util.LongBits(object.affectedShards.low >>> 0, object.affectedShards.high >>> 0).toNumber(true);
                if (object.literalPhase != null)
                    message.literalPhase = Boolean(object.literalPhase);
                return message;
            };

            /**
             * Creates a plain object from a QueryPhaseStats message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.TableStats.QueryPhaseStats
             * @static
             * @param {Ydb.TableStats.QueryPhaseStats} message QueryPhaseStats
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            QueryPhaseStats.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.tableAccess = [];
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.durationUs = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.durationUs = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.cpuTimeUs = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.cpuTimeUs = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.affectedShards = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.affectedShards = options.longs === String ? "0" : 0;
                    object.literalPhase = false;
                }
                if (message.durationUs != null && message.hasOwnProperty("durationUs"))
                    if (typeof message.durationUs === "number")
                        object.durationUs = options.longs === String ? String(message.durationUs) : message.durationUs;
                    else
                        object.durationUs = options.longs === String ? $util.Long.prototype.toString.call(message.durationUs) : options.longs === Number ? new $util.LongBits(message.durationUs.low >>> 0, message.durationUs.high >>> 0).toNumber(true) : message.durationUs;
                if (message.tableAccess && message.tableAccess.length) {
                    object.tableAccess = [];
                    for (var j = 0; j < message.tableAccess.length; ++j)
                        object.tableAccess[j] = $root.Ydb.TableStats.TableAccessStats.toObject(message.tableAccess[j], options);
                }
                if (message.cpuTimeUs != null && message.hasOwnProperty("cpuTimeUs"))
                    if (typeof message.cpuTimeUs === "number")
                        object.cpuTimeUs = options.longs === String ? String(message.cpuTimeUs) : message.cpuTimeUs;
                    else
                        object.cpuTimeUs = options.longs === String ? $util.Long.prototype.toString.call(message.cpuTimeUs) : options.longs === Number ? new $util.LongBits(message.cpuTimeUs.low >>> 0, message.cpuTimeUs.high >>> 0).toNumber(true) : message.cpuTimeUs;
                if (message.affectedShards != null && message.hasOwnProperty("affectedShards"))
                    if (typeof message.affectedShards === "number")
                        object.affectedShards = options.longs === String ? String(message.affectedShards) : message.affectedShards;
                    else
                        object.affectedShards = options.longs === String ? $util.Long.prototype.toString.call(message.affectedShards) : options.longs === Number ? new $util.LongBits(message.affectedShards.low >>> 0, message.affectedShards.high >>> 0).toNumber(true) : message.affectedShards;
                if (message.literalPhase != null && message.hasOwnProperty("literalPhase"))
                    object.literalPhase = message.literalPhase;
                return object;
            };

            /**
             * Converts this QueryPhaseStats to JSON.
             * @function toJSON
             * @memberof Ydb.TableStats.QueryPhaseStats
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            QueryPhaseStats.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return QueryPhaseStats;
        })();

        TableStats.CompilationStats = (function() {

            /**
             * Properties of a CompilationStats.
             * @memberof Ydb.TableStats
             * @interface ICompilationStats
             * @property {boolean|null} [fromCache] CompilationStats fromCache
             * @property {number|Long|null} [durationUs] CompilationStats durationUs
             * @property {number|Long|null} [cpuTimeUs] CompilationStats cpuTimeUs
             */

            /**
             * Constructs a new CompilationStats.
             * @memberof Ydb.TableStats
             * @classdesc Represents a CompilationStats.
             * @implements ICompilationStats
             * @constructor
             * @param {Ydb.TableStats.ICompilationStats=} [properties] Properties to set
             */
            function CompilationStats(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CompilationStats fromCache.
             * @member {boolean} fromCache
             * @memberof Ydb.TableStats.CompilationStats
             * @instance
             */
            CompilationStats.prototype.fromCache = false;

            /**
             * CompilationStats durationUs.
             * @member {number|Long} durationUs
             * @memberof Ydb.TableStats.CompilationStats
             * @instance
             */
            CompilationStats.prototype.durationUs = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * CompilationStats cpuTimeUs.
             * @member {number|Long} cpuTimeUs
             * @memberof Ydb.TableStats.CompilationStats
             * @instance
             */
            CompilationStats.prototype.cpuTimeUs = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Creates a new CompilationStats instance using the specified properties.
             * @function create
             * @memberof Ydb.TableStats.CompilationStats
             * @static
             * @param {Ydb.TableStats.ICompilationStats=} [properties] Properties to set
             * @returns {Ydb.TableStats.CompilationStats} CompilationStats instance
             */
            CompilationStats.create = function create(properties) {
                return new CompilationStats(properties);
            };

            /**
             * Encodes the specified CompilationStats message. Does not implicitly {@link Ydb.TableStats.CompilationStats.verify|verify} messages.
             * @function encode
             * @memberof Ydb.TableStats.CompilationStats
             * @static
             * @param {Ydb.TableStats.ICompilationStats} message CompilationStats message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CompilationStats.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.fromCache != null && Object.hasOwnProperty.call(message, "fromCache"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.fromCache);
                if (message.durationUs != null && Object.hasOwnProperty.call(message, "durationUs"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.durationUs);
                if (message.cpuTimeUs != null && Object.hasOwnProperty.call(message, "cpuTimeUs"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.cpuTimeUs);
                return writer;
            };

            /**
             * Encodes the specified CompilationStats message, length delimited. Does not implicitly {@link Ydb.TableStats.CompilationStats.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.TableStats.CompilationStats
             * @static
             * @param {Ydb.TableStats.ICompilationStats} message CompilationStats message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CompilationStats.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CompilationStats message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.TableStats.CompilationStats
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.TableStats.CompilationStats} CompilationStats
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CompilationStats.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.TableStats.CompilationStats();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.fromCache = reader.bool();
                        break;
                    case 2:
                        message.durationUs = reader.uint64();
                        break;
                    case 3:
                        message.cpuTimeUs = reader.uint64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a CompilationStats message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.TableStats.CompilationStats
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.TableStats.CompilationStats} CompilationStats
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CompilationStats.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CompilationStats message.
             * @function verify
             * @memberof Ydb.TableStats.CompilationStats
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CompilationStats.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.fromCache != null && message.hasOwnProperty("fromCache"))
                    if (typeof message.fromCache !== "boolean")
                        return "fromCache: boolean expected";
                if (message.durationUs != null && message.hasOwnProperty("durationUs"))
                    if (!$util.isInteger(message.durationUs) && !(message.durationUs && $util.isInteger(message.durationUs.low) && $util.isInteger(message.durationUs.high)))
                        return "durationUs: integer|Long expected";
                if (message.cpuTimeUs != null && message.hasOwnProperty("cpuTimeUs"))
                    if (!$util.isInteger(message.cpuTimeUs) && !(message.cpuTimeUs && $util.isInteger(message.cpuTimeUs.low) && $util.isInteger(message.cpuTimeUs.high)))
                        return "cpuTimeUs: integer|Long expected";
                return null;
            };

            /**
             * Creates a CompilationStats message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.TableStats.CompilationStats
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.TableStats.CompilationStats} CompilationStats
             */
            CompilationStats.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.TableStats.CompilationStats)
                    return object;
                var message = new $root.Ydb.TableStats.CompilationStats();
                if (object.fromCache != null)
                    message.fromCache = Boolean(object.fromCache);
                if (object.durationUs != null)
                    if ($util.Long)
                        (message.durationUs = $util.Long.fromValue(object.durationUs)).unsigned = true;
                    else if (typeof object.durationUs === "string")
                        message.durationUs = parseInt(object.durationUs, 10);
                    else if (typeof object.durationUs === "number")
                        message.durationUs = object.durationUs;
                    else if (typeof object.durationUs === "object")
                        message.durationUs = new $util.LongBits(object.durationUs.low >>> 0, object.durationUs.high >>> 0).toNumber(true);
                if (object.cpuTimeUs != null)
                    if ($util.Long)
                        (message.cpuTimeUs = $util.Long.fromValue(object.cpuTimeUs)).unsigned = true;
                    else if (typeof object.cpuTimeUs === "string")
                        message.cpuTimeUs = parseInt(object.cpuTimeUs, 10);
                    else if (typeof object.cpuTimeUs === "number")
                        message.cpuTimeUs = object.cpuTimeUs;
                    else if (typeof object.cpuTimeUs === "object")
                        message.cpuTimeUs = new $util.LongBits(object.cpuTimeUs.low >>> 0, object.cpuTimeUs.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a CompilationStats message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.TableStats.CompilationStats
             * @static
             * @param {Ydb.TableStats.CompilationStats} message CompilationStats
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CompilationStats.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.fromCache = false;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.durationUs = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.durationUs = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.cpuTimeUs = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.cpuTimeUs = options.longs === String ? "0" : 0;
                }
                if (message.fromCache != null && message.hasOwnProperty("fromCache"))
                    object.fromCache = message.fromCache;
                if (message.durationUs != null && message.hasOwnProperty("durationUs"))
                    if (typeof message.durationUs === "number")
                        object.durationUs = options.longs === String ? String(message.durationUs) : message.durationUs;
                    else
                        object.durationUs = options.longs === String ? $util.Long.prototype.toString.call(message.durationUs) : options.longs === Number ? new $util.LongBits(message.durationUs.low >>> 0, message.durationUs.high >>> 0).toNumber(true) : message.durationUs;
                if (message.cpuTimeUs != null && message.hasOwnProperty("cpuTimeUs"))
                    if (typeof message.cpuTimeUs === "number")
                        object.cpuTimeUs = options.longs === String ? String(message.cpuTimeUs) : message.cpuTimeUs;
                    else
                        object.cpuTimeUs = options.longs === String ? $util.Long.prototype.toString.call(message.cpuTimeUs) : options.longs === Number ? new $util.LongBits(message.cpuTimeUs.low >>> 0, message.cpuTimeUs.high >>> 0).toNumber(true) : message.cpuTimeUs;
                return object;
            };

            /**
             * Converts this CompilationStats to JSON.
             * @function toJSON
             * @memberof Ydb.TableStats.CompilationStats
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CompilationStats.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return CompilationStats;
        })();

        TableStats.QueryStats = (function() {

            /**
             * Properties of a QueryStats.
             * @memberof Ydb.TableStats
             * @interface IQueryStats
             * @property {Array.<Ydb.TableStats.IQueryPhaseStats>|null} [queryPhases] QueryStats queryPhases
             * @property {Ydb.TableStats.ICompilationStats|null} [compilation] QueryStats compilation
             * @property {number|Long|null} [processCpuTimeUs] QueryStats processCpuTimeUs
             * @property {string|null} [queryPlan] QueryStats queryPlan
             * @property {string|null} [queryAst] QueryStats queryAst
             */

            /**
             * Constructs a new QueryStats.
             * @memberof Ydb.TableStats
             * @classdesc Represents a QueryStats.
             * @implements IQueryStats
             * @constructor
             * @param {Ydb.TableStats.IQueryStats=} [properties] Properties to set
             */
            function QueryStats(properties) {
                this.queryPhases = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * QueryStats queryPhases.
             * @member {Array.<Ydb.TableStats.IQueryPhaseStats>} queryPhases
             * @memberof Ydb.TableStats.QueryStats
             * @instance
             */
            QueryStats.prototype.queryPhases = $util.emptyArray;

            /**
             * QueryStats compilation.
             * @member {Ydb.TableStats.ICompilationStats|null|undefined} compilation
             * @memberof Ydb.TableStats.QueryStats
             * @instance
             */
            QueryStats.prototype.compilation = null;

            /**
             * QueryStats processCpuTimeUs.
             * @member {number|Long} processCpuTimeUs
             * @memberof Ydb.TableStats.QueryStats
             * @instance
             */
            QueryStats.prototype.processCpuTimeUs = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * QueryStats queryPlan.
             * @member {string} queryPlan
             * @memberof Ydb.TableStats.QueryStats
             * @instance
             */
            QueryStats.prototype.queryPlan = "";

            /**
             * QueryStats queryAst.
             * @member {string} queryAst
             * @memberof Ydb.TableStats.QueryStats
             * @instance
             */
            QueryStats.prototype.queryAst = "";

            /**
             * Creates a new QueryStats instance using the specified properties.
             * @function create
             * @memberof Ydb.TableStats.QueryStats
             * @static
             * @param {Ydb.TableStats.IQueryStats=} [properties] Properties to set
             * @returns {Ydb.TableStats.QueryStats} QueryStats instance
             */
            QueryStats.create = function create(properties) {
                return new QueryStats(properties);
            };

            /**
             * Encodes the specified QueryStats message. Does not implicitly {@link Ydb.TableStats.QueryStats.verify|verify} messages.
             * @function encode
             * @memberof Ydb.TableStats.QueryStats
             * @static
             * @param {Ydb.TableStats.IQueryStats} message QueryStats message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryStats.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.queryPhases != null && message.queryPhases.length)
                    for (var i = 0; i < message.queryPhases.length; ++i)
                        $root.Ydb.TableStats.QueryPhaseStats.encode(message.queryPhases[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.compilation != null && Object.hasOwnProperty.call(message, "compilation"))
                    $root.Ydb.TableStats.CompilationStats.encode(message.compilation, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.processCpuTimeUs != null && Object.hasOwnProperty.call(message, "processCpuTimeUs"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.processCpuTimeUs);
                if (message.queryPlan != null && Object.hasOwnProperty.call(message, "queryPlan"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.queryPlan);
                if (message.queryAst != null && Object.hasOwnProperty.call(message, "queryAst"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.queryAst);
                return writer;
            };

            /**
             * Encodes the specified QueryStats message, length delimited. Does not implicitly {@link Ydb.TableStats.QueryStats.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.TableStats.QueryStats
             * @static
             * @param {Ydb.TableStats.IQueryStats} message QueryStats message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryStats.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a QueryStats message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.TableStats.QueryStats
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.TableStats.QueryStats} QueryStats
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryStats.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.TableStats.QueryStats();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.queryPhases && message.queryPhases.length))
                            message.queryPhases = [];
                        message.queryPhases.push($root.Ydb.TableStats.QueryPhaseStats.decode(reader, reader.uint32()));
                        break;
                    case 2:
                        message.compilation = $root.Ydb.TableStats.CompilationStats.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.processCpuTimeUs = reader.uint64();
                        break;
                    case 4:
                        message.queryPlan = reader.string();
                        break;
                    case 5:
                        message.queryAst = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a QueryStats message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.TableStats.QueryStats
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.TableStats.QueryStats} QueryStats
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryStats.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a QueryStats message.
             * @function verify
             * @memberof Ydb.TableStats.QueryStats
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            QueryStats.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.queryPhases != null && message.hasOwnProperty("queryPhases")) {
                    if (!Array.isArray(message.queryPhases))
                        return "queryPhases: array expected";
                    for (var i = 0; i < message.queryPhases.length; ++i) {
                        var error = $root.Ydb.TableStats.QueryPhaseStats.verify(message.queryPhases[i]);
                        if (error)
                            return "queryPhases." + error;
                    }
                }
                if (message.compilation != null && message.hasOwnProperty("compilation")) {
                    var error = $root.Ydb.TableStats.CompilationStats.verify(message.compilation);
                    if (error)
                        return "compilation." + error;
                }
                if (message.processCpuTimeUs != null && message.hasOwnProperty("processCpuTimeUs"))
                    if (!$util.isInteger(message.processCpuTimeUs) && !(message.processCpuTimeUs && $util.isInteger(message.processCpuTimeUs.low) && $util.isInteger(message.processCpuTimeUs.high)))
                        return "processCpuTimeUs: integer|Long expected";
                if (message.queryPlan != null && message.hasOwnProperty("queryPlan"))
                    if (!$util.isString(message.queryPlan))
                        return "queryPlan: string expected";
                if (message.queryAst != null && message.hasOwnProperty("queryAst"))
                    if (!$util.isString(message.queryAst))
                        return "queryAst: string expected";
                return null;
            };

            /**
             * Creates a QueryStats message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.TableStats.QueryStats
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.TableStats.QueryStats} QueryStats
             */
            QueryStats.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.TableStats.QueryStats)
                    return object;
                var message = new $root.Ydb.TableStats.QueryStats();
                if (object.queryPhases) {
                    if (!Array.isArray(object.queryPhases))
                        throw TypeError(".Ydb.TableStats.QueryStats.queryPhases: array expected");
                    message.queryPhases = [];
                    for (var i = 0; i < object.queryPhases.length; ++i) {
                        if (typeof object.queryPhases[i] !== "object")
                            throw TypeError(".Ydb.TableStats.QueryStats.queryPhases: object expected");
                        message.queryPhases[i] = $root.Ydb.TableStats.QueryPhaseStats.fromObject(object.queryPhases[i]);
                    }
                }
                if (object.compilation != null) {
                    if (typeof object.compilation !== "object")
                        throw TypeError(".Ydb.TableStats.QueryStats.compilation: object expected");
                    message.compilation = $root.Ydb.TableStats.CompilationStats.fromObject(object.compilation);
                }
                if (object.processCpuTimeUs != null)
                    if ($util.Long)
                        (message.processCpuTimeUs = $util.Long.fromValue(object.processCpuTimeUs)).unsigned = true;
                    else if (typeof object.processCpuTimeUs === "string")
                        message.processCpuTimeUs = parseInt(object.processCpuTimeUs, 10);
                    else if (typeof object.processCpuTimeUs === "number")
                        message.processCpuTimeUs = object.processCpuTimeUs;
                    else if (typeof object.processCpuTimeUs === "object")
                        message.processCpuTimeUs = new $util.LongBits(object.processCpuTimeUs.low >>> 0, object.processCpuTimeUs.high >>> 0).toNumber(true);
                if (object.queryPlan != null)
                    message.queryPlan = String(object.queryPlan);
                if (object.queryAst != null)
                    message.queryAst = String(object.queryAst);
                return message;
            };

            /**
             * Creates a plain object from a QueryStats message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.TableStats.QueryStats
             * @static
             * @param {Ydb.TableStats.QueryStats} message QueryStats
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            QueryStats.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.queryPhases = [];
                if (options.defaults) {
                    object.compilation = null;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.processCpuTimeUs = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.processCpuTimeUs = options.longs === String ? "0" : 0;
                    object.queryPlan = "";
                    object.queryAst = "";
                }
                if (message.queryPhases && message.queryPhases.length) {
                    object.queryPhases = [];
                    for (var j = 0; j < message.queryPhases.length; ++j)
                        object.queryPhases[j] = $root.Ydb.TableStats.QueryPhaseStats.toObject(message.queryPhases[j], options);
                }
                if (message.compilation != null && message.hasOwnProperty("compilation"))
                    object.compilation = $root.Ydb.TableStats.CompilationStats.toObject(message.compilation, options);
                if (message.processCpuTimeUs != null && message.hasOwnProperty("processCpuTimeUs"))
                    if (typeof message.processCpuTimeUs === "number")
                        object.processCpuTimeUs = options.longs === String ? String(message.processCpuTimeUs) : message.processCpuTimeUs;
                    else
                        object.processCpuTimeUs = options.longs === String ? $util.Long.prototype.toString.call(message.processCpuTimeUs) : options.longs === Number ? new $util.LongBits(message.processCpuTimeUs.low >>> 0, message.processCpuTimeUs.high >>> 0).toNumber(true) : message.processCpuTimeUs;
                if (message.queryPlan != null && message.hasOwnProperty("queryPlan"))
                    object.queryPlan = message.queryPlan;
                if (message.queryAst != null && message.hasOwnProperty("queryAst"))
                    object.queryAst = message.queryAst;
                return object;
            };

            /**
             * Converts this QueryStats to JSON.
             * @function toJSON
             * @memberof Ydb.TableStats.QueryStats
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            QueryStats.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return QueryStats;
        })();

        return TableStats;
    })();

    Ydb.DecimalType = (function() {

        /**
         * Properties of a DecimalType.
         * @memberof Ydb
         * @interface IDecimalType
         * @property {number|null} [precision] DecimalType precision
         * @property {number|null} [scale] DecimalType scale
         */

        /**
         * Constructs a new DecimalType.
         * @memberof Ydb
         * @classdesc Represents a DecimalType.
         * @implements IDecimalType
         * @constructor
         * @param {Ydb.IDecimalType=} [properties] Properties to set
         */
        function DecimalType(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DecimalType precision.
         * @member {number} precision
         * @memberof Ydb.DecimalType
         * @instance
         */
        DecimalType.prototype.precision = 0;

        /**
         * DecimalType scale.
         * @member {number} scale
         * @memberof Ydb.DecimalType
         * @instance
         */
        DecimalType.prototype.scale = 0;

        /**
         * Creates a new DecimalType instance using the specified properties.
         * @function create
         * @memberof Ydb.DecimalType
         * @static
         * @param {Ydb.IDecimalType=} [properties] Properties to set
         * @returns {Ydb.DecimalType} DecimalType instance
         */
        DecimalType.create = function create(properties) {
            return new DecimalType(properties);
        };

        /**
         * Encodes the specified DecimalType message. Does not implicitly {@link Ydb.DecimalType.verify|verify} messages.
         * @function encode
         * @memberof Ydb.DecimalType
         * @static
         * @param {Ydb.IDecimalType} message DecimalType message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DecimalType.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.precision != null && Object.hasOwnProperty.call(message, "precision"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.precision);
            if (message.scale != null && Object.hasOwnProperty.call(message, "scale"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.scale);
            return writer;
        };

        /**
         * Encodes the specified DecimalType message, length delimited. Does not implicitly {@link Ydb.DecimalType.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Ydb.DecimalType
         * @static
         * @param {Ydb.IDecimalType} message DecimalType message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DecimalType.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DecimalType message from the specified reader or buffer.
         * @function decode
         * @memberof Ydb.DecimalType
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Ydb.DecimalType} DecimalType
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DecimalType.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.DecimalType();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.precision = reader.uint32();
                    break;
                case 2:
                    message.scale = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DecimalType message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Ydb.DecimalType
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Ydb.DecimalType} DecimalType
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DecimalType.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DecimalType message.
         * @function verify
         * @memberof Ydb.DecimalType
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DecimalType.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.precision != null && message.hasOwnProperty("precision"))
                if (!$util.isInteger(message.precision))
                    return "precision: integer expected";
            if (message.scale != null && message.hasOwnProperty("scale"))
                if (!$util.isInteger(message.scale))
                    return "scale: integer expected";
            return null;
        };

        /**
         * Creates a DecimalType message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Ydb.DecimalType
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Ydb.DecimalType} DecimalType
         */
        DecimalType.fromObject = function fromObject(object) {
            if (object instanceof $root.Ydb.DecimalType)
                return object;
            var message = new $root.Ydb.DecimalType();
            if (object.precision != null)
                message.precision = object.precision >>> 0;
            if (object.scale != null)
                message.scale = object.scale >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a DecimalType message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Ydb.DecimalType
         * @static
         * @param {Ydb.DecimalType} message DecimalType
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DecimalType.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.precision = 0;
                object.scale = 0;
            }
            if (message.precision != null && message.hasOwnProperty("precision"))
                object.precision = message.precision;
            if (message.scale != null && message.hasOwnProperty("scale"))
                object.scale = message.scale;
            return object;
        };

        /**
         * Converts this DecimalType to JSON.
         * @function toJSON
         * @memberof Ydb.DecimalType
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DecimalType.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DecimalType;
    })();

    Ydb.OptionalType = (function() {

        /**
         * Properties of an OptionalType.
         * @memberof Ydb
         * @interface IOptionalType
         * @property {Ydb.IType|null} [item] OptionalType item
         */

        /**
         * Constructs a new OptionalType.
         * @memberof Ydb
         * @classdesc Represents an OptionalType.
         * @implements IOptionalType
         * @constructor
         * @param {Ydb.IOptionalType=} [properties] Properties to set
         */
        function OptionalType(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * OptionalType item.
         * @member {Ydb.IType|null|undefined} item
         * @memberof Ydb.OptionalType
         * @instance
         */
        OptionalType.prototype.item = null;

        /**
         * Creates a new OptionalType instance using the specified properties.
         * @function create
         * @memberof Ydb.OptionalType
         * @static
         * @param {Ydb.IOptionalType=} [properties] Properties to set
         * @returns {Ydb.OptionalType} OptionalType instance
         */
        OptionalType.create = function create(properties) {
            return new OptionalType(properties);
        };

        /**
         * Encodes the specified OptionalType message. Does not implicitly {@link Ydb.OptionalType.verify|verify} messages.
         * @function encode
         * @memberof Ydb.OptionalType
         * @static
         * @param {Ydb.IOptionalType} message OptionalType message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OptionalType.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.item != null && Object.hasOwnProperty.call(message, "item"))
                $root.Ydb.Type.encode(message.item, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified OptionalType message, length delimited. Does not implicitly {@link Ydb.OptionalType.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Ydb.OptionalType
         * @static
         * @param {Ydb.IOptionalType} message OptionalType message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OptionalType.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an OptionalType message from the specified reader or buffer.
         * @function decode
         * @memberof Ydb.OptionalType
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Ydb.OptionalType} OptionalType
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OptionalType.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.OptionalType();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.item = $root.Ydb.Type.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an OptionalType message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Ydb.OptionalType
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Ydb.OptionalType} OptionalType
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OptionalType.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an OptionalType message.
         * @function verify
         * @memberof Ydb.OptionalType
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        OptionalType.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.item != null && message.hasOwnProperty("item")) {
                var error = $root.Ydb.Type.verify(message.item);
                if (error)
                    return "item." + error;
            }
            return null;
        };

        /**
         * Creates an OptionalType message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Ydb.OptionalType
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Ydb.OptionalType} OptionalType
         */
        OptionalType.fromObject = function fromObject(object) {
            if (object instanceof $root.Ydb.OptionalType)
                return object;
            var message = new $root.Ydb.OptionalType();
            if (object.item != null) {
                if (typeof object.item !== "object")
                    throw TypeError(".Ydb.OptionalType.item: object expected");
                message.item = $root.Ydb.Type.fromObject(object.item);
            }
            return message;
        };

        /**
         * Creates a plain object from an OptionalType message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Ydb.OptionalType
         * @static
         * @param {Ydb.OptionalType} message OptionalType
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        OptionalType.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.item = null;
            if (message.item != null && message.hasOwnProperty("item"))
                object.item = $root.Ydb.Type.toObject(message.item, options);
            return object;
        };

        /**
         * Converts this OptionalType to JSON.
         * @function toJSON
         * @memberof Ydb.OptionalType
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        OptionalType.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return OptionalType;
    })();

    Ydb.ListType = (function() {

        /**
         * Properties of a ListType.
         * @memberof Ydb
         * @interface IListType
         * @property {Ydb.IType|null} [item] ListType item
         */

        /**
         * Constructs a new ListType.
         * @memberof Ydb
         * @classdesc Represents a ListType.
         * @implements IListType
         * @constructor
         * @param {Ydb.IListType=} [properties] Properties to set
         */
        function ListType(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ListType item.
         * @member {Ydb.IType|null|undefined} item
         * @memberof Ydb.ListType
         * @instance
         */
        ListType.prototype.item = null;

        /**
         * Creates a new ListType instance using the specified properties.
         * @function create
         * @memberof Ydb.ListType
         * @static
         * @param {Ydb.IListType=} [properties] Properties to set
         * @returns {Ydb.ListType} ListType instance
         */
        ListType.create = function create(properties) {
            return new ListType(properties);
        };

        /**
         * Encodes the specified ListType message. Does not implicitly {@link Ydb.ListType.verify|verify} messages.
         * @function encode
         * @memberof Ydb.ListType
         * @static
         * @param {Ydb.IListType} message ListType message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ListType.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.item != null && Object.hasOwnProperty.call(message, "item"))
                $root.Ydb.Type.encode(message.item, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ListType message, length delimited. Does not implicitly {@link Ydb.ListType.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Ydb.ListType
         * @static
         * @param {Ydb.IListType} message ListType message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ListType.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ListType message from the specified reader or buffer.
         * @function decode
         * @memberof Ydb.ListType
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Ydb.ListType} ListType
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ListType.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.ListType();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.item = $root.Ydb.Type.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ListType message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Ydb.ListType
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Ydb.ListType} ListType
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ListType.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ListType message.
         * @function verify
         * @memberof Ydb.ListType
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ListType.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.item != null && message.hasOwnProperty("item")) {
                var error = $root.Ydb.Type.verify(message.item);
                if (error)
                    return "item." + error;
            }
            return null;
        };

        /**
         * Creates a ListType message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Ydb.ListType
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Ydb.ListType} ListType
         */
        ListType.fromObject = function fromObject(object) {
            if (object instanceof $root.Ydb.ListType)
                return object;
            var message = new $root.Ydb.ListType();
            if (object.item != null) {
                if (typeof object.item !== "object")
                    throw TypeError(".Ydb.ListType.item: object expected");
                message.item = $root.Ydb.Type.fromObject(object.item);
            }
            return message;
        };

        /**
         * Creates a plain object from a ListType message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Ydb.ListType
         * @static
         * @param {Ydb.ListType} message ListType
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ListType.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.item = null;
            if (message.item != null && message.hasOwnProperty("item"))
                object.item = $root.Ydb.Type.toObject(message.item, options);
            return object;
        };

        /**
         * Converts this ListType to JSON.
         * @function toJSON
         * @memberof Ydb.ListType
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ListType.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ListType;
    })();

    Ydb.VariantType = (function() {

        /**
         * Properties of a VariantType.
         * @memberof Ydb
         * @interface IVariantType
         * @property {Ydb.ITupleType|null} [tupleItems] VariantType tupleItems
         * @property {Ydb.IStructType|null} [structItems] VariantType structItems
         */

        /**
         * Constructs a new VariantType.
         * @memberof Ydb
         * @classdesc Represents a VariantType.
         * @implements IVariantType
         * @constructor
         * @param {Ydb.IVariantType=} [properties] Properties to set
         */
        function VariantType(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * VariantType tupleItems.
         * @member {Ydb.ITupleType|null|undefined} tupleItems
         * @memberof Ydb.VariantType
         * @instance
         */
        VariantType.prototype.tupleItems = null;

        /**
         * VariantType structItems.
         * @member {Ydb.IStructType|null|undefined} structItems
         * @memberof Ydb.VariantType
         * @instance
         */
        VariantType.prototype.structItems = null;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * VariantType type.
         * @member {"tupleItems"|"structItems"|undefined} type
         * @memberof Ydb.VariantType
         * @instance
         */
        Object.defineProperty(VariantType.prototype, "type", {
            get: $util.oneOfGetter($oneOfFields = ["tupleItems", "structItems"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new VariantType instance using the specified properties.
         * @function create
         * @memberof Ydb.VariantType
         * @static
         * @param {Ydb.IVariantType=} [properties] Properties to set
         * @returns {Ydb.VariantType} VariantType instance
         */
        VariantType.create = function create(properties) {
            return new VariantType(properties);
        };

        /**
         * Encodes the specified VariantType message. Does not implicitly {@link Ydb.VariantType.verify|verify} messages.
         * @function encode
         * @memberof Ydb.VariantType
         * @static
         * @param {Ydb.IVariantType} message VariantType message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VariantType.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tupleItems != null && Object.hasOwnProperty.call(message, "tupleItems"))
                $root.Ydb.TupleType.encode(message.tupleItems, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.structItems != null && Object.hasOwnProperty.call(message, "structItems"))
                $root.Ydb.StructType.encode(message.structItems, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified VariantType message, length delimited. Does not implicitly {@link Ydb.VariantType.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Ydb.VariantType
         * @static
         * @param {Ydb.IVariantType} message VariantType message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VariantType.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a VariantType message from the specified reader or buffer.
         * @function decode
         * @memberof Ydb.VariantType
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Ydb.VariantType} VariantType
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VariantType.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.VariantType();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.tupleItems = $root.Ydb.TupleType.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.structItems = $root.Ydb.StructType.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a VariantType message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Ydb.VariantType
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Ydb.VariantType} VariantType
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VariantType.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a VariantType message.
         * @function verify
         * @memberof Ydb.VariantType
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        VariantType.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.tupleItems != null && message.hasOwnProperty("tupleItems")) {
                properties.type = 1;
                {
                    var error = $root.Ydb.TupleType.verify(message.tupleItems);
                    if (error)
                        return "tupleItems." + error;
                }
            }
            if (message.structItems != null && message.hasOwnProperty("structItems")) {
                if (properties.type === 1)
                    return "type: multiple values";
                properties.type = 1;
                {
                    var error = $root.Ydb.StructType.verify(message.structItems);
                    if (error)
                        return "structItems." + error;
                }
            }
            return null;
        };

        /**
         * Creates a VariantType message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Ydb.VariantType
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Ydb.VariantType} VariantType
         */
        VariantType.fromObject = function fromObject(object) {
            if (object instanceof $root.Ydb.VariantType)
                return object;
            var message = new $root.Ydb.VariantType();
            if (object.tupleItems != null) {
                if (typeof object.tupleItems !== "object")
                    throw TypeError(".Ydb.VariantType.tupleItems: object expected");
                message.tupleItems = $root.Ydb.TupleType.fromObject(object.tupleItems);
            }
            if (object.structItems != null) {
                if (typeof object.structItems !== "object")
                    throw TypeError(".Ydb.VariantType.structItems: object expected");
                message.structItems = $root.Ydb.StructType.fromObject(object.structItems);
            }
            return message;
        };

        /**
         * Creates a plain object from a VariantType message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Ydb.VariantType
         * @static
         * @param {Ydb.VariantType} message VariantType
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        VariantType.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (message.tupleItems != null && message.hasOwnProperty("tupleItems")) {
                object.tupleItems = $root.Ydb.TupleType.toObject(message.tupleItems, options);
                if (options.oneofs)
                    object.type = "tupleItems";
            }
            if (message.structItems != null && message.hasOwnProperty("structItems")) {
                object.structItems = $root.Ydb.StructType.toObject(message.structItems, options);
                if (options.oneofs)
                    object.type = "structItems";
            }
            return object;
        };

        /**
         * Converts this VariantType to JSON.
         * @function toJSON
         * @memberof Ydb.VariantType
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        VariantType.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return VariantType;
    })();

    Ydb.TupleType = (function() {

        /**
         * Properties of a TupleType.
         * @memberof Ydb
         * @interface ITupleType
         * @property {Array.<Ydb.IType>|null} [elements] TupleType elements
         */

        /**
         * Constructs a new TupleType.
         * @memberof Ydb
         * @classdesc Represents a TupleType.
         * @implements ITupleType
         * @constructor
         * @param {Ydb.ITupleType=} [properties] Properties to set
         */
        function TupleType(properties) {
            this.elements = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TupleType elements.
         * @member {Array.<Ydb.IType>} elements
         * @memberof Ydb.TupleType
         * @instance
         */
        TupleType.prototype.elements = $util.emptyArray;

        /**
         * Creates a new TupleType instance using the specified properties.
         * @function create
         * @memberof Ydb.TupleType
         * @static
         * @param {Ydb.ITupleType=} [properties] Properties to set
         * @returns {Ydb.TupleType} TupleType instance
         */
        TupleType.create = function create(properties) {
            return new TupleType(properties);
        };

        /**
         * Encodes the specified TupleType message. Does not implicitly {@link Ydb.TupleType.verify|verify} messages.
         * @function encode
         * @memberof Ydb.TupleType
         * @static
         * @param {Ydb.ITupleType} message TupleType message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TupleType.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.elements != null && message.elements.length)
                for (var i = 0; i < message.elements.length; ++i)
                    $root.Ydb.Type.encode(message.elements[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified TupleType message, length delimited. Does not implicitly {@link Ydb.TupleType.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Ydb.TupleType
         * @static
         * @param {Ydb.ITupleType} message TupleType message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TupleType.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TupleType message from the specified reader or buffer.
         * @function decode
         * @memberof Ydb.TupleType
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Ydb.TupleType} TupleType
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TupleType.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.TupleType();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.elements && message.elements.length))
                        message.elements = [];
                    message.elements.push($root.Ydb.Type.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TupleType message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Ydb.TupleType
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Ydb.TupleType} TupleType
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TupleType.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TupleType message.
         * @function verify
         * @memberof Ydb.TupleType
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TupleType.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.elements != null && message.hasOwnProperty("elements")) {
                if (!Array.isArray(message.elements))
                    return "elements: array expected";
                for (var i = 0; i < message.elements.length; ++i) {
                    var error = $root.Ydb.Type.verify(message.elements[i]);
                    if (error)
                        return "elements." + error;
                }
            }
            return null;
        };

        /**
         * Creates a TupleType message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Ydb.TupleType
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Ydb.TupleType} TupleType
         */
        TupleType.fromObject = function fromObject(object) {
            if (object instanceof $root.Ydb.TupleType)
                return object;
            var message = new $root.Ydb.TupleType();
            if (object.elements) {
                if (!Array.isArray(object.elements))
                    throw TypeError(".Ydb.TupleType.elements: array expected");
                message.elements = [];
                for (var i = 0; i < object.elements.length; ++i) {
                    if (typeof object.elements[i] !== "object")
                        throw TypeError(".Ydb.TupleType.elements: object expected");
                    message.elements[i] = $root.Ydb.Type.fromObject(object.elements[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a TupleType message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Ydb.TupleType
         * @static
         * @param {Ydb.TupleType} message TupleType
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TupleType.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.elements = [];
            if (message.elements && message.elements.length) {
                object.elements = [];
                for (var j = 0; j < message.elements.length; ++j)
                    object.elements[j] = $root.Ydb.Type.toObject(message.elements[j], options);
            }
            return object;
        };

        /**
         * Converts this TupleType to JSON.
         * @function toJSON
         * @memberof Ydb.TupleType
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TupleType.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TupleType;
    })();

    Ydb.StructMember = (function() {

        /**
         * Properties of a StructMember.
         * @memberof Ydb
         * @interface IStructMember
         * @property {string|null} [name] StructMember name
         * @property {Ydb.IType|null} [type] StructMember type
         */

        /**
         * Constructs a new StructMember.
         * @memberof Ydb
         * @classdesc Represents a StructMember.
         * @implements IStructMember
         * @constructor
         * @param {Ydb.IStructMember=} [properties] Properties to set
         */
        function StructMember(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StructMember name.
         * @member {string} name
         * @memberof Ydb.StructMember
         * @instance
         */
        StructMember.prototype.name = "";

        /**
         * StructMember type.
         * @member {Ydb.IType|null|undefined} type
         * @memberof Ydb.StructMember
         * @instance
         */
        StructMember.prototype.type = null;

        /**
         * Creates a new StructMember instance using the specified properties.
         * @function create
         * @memberof Ydb.StructMember
         * @static
         * @param {Ydb.IStructMember=} [properties] Properties to set
         * @returns {Ydb.StructMember} StructMember instance
         */
        StructMember.create = function create(properties) {
            return new StructMember(properties);
        };

        /**
         * Encodes the specified StructMember message. Does not implicitly {@link Ydb.StructMember.verify|verify} messages.
         * @function encode
         * @memberof Ydb.StructMember
         * @static
         * @param {Ydb.IStructMember} message StructMember message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StructMember.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                $root.Ydb.Type.encode(message.type, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified StructMember message, length delimited. Does not implicitly {@link Ydb.StructMember.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Ydb.StructMember
         * @static
         * @param {Ydb.IStructMember} message StructMember message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StructMember.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a StructMember message from the specified reader or buffer.
         * @function decode
         * @memberof Ydb.StructMember
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Ydb.StructMember} StructMember
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StructMember.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.StructMember();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                case 2:
                    message.type = $root.Ydb.Type.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a StructMember message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Ydb.StructMember
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Ydb.StructMember} StructMember
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StructMember.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a StructMember message.
         * @function verify
         * @memberof Ydb.StructMember
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        StructMember.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.type != null && message.hasOwnProperty("type")) {
                var error = $root.Ydb.Type.verify(message.type);
                if (error)
                    return "type." + error;
            }
            return null;
        };

        /**
         * Creates a StructMember message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Ydb.StructMember
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Ydb.StructMember} StructMember
         */
        StructMember.fromObject = function fromObject(object) {
            if (object instanceof $root.Ydb.StructMember)
                return object;
            var message = new $root.Ydb.StructMember();
            if (object.name != null)
                message.name = String(object.name);
            if (object.type != null) {
                if (typeof object.type !== "object")
                    throw TypeError(".Ydb.StructMember.type: object expected");
                message.type = $root.Ydb.Type.fromObject(object.type);
            }
            return message;
        };

        /**
         * Creates a plain object from a StructMember message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Ydb.StructMember
         * @static
         * @param {Ydb.StructMember} message StructMember
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        StructMember.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.name = "";
                object.type = null;
            }
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = $root.Ydb.Type.toObject(message.type, options);
            return object;
        };

        /**
         * Converts this StructMember to JSON.
         * @function toJSON
         * @memberof Ydb.StructMember
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        StructMember.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return StructMember;
    })();

    Ydb.StructType = (function() {

        /**
         * Properties of a StructType.
         * @memberof Ydb
         * @interface IStructType
         * @property {Array.<Ydb.IStructMember>|null} [members] StructType members
         */

        /**
         * Constructs a new StructType.
         * @memberof Ydb
         * @classdesc Represents a StructType.
         * @implements IStructType
         * @constructor
         * @param {Ydb.IStructType=} [properties] Properties to set
         */
        function StructType(properties) {
            this.members = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StructType members.
         * @member {Array.<Ydb.IStructMember>} members
         * @memberof Ydb.StructType
         * @instance
         */
        StructType.prototype.members = $util.emptyArray;

        /**
         * Creates a new StructType instance using the specified properties.
         * @function create
         * @memberof Ydb.StructType
         * @static
         * @param {Ydb.IStructType=} [properties] Properties to set
         * @returns {Ydb.StructType} StructType instance
         */
        StructType.create = function create(properties) {
            return new StructType(properties);
        };

        /**
         * Encodes the specified StructType message. Does not implicitly {@link Ydb.StructType.verify|verify} messages.
         * @function encode
         * @memberof Ydb.StructType
         * @static
         * @param {Ydb.IStructType} message StructType message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StructType.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.members != null && message.members.length)
                for (var i = 0; i < message.members.length; ++i)
                    $root.Ydb.StructMember.encode(message.members[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified StructType message, length delimited. Does not implicitly {@link Ydb.StructType.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Ydb.StructType
         * @static
         * @param {Ydb.IStructType} message StructType message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StructType.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a StructType message from the specified reader or buffer.
         * @function decode
         * @memberof Ydb.StructType
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Ydb.StructType} StructType
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StructType.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.StructType();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.members && message.members.length))
                        message.members = [];
                    message.members.push($root.Ydb.StructMember.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a StructType message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Ydb.StructType
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Ydb.StructType} StructType
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StructType.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a StructType message.
         * @function verify
         * @memberof Ydb.StructType
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        StructType.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.members != null && message.hasOwnProperty("members")) {
                if (!Array.isArray(message.members))
                    return "members: array expected";
                for (var i = 0; i < message.members.length; ++i) {
                    var error = $root.Ydb.StructMember.verify(message.members[i]);
                    if (error)
                        return "members." + error;
                }
            }
            return null;
        };

        /**
         * Creates a StructType message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Ydb.StructType
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Ydb.StructType} StructType
         */
        StructType.fromObject = function fromObject(object) {
            if (object instanceof $root.Ydb.StructType)
                return object;
            var message = new $root.Ydb.StructType();
            if (object.members) {
                if (!Array.isArray(object.members))
                    throw TypeError(".Ydb.StructType.members: array expected");
                message.members = [];
                for (var i = 0; i < object.members.length; ++i) {
                    if (typeof object.members[i] !== "object")
                        throw TypeError(".Ydb.StructType.members: object expected");
                    message.members[i] = $root.Ydb.StructMember.fromObject(object.members[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a StructType message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Ydb.StructType
         * @static
         * @param {Ydb.StructType} message StructType
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        StructType.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.members = [];
            if (message.members && message.members.length) {
                object.members = [];
                for (var j = 0; j < message.members.length; ++j)
                    object.members[j] = $root.Ydb.StructMember.toObject(message.members[j], options);
            }
            return object;
        };

        /**
         * Converts this StructType to JSON.
         * @function toJSON
         * @memberof Ydb.StructType
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        StructType.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return StructType;
    })();

    Ydb.DictType = (function() {

        /**
         * Properties of a DictType.
         * @memberof Ydb
         * @interface IDictType
         * @property {Ydb.IType|null} [key] DictType key
         * @property {Ydb.IType|null} [payload] DictType payload
         */

        /**
         * Constructs a new DictType.
         * @memberof Ydb
         * @classdesc Represents a DictType.
         * @implements IDictType
         * @constructor
         * @param {Ydb.IDictType=} [properties] Properties to set
         */
        function DictType(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DictType key.
         * @member {Ydb.IType|null|undefined} key
         * @memberof Ydb.DictType
         * @instance
         */
        DictType.prototype.key = null;

        /**
         * DictType payload.
         * @member {Ydb.IType|null|undefined} payload
         * @memberof Ydb.DictType
         * @instance
         */
        DictType.prototype.payload = null;

        /**
         * Creates a new DictType instance using the specified properties.
         * @function create
         * @memberof Ydb.DictType
         * @static
         * @param {Ydb.IDictType=} [properties] Properties to set
         * @returns {Ydb.DictType} DictType instance
         */
        DictType.create = function create(properties) {
            return new DictType(properties);
        };

        /**
         * Encodes the specified DictType message. Does not implicitly {@link Ydb.DictType.verify|verify} messages.
         * @function encode
         * @memberof Ydb.DictType
         * @static
         * @param {Ydb.IDictType} message DictType message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DictType.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                $root.Ydb.Type.encode(message.key, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.payload != null && Object.hasOwnProperty.call(message, "payload"))
                $root.Ydb.Type.encode(message.payload, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified DictType message, length delimited. Does not implicitly {@link Ydb.DictType.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Ydb.DictType
         * @static
         * @param {Ydb.IDictType} message DictType message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DictType.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DictType message from the specified reader or buffer.
         * @function decode
         * @memberof Ydb.DictType
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Ydb.DictType} DictType
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DictType.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.DictType();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.key = $root.Ydb.Type.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.payload = $root.Ydb.Type.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DictType message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Ydb.DictType
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Ydb.DictType} DictType
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DictType.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DictType message.
         * @function verify
         * @memberof Ydb.DictType
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DictType.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.key != null && message.hasOwnProperty("key")) {
                var error = $root.Ydb.Type.verify(message.key);
                if (error)
                    return "key." + error;
            }
            if (message.payload != null && message.hasOwnProperty("payload")) {
                var error = $root.Ydb.Type.verify(message.payload);
                if (error)
                    return "payload." + error;
            }
            return null;
        };

        /**
         * Creates a DictType message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Ydb.DictType
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Ydb.DictType} DictType
         */
        DictType.fromObject = function fromObject(object) {
            if (object instanceof $root.Ydb.DictType)
                return object;
            var message = new $root.Ydb.DictType();
            if (object.key != null) {
                if (typeof object.key !== "object")
                    throw TypeError(".Ydb.DictType.key: object expected");
                message.key = $root.Ydb.Type.fromObject(object.key);
            }
            if (object.payload != null) {
                if (typeof object.payload !== "object")
                    throw TypeError(".Ydb.DictType.payload: object expected");
                message.payload = $root.Ydb.Type.fromObject(object.payload);
            }
            return message;
        };

        /**
         * Creates a plain object from a DictType message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Ydb.DictType
         * @static
         * @param {Ydb.DictType} message DictType
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DictType.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.key = null;
                object.payload = null;
            }
            if (message.key != null && message.hasOwnProperty("key"))
                object.key = $root.Ydb.Type.toObject(message.key, options);
            if (message.payload != null && message.hasOwnProperty("payload"))
                object.payload = $root.Ydb.Type.toObject(message.payload, options);
            return object;
        };

        /**
         * Converts this DictType to JSON.
         * @function toJSON
         * @memberof Ydb.DictType
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DictType.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DictType;
    })();

    Ydb.Type = (function() {

        /**
         * Properties of a Type.
         * @memberof Ydb
         * @interface IType
         * @property {Ydb.Type.PrimitiveTypeId|null} [typeId] Type typeId
         * @property {Ydb.IDecimalType|null} [decimalType] Type decimalType
         * @property {Ydb.IOptionalType|null} [optionalType] Type optionalType
         * @property {Ydb.IListType|null} [listType] Type listType
         * @property {Ydb.ITupleType|null} [tupleType] Type tupleType
         * @property {Ydb.IStructType|null} [structType] Type structType
         * @property {Ydb.IDictType|null} [dictType] Type dictType
         * @property {Ydb.IVariantType|null} [variantType] Type variantType
         * @property {google.protobuf.NullValue|null} [voidType] Type voidType
         */

        /**
         * Constructs a new Type.
         * @memberof Ydb
         * @classdesc Represents a Type.
         * @implements IType
         * @constructor
         * @param {Ydb.IType=} [properties] Properties to set
         */
        function Type(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Type typeId.
         * @member {Ydb.Type.PrimitiveTypeId|null|undefined} typeId
         * @memberof Ydb.Type
         * @instance
         */
        Type.prototype.typeId = null;

        /**
         * Type decimalType.
         * @member {Ydb.IDecimalType|null|undefined} decimalType
         * @memberof Ydb.Type
         * @instance
         */
        Type.prototype.decimalType = null;

        /**
         * Type optionalType.
         * @member {Ydb.IOptionalType|null|undefined} optionalType
         * @memberof Ydb.Type
         * @instance
         */
        Type.prototype.optionalType = null;

        /**
         * Type listType.
         * @member {Ydb.IListType|null|undefined} listType
         * @memberof Ydb.Type
         * @instance
         */
        Type.prototype.listType = null;

        /**
         * Type tupleType.
         * @member {Ydb.ITupleType|null|undefined} tupleType
         * @memberof Ydb.Type
         * @instance
         */
        Type.prototype.tupleType = null;

        /**
         * Type structType.
         * @member {Ydb.IStructType|null|undefined} structType
         * @memberof Ydb.Type
         * @instance
         */
        Type.prototype.structType = null;

        /**
         * Type dictType.
         * @member {Ydb.IDictType|null|undefined} dictType
         * @memberof Ydb.Type
         * @instance
         */
        Type.prototype.dictType = null;

        /**
         * Type variantType.
         * @member {Ydb.IVariantType|null|undefined} variantType
         * @memberof Ydb.Type
         * @instance
         */
        Type.prototype.variantType = null;

        /**
         * Type voidType.
         * @member {google.protobuf.NullValue|null|undefined} voidType
         * @memberof Ydb.Type
         * @instance
         */
        Type.prototype.voidType = null;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * Type type.
         * @member {"typeId"|"decimalType"|"optionalType"|"listType"|"tupleType"|"structType"|"dictType"|"variantType"|"voidType"|undefined} type
         * @memberof Ydb.Type
         * @instance
         */
        Object.defineProperty(Type.prototype, "type", {
            get: $util.oneOfGetter($oneOfFields = ["typeId", "decimalType", "optionalType", "listType", "tupleType", "structType", "dictType", "variantType", "voidType"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new Type instance using the specified properties.
         * @function create
         * @memberof Ydb.Type
         * @static
         * @param {Ydb.IType=} [properties] Properties to set
         * @returns {Ydb.Type} Type instance
         */
        Type.create = function create(properties) {
            return new Type(properties);
        };

        /**
         * Encodes the specified Type message. Does not implicitly {@link Ydb.Type.verify|verify} messages.
         * @function encode
         * @memberof Ydb.Type
         * @static
         * @param {Ydb.IType} message Type message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Type.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.typeId != null && Object.hasOwnProperty.call(message, "typeId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.typeId);
            if (message.decimalType != null && Object.hasOwnProperty.call(message, "decimalType"))
                $root.Ydb.DecimalType.encode(message.decimalType, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.optionalType != null && Object.hasOwnProperty.call(message, "optionalType"))
                $root.Ydb.OptionalType.encode(message.optionalType, writer.uint32(/* id 101, wireType 2 =*/810).fork()).ldelim();
            if (message.listType != null && Object.hasOwnProperty.call(message, "listType"))
                $root.Ydb.ListType.encode(message.listType, writer.uint32(/* id 102, wireType 2 =*/818).fork()).ldelim();
            if (message.tupleType != null && Object.hasOwnProperty.call(message, "tupleType"))
                $root.Ydb.TupleType.encode(message.tupleType, writer.uint32(/* id 103, wireType 2 =*/826).fork()).ldelim();
            if (message.structType != null && Object.hasOwnProperty.call(message, "structType"))
                $root.Ydb.StructType.encode(message.structType, writer.uint32(/* id 104, wireType 2 =*/834).fork()).ldelim();
            if (message.dictType != null && Object.hasOwnProperty.call(message, "dictType"))
                $root.Ydb.DictType.encode(message.dictType, writer.uint32(/* id 105, wireType 2 =*/842).fork()).ldelim();
            if (message.variantType != null && Object.hasOwnProperty.call(message, "variantType"))
                $root.Ydb.VariantType.encode(message.variantType, writer.uint32(/* id 106, wireType 2 =*/850).fork()).ldelim();
            if (message.voidType != null && Object.hasOwnProperty.call(message, "voidType"))
                writer.uint32(/* id 201, wireType 0 =*/1608).int32(message.voidType);
            return writer;
        };

        /**
         * Encodes the specified Type message, length delimited. Does not implicitly {@link Ydb.Type.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Ydb.Type
         * @static
         * @param {Ydb.IType} message Type message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Type.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Type message from the specified reader or buffer.
         * @function decode
         * @memberof Ydb.Type
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Ydb.Type} Type
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Type.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Type();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.typeId = reader.int32();
                    break;
                case 2:
                    message.decimalType = $root.Ydb.DecimalType.decode(reader, reader.uint32());
                    break;
                case 101:
                    message.optionalType = $root.Ydb.OptionalType.decode(reader, reader.uint32());
                    break;
                case 102:
                    message.listType = $root.Ydb.ListType.decode(reader, reader.uint32());
                    break;
                case 103:
                    message.tupleType = $root.Ydb.TupleType.decode(reader, reader.uint32());
                    break;
                case 104:
                    message.structType = $root.Ydb.StructType.decode(reader, reader.uint32());
                    break;
                case 105:
                    message.dictType = $root.Ydb.DictType.decode(reader, reader.uint32());
                    break;
                case 106:
                    message.variantType = $root.Ydb.VariantType.decode(reader, reader.uint32());
                    break;
                case 201:
                    message.voidType = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Type message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Ydb.Type
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Ydb.Type} Type
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Type.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Type message.
         * @function verify
         * @memberof Ydb.Type
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Type.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.typeId != null && message.hasOwnProperty("typeId")) {
                properties.type = 1;
                switch (message.typeId) {
                default:
                    return "typeId: enum value expected";
                case 0:
                case 6:
                case 7:
                case 5:
                case 8:
                case 9:
                case 1:
                case 2:
                case 3:
                case 4:
                case 33:
                case 32:
                case 48:
                case 49:
                case 50:
                case 51:
                case 52:
                case 53:
                case 54:
                case 4097:
                case 4608:
                case 4609:
                case 4610:
                case 4611:
                case 4612:
                case 4866:
                    break;
                }
            }
            if (message.decimalType != null && message.hasOwnProperty("decimalType")) {
                if (properties.type === 1)
                    return "type: multiple values";
                properties.type = 1;
                {
                    var error = $root.Ydb.DecimalType.verify(message.decimalType);
                    if (error)
                        return "decimalType." + error;
                }
            }
            if (message.optionalType != null && message.hasOwnProperty("optionalType")) {
                if (properties.type === 1)
                    return "type: multiple values";
                properties.type = 1;
                {
                    var error = $root.Ydb.OptionalType.verify(message.optionalType);
                    if (error)
                        return "optionalType." + error;
                }
            }
            if (message.listType != null && message.hasOwnProperty("listType")) {
                if (properties.type === 1)
                    return "type: multiple values";
                properties.type = 1;
                {
                    var error = $root.Ydb.ListType.verify(message.listType);
                    if (error)
                        return "listType." + error;
                }
            }
            if (message.tupleType != null && message.hasOwnProperty("tupleType")) {
                if (properties.type === 1)
                    return "type: multiple values";
                properties.type = 1;
                {
                    var error = $root.Ydb.TupleType.verify(message.tupleType);
                    if (error)
                        return "tupleType." + error;
                }
            }
            if (message.structType != null && message.hasOwnProperty("structType")) {
                if (properties.type === 1)
                    return "type: multiple values";
                properties.type = 1;
                {
                    var error = $root.Ydb.StructType.verify(message.structType);
                    if (error)
                        return "structType." + error;
                }
            }
            if (message.dictType != null && message.hasOwnProperty("dictType")) {
                if (properties.type === 1)
                    return "type: multiple values";
                properties.type = 1;
                {
                    var error = $root.Ydb.DictType.verify(message.dictType);
                    if (error)
                        return "dictType." + error;
                }
            }
            if (message.variantType != null && message.hasOwnProperty("variantType")) {
                if (properties.type === 1)
                    return "type: multiple values";
                properties.type = 1;
                {
                    var error = $root.Ydb.VariantType.verify(message.variantType);
                    if (error)
                        return "variantType." + error;
                }
            }
            if (message.voidType != null && message.hasOwnProperty("voidType")) {
                if (properties.type === 1)
                    return "type: multiple values";
                properties.type = 1;
                switch (message.voidType) {
                default:
                    return "voidType: enum value expected";
                case 0:
                    break;
                }
            }
            return null;
        };

        /**
         * Creates a Type message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Ydb.Type
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Ydb.Type} Type
         */
        Type.fromObject = function fromObject(object) {
            if (object instanceof $root.Ydb.Type)
                return object;
            var message = new $root.Ydb.Type();
            switch (object.typeId) {
            case "PRIMITIVE_TYPE_ID_UNSPECIFIED":
            case 0:
                message.typeId = 0;
                break;
            case "BOOL":
            case 6:
                message.typeId = 6;
                break;
            case "INT8":
            case 7:
                message.typeId = 7;
                break;
            case "UINT8":
            case 5:
                message.typeId = 5;
                break;
            case "INT16":
            case 8:
                message.typeId = 8;
                break;
            case "UINT16":
            case 9:
                message.typeId = 9;
                break;
            case "INT32":
            case 1:
                message.typeId = 1;
                break;
            case "UINT32":
            case 2:
                message.typeId = 2;
                break;
            case "INT64":
            case 3:
                message.typeId = 3;
                break;
            case "UINT64":
            case 4:
                message.typeId = 4;
                break;
            case "FLOAT":
            case 33:
                message.typeId = 33;
                break;
            case "DOUBLE":
            case 32:
                message.typeId = 32;
                break;
            case "DATE":
            case 48:
                message.typeId = 48;
                break;
            case "DATETIME":
            case 49:
                message.typeId = 49;
                break;
            case "TIMESTAMP":
            case 50:
                message.typeId = 50;
                break;
            case "INTERVAL":
            case 51:
                message.typeId = 51;
                break;
            case "TZ_DATE":
            case 52:
                message.typeId = 52;
                break;
            case "TZ_DATETIME":
            case 53:
                message.typeId = 53;
                break;
            case "TZ_TIMESTAMP":
            case 54:
                message.typeId = 54;
                break;
            case "STRING":
            case 4097:
                message.typeId = 4097;
                break;
            case "UTF8":
            case 4608:
                message.typeId = 4608;
                break;
            case "YSON":
            case 4609:
                message.typeId = 4609;
                break;
            case "JSON":
            case 4610:
                message.typeId = 4610;
                break;
            case "UUID":
            case 4611:
                message.typeId = 4611;
                break;
            case "JSON_DOCUMENT":
            case 4612:
                message.typeId = 4612;
                break;
            case "DYNUMBER":
            case 4866:
                message.typeId = 4866;
                break;
            }
            if (object.decimalType != null) {
                if (typeof object.decimalType !== "object")
                    throw TypeError(".Ydb.Type.decimalType: object expected");
                message.decimalType = $root.Ydb.DecimalType.fromObject(object.decimalType);
            }
            if (object.optionalType != null) {
                if (typeof object.optionalType !== "object")
                    throw TypeError(".Ydb.Type.optionalType: object expected");
                message.optionalType = $root.Ydb.OptionalType.fromObject(object.optionalType);
            }
            if (object.listType != null) {
                if (typeof object.listType !== "object")
                    throw TypeError(".Ydb.Type.listType: object expected");
                message.listType = $root.Ydb.ListType.fromObject(object.listType);
            }
            if (object.tupleType != null) {
                if (typeof object.tupleType !== "object")
                    throw TypeError(".Ydb.Type.tupleType: object expected");
                message.tupleType = $root.Ydb.TupleType.fromObject(object.tupleType);
            }
            if (object.structType != null) {
                if (typeof object.structType !== "object")
                    throw TypeError(".Ydb.Type.structType: object expected");
                message.structType = $root.Ydb.StructType.fromObject(object.structType);
            }
            if (object.dictType != null) {
                if (typeof object.dictType !== "object")
                    throw TypeError(".Ydb.Type.dictType: object expected");
                message.dictType = $root.Ydb.DictType.fromObject(object.dictType);
            }
            if (object.variantType != null) {
                if (typeof object.variantType !== "object")
                    throw TypeError(".Ydb.Type.variantType: object expected");
                message.variantType = $root.Ydb.VariantType.fromObject(object.variantType);
            }
            switch (object.voidType) {
            case "NULL_VALUE":
            case 0:
                message.voidType = 0;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a Type message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Ydb.Type
         * @static
         * @param {Ydb.Type} message Type
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Type.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (message.typeId != null && message.hasOwnProperty("typeId")) {
                object.typeId = options.enums === String ? $root.Ydb.Type.PrimitiveTypeId[message.typeId] : message.typeId;
                if (options.oneofs)
                    object.type = "typeId";
            }
            if (message.decimalType != null && message.hasOwnProperty("decimalType")) {
                object.decimalType = $root.Ydb.DecimalType.toObject(message.decimalType, options);
                if (options.oneofs)
                    object.type = "decimalType";
            }
            if (message.optionalType != null && message.hasOwnProperty("optionalType")) {
                object.optionalType = $root.Ydb.OptionalType.toObject(message.optionalType, options);
                if (options.oneofs)
                    object.type = "optionalType";
            }
            if (message.listType != null && message.hasOwnProperty("listType")) {
                object.listType = $root.Ydb.ListType.toObject(message.listType, options);
                if (options.oneofs)
                    object.type = "listType";
            }
            if (message.tupleType != null && message.hasOwnProperty("tupleType")) {
                object.tupleType = $root.Ydb.TupleType.toObject(message.tupleType, options);
                if (options.oneofs)
                    object.type = "tupleType";
            }
            if (message.structType != null && message.hasOwnProperty("structType")) {
                object.structType = $root.Ydb.StructType.toObject(message.structType, options);
                if (options.oneofs)
                    object.type = "structType";
            }
            if (message.dictType != null && message.hasOwnProperty("dictType")) {
                object.dictType = $root.Ydb.DictType.toObject(message.dictType, options);
                if (options.oneofs)
                    object.type = "dictType";
            }
            if (message.variantType != null && message.hasOwnProperty("variantType")) {
                object.variantType = $root.Ydb.VariantType.toObject(message.variantType, options);
                if (options.oneofs)
                    object.type = "variantType";
            }
            if (message.voidType != null && message.hasOwnProperty("voidType")) {
                object.voidType = options.enums === String ? $root.google.protobuf.NullValue[message.voidType] : message.voidType;
                if (options.oneofs)
                    object.type = "voidType";
            }
            return object;
        };

        /**
         * Converts this Type to JSON.
         * @function toJSON
         * @memberof Ydb.Type
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Type.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * PrimitiveTypeId enum.
         * @name Ydb.Type.PrimitiveTypeId
         * @enum {number}
         * @property {number} PRIMITIVE_TYPE_ID_UNSPECIFIED=0 PRIMITIVE_TYPE_ID_UNSPECIFIED value
         * @property {number} BOOL=6 BOOL value
         * @property {number} INT8=7 INT8 value
         * @property {number} UINT8=5 UINT8 value
         * @property {number} INT16=8 INT16 value
         * @property {number} UINT16=9 UINT16 value
         * @property {number} INT32=1 INT32 value
         * @property {number} UINT32=2 UINT32 value
         * @property {number} INT64=3 INT64 value
         * @property {number} UINT64=4 UINT64 value
         * @property {number} FLOAT=33 FLOAT value
         * @property {number} DOUBLE=32 DOUBLE value
         * @property {number} DATE=48 DATE value
         * @property {number} DATETIME=49 DATETIME value
         * @property {number} TIMESTAMP=50 TIMESTAMP value
         * @property {number} INTERVAL=51 INTERVAL value
         * @property {number} TZ_DATE=52 TZ_DATE value
         * @property {number} TZ_DATETIME=53 TZ_DATETIME value
         * @property {number} TZ_TIMESTAMP=54 TZ_TIMESTAMP value
         * @property {number} STRING=4097 STRING value
         * @property {number} UTF8=4608 UTF8 value
         * @property {number} YSON=4609 YSON value
         * @property {number} JSON=4610 JSON value
         * @property {number} UUID=4611 UUID value
         * @property {number} JSON_DOCUMENT=4612 JSON_DOCUMENT value
         * @property {number} DYNUMBER=4866 DYNUMBER value
         */
        Type.PrimitiveTypeId = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "PRIMITIVE_TYPE_ID_UNSPECIFIED"] = 0;
            values[valuesById[6] = "BOOL"] = 6;
            values[valuesById[7] = "INT8"] = 7;
            values[valuesById[5] = "UINT8"] = 5;
            values[valuesById[8] = "INT16"] = 8;
            values[valuesById[9] = "UINT16"] = 9;
            values[valuesById[1] = "INT32"] = 1;
            values[valuesById[2] = "UINT32"] = 2;
            values[valuesById[3] = "INT64"] = 3;
            values[valuesById[4] = "UINT64"] = 4;
            values[valuesById[33] = "FLOAT"] = 33;
            values[valuesById[32] = "DOUBLE"] = 32;
            values[valuesById[48] = "DATE"] = 48;
            values[valuesById[49] = "DATETIME"] = 49;
            values[valuesById[50] = "TIMESTAMP"] = 50;
            values[valuesById[51] = "INTERVAL"] = 51;
            values[valuesById[52] = "TZ_DATE"] = 52;
            values[valuesById[53] = "TZ_DATETIME"] = 53;
            values[valuesById[54] = "TZ_TIMESTAMP"] = 54;
            values[valuesById[4097] = "STRING"] = 4097;
            values[valuesById[4608] = "UTF8"] = 4608;
            values[valuesById[4609] = "YSON"] = 4609;
            values[valuesById[4610] = "JSON"] = 4610;
            values[valuesById[4611] = "UUID"] = 4611;
            values[valuesById[4612] = "JSON_DOCUMENT"] = 4612;
            values[valuesById[4866] = "DYNUMBER"] = 4866;
            return values;
        })();

        return Type;
    })();

    Ydb.ValuePair = (function() {

        /**
         * Properties of a ValuePair.
         * @memberof Ydb
         * @interface IValuePair
         * @property {Ydb.IValue|null} [key] ValuePair key
         * @property {Ydb.IValue|null} [payload] ValuePair payload
         */

        /**
         * Constructs a new ValuePair.
         * @memberof Ydb
         * @classdesc Represents a ValuePair.
         * @implements IValuePair
         * @constructor
         * @param {Ydb.IValuePair=} [properties] Properties to set
         */
        function ValuePair(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ValuePair key.
         * @member {Ydb.IValue|null|undefined} key
         * @memberof Ydb.ValuePair
         * @instance
         */
        ValuePair.prototype.key = null;

        /**
         * ValuePair payload.
         * @member {Ydb.IValue|null|undefined} payload
         * @memberof Ydb.ValuePair
         * @instance
         */
        ValuePair.prototype.payload = null;

        /**
         * Creates a new ValuePair instance using the specified properties.
         * @function create
         * @memberof Ydb.ValuePair
         * @static
         * @param {Ydb.IValuePair=} [properties] Properties to set
         * @returns {Ydb.ValuePair} ValuePair instance
         */
        ValuePair.create = function create(properties) {
            return new ValuePair(properties);
        };

        /**
         * Encodes the specified ValuePair message. Does not implicitly {@link Ydb.ValuePair.verify|verify} messages.
         * @function encode
         * @memberof Ydb.ValuePair
         * @static
         * @param {Ydb.IValuePair} message ValuePair message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ValuePair.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                $root.Ydb.Value.encode(message.key, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.payload != null && Object.hasOwnProperty.call(message, "payload"))
                $root.Ydb.Value.encode(message.payload, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ValuePair message, length delimited. Does not implicitly {@link Ydb.ValuePair.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Ydb.ValuePair
         * @static
         * @param {Ydb.IValuePair} message ValuePair message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ValuePair.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ValuePair message from the specified reader or buffer.
         * @function decode
         * @memberof Ydb.ValuePair
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Ydb.ValuePair} ValuePair
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ValuePair.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.ValuePair();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.key = $root.Ydb.Value.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.payload = $root.Ydb.Value.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ValuePair message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Ydb.ValuePair
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Ydb.ValuePair} ValuePair
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ValuePair.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ValuePair message.
         * @function verify
         * @memberof Ydb.ValuePair
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ValuePair.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.key != null && message.hasOwnProperty("key")) {
                var error = $root.Ydb.Value.verify(message.key);
                if (error)
                    return "key." + error;
            }
            if (message.payload != null && message.hasOwnProperty("payload")) {
                var error = $root.Ydb.Value.verify(message.payload);
                if (error)
                    return "payload." + error;
            }
            return null;
        };

        /**
         * Creates a ValuePair message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Ydb.ValuePair
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Ydb.ValuePair} ValuePair
         */
        ValuePair.fromObject = function fromObject(object) {
            if (object instanceof $root.Ydb.ValuePair)
                return object;
            var message = new $root.Ydb.ValuePair();
            if (object.key != null) {
                if (typeof object.key !== "object")
                    throw TypeError(".Ydb.ValuePair.key: object expected");
                message.key = $root.Ydb.Value.fromObject(object.key);
            }
            if (object.payload != null) {
                if (typeof object.payload !== "object")
                    throw TypeError(".Ydb.ValuePair.payload: object expected");
                message.payload = $root.Ydb.Value.fromObject(object.payload);
            }
            return message;
        };

        /**
         * Creates a plain object from a ValuePair message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Ydb.ValuePair
         * @static
         * @param {Ydb.ValuePair} message ValuePair
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ValuePair.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.key = null;
                object.payload = null;
            }
            if (message.key != null && message.hasOwnProperty("key"))
                object.key = $root.Ydb.Value.toObject(message.key, options);
            if (message.payload != null && message.hasOwnProperty("payload"))
                object.payload = $root.Ydb.Value.toObject(message.payload, options);
            return object;
        };

        /**
         * Converts this ValuePair to JSON.
         * @function toJSON
         * @memberof Ydb.ValuePair
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ValuePair.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ValuePair;
    })();

    Ydb.Value = (function() {

        /**
         * Properties of a Value.
         * @memberof Ydb
         * @interface IValue
         * @property {boolean|null} [boolValue] Value boolValue
         * @property {number|null} [int32Value] Value int32Value
         * @property {number|null} [uint32Value] Value uint32Value
         * @property {number|Long|null} [int64Value] Value int64Value
         * @property {number|Long|null} [uint64Value] Value uint64Value
         * @property {number|null} [floatValue] Value floatValue
         * @property {number|null} [doubleValue] Value doubleValue
         * @property {Uint8Array|null} [bytesValue] Value bytesValue
         * @property {string|null} [textValue] Value textValue
         * @property {google.protobuf.NullValue|null} [nullFlagValue] Value nullFlagValue
         * @property {Ydb.IValue|null} [nestedValue] Value nestedValue
         * @property {number|Long|null} [low_128] Value low_128
         * @property {Array.<Ydb.IValue>|null} [items] Value items
         * @property {Array.<Ydb.IValuePair>|null} [pairs] Value pairs
         * @property {number|null} [variantIndex] Value variantIndex
         * @property {number|Long|null} [high_128] Value high_128
         */

        /**
         * Constructs a new Value.
         * @memberof Ydb
         * @classdesc Represents a Value.
         * @implements IValue
         * @constructor
         * @param {Ydb.IValue=} [properties] Properties to set
         */
        function Value(properties) {
            this.items = [];
            this.pairs = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Value boolValue.
         * @member {boolean|null|undefined} boolValue
         * @memberof Ydb.Value
         * @instance
         */
        Value.prototype.boolValue = null;

        /**
         * Value int32Value.
         * @member {number|null|undefined} int32Value
         * @memberof Ydb.Value
         * @instance
         */
        Value.prototype.int32Value = null;

        /**
         * Value uint32Value.
         * @member {number|null|undefined} uint32Value
         * @memberof Ydb.Value
         * @instance
         */
        Value.prototype.uint32Value = null;

        /**
         * Value int64Value.
         * @member {number|Long|null|undefined} int64Value
         * @memberof Ydb.Value
         * @instance
         */
        Value.prototype.int64Value = null;

        /**
         * Value uint64Value.
         * @member {number|Long|null|undefined} uint64Value
         * @memberof Ydb.Value
         * @instance
         */
        Value.prototype.uint64Value = null;

        /**
         * Value floatValue.
         * @member {number|null|undefined} floatValue
         * @memberof Ydb.Value
         * @instance
         */
        Value.prototype.floatValue = null;

        /**
         * Value doubleValue.
         * @member {number|null|undefined} doubleValue
         * @memberof Ydb.Value
         * @instance
         */
        Value.prototype.doubleValue = null;

        /**
         * Value bytesValue.
         * @member {Uint8Array|null|undefined} bytesValue
         * @memberof Ydb.Value
         * @instance
         */
        Value.prototype.bytesValue = null;

        /**
         * Value textValue.
         * @member {string|null|undefined} textValue
         * @memberof Ydb.Value
         * @instance
         */
        Value.prototype.textValue = null;

        /**
         * Value nullFlagValue.
         * @member {google.protobuf.NullValue|null|undefined} nullFlagValue
         * @memberof Ydb.Value
         * @instance
         */
        Value.prototype.nullFlagValue = null;

        /**
         * Value nestedValue.
         * @member {Ydb.IValue|null|undefined} nestedValue
         * @memberof Ydb.Value
         * @instance
         */
        Value.prototype.nestedValue = null;

        /**
         * Value low_128.
         * @member {number|Long|null|undefined} low_128
         * @memberof Ydb.Value
         * @instance
         */
        Value.prototype.low_128 = null;

        /**
         * Value items.
         * @member {Array.<Ydb.IValue>} items
         * @memberof Ydb.Value
         * @instance
         */
        Value.prototype.items = $util.emptyArray;

        /**
         * Value pairs.
         * @member {Array.<Ydb.IValuePair>} pairs
         * @memberof Ydb.Value
         * @instance
         */
        Value.prototype.pairs = $util.emptyArray;

        /**
         * Value variantIndex.
         * @member {number} variantIndex
         * @memberof Ydb.Value
         * @instance
         */
        Value.prototype.variantIndex = 0;

        /**
         * Value high_128.
         * @member {number|Long} high_128
         * @memberof Ydb.Value
         * @instance
         */
        Value.prototype.high_128 = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * Value value.
         * @member {"boolValue"|"int32Value"|"uint32Value"|"int64Value"|"uint64Value"|"floatValue"|"doubleValue"|"bytesValue"|"textValue"|"nullFlagValue"|"nestedValue"|"low_128"|undefined} value
         * @memberof Ydb.Value
         * @instance
         */
        Object.defineProperty(Value.prototype, "value", {
            get: $util.oneOfGetter($oneOfFields = ["boolValue", "int32Value", "uint32Value", "int64Value", "uint64Value", "floatValue", "doubleValue", "bytesValue", "textValue", "nullFlagValue", "nestedValue", "low_128"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new Value instance using the specified properties.
         * @function create
         * @memberof Ydb.Value
         * @static
         * @param {Ydb.IValue=} [properties] Properties to set
         * @returns {Ydb.Value} Value instance
         */
        Value.create = function create(properties) {
            return new Value(properties);
        };

        /**
         * Encodes the specified Value message. Does not implicitly {@link Ydb.Value.verify|verify} messages.
         * @function encode
         * @memberof Ydb.Value
         * @static
         * @param {Ydb.IValue} message Value message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Value.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.boolValue != null && Object.hasOwnProperty.call(message, "boolValue"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.boolValue);
            if (message.int32Value != null && Object.hasOwnProperty.call(message, "int32Value"))
                writer.uint32(/* id 2, wireType 5 =*/21).sfixed32(message.int32Value);
            if (message.uint32Value != null && Object.hasOwnProperty.call(message, "uint32Value"))
                writer.uint32(/* id 3, wireType 5 =*/29).fixed32(message.uint32Value);
            if (message.int64Value != null && Object.hasOwnProperty.call(message, "int64Value"))
                writer.uint32(/* id 4, wireType 1 =*/33).sfixed64(message.int64Value);
            if (message.uint64Value != null && Object.hasOwnProperty.call(message, "uint64Value"))
                writer.uint32(/* id 5, wireType 1 =*/41).fixed64(message.uint64Value);
            if (message.floatValue != null && Object.hasOwnProperty.call(message, "floatValue"))
                writer.uint32(/* id 6, wireType 5 =*/53).float(message.floatValue);
            if (message.doubleValue != null && Object.hasOwnProperty.call(message, "doubleValue"))
                writer.uint32(/* id 7, wireType 1 =*/57).double(message.doubleValue);
            if (message.bytesValue != null && Object.hasOwnProperty.call(message, "bytesValue"))
                writer.uint32(/* id 8, wireType 2 =*/66).bytes(message.bytesValue);
            if (message.textValue != null && Object.hasOwnProperty.call(message, "textValue"))
                writer.uint32(/* id 9, wireType 2 =*/74).string(message.textValue);
            if (message.nullFlagValue != null && Object.hasOwnProperty.call(message, "nullFlagValue"))
                writer.uint32(/* id 10, wireType 0 =*/80).int32(message.nullFlagValue);
            if (message.nestedValue != null && Object.hasOwnProperty.call(message, "nestedValue"))
                $root.Ydb.Value.encode(message.nestedValue, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
            if (message.items != null && message.items.length)
                for (var i = 0; i < message.items.length; ++i)
                    $root.Ydb.Value.encode(message.items[i], writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
            if (message.pairs != null && message.pairs.length)
                for (var i = 0; i < message.pairs.length; ++i)
                    $root.Ydb.ValuePair.encode(message.pairs[i], writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
            if (message.variantIndex != null && Object.hasOwnProperty.call(message, "variantIndex"))
                writer.uint32(/* id 14, wireType 0 =*/112).uint32(message.variantIndex);
            if (message.low_128 != null && Object.hasOwnProperty.call(message, "low_128"))
                writer.uint32(/* id 15, wireType 1 =*/121).fixed64(message.low_128);
            if (message.high_128 != null && Object.hasOwnProperty.call(message, "high_128"))
                writer.uint32(/* id 16, wireType 1 =*/129).fixed64(message.high_128);
            return writer;
        };

        /**
         * Encodes the specified Value message, length delimited. Does not implicitly {@link Ydb.Value.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Ydb.Value
         * @static
         * @param {Ydb.IValue} message Value message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Value.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Value message from the specified reader or buffer.
         * @function decode
         * @memberof Ydb.Value
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Ydb.Value} Value
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Value.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Value();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.boolValue = reader.bool();
                    break;
                case 2:
                    message.int32Value = reader.sfixed32();
                    break;
                case 3:
                    message.uint32Value = reader.fixed32();
                    break;
                case 4:
                    message.int64Value = reader.sfixed64();
                    break;
                case 5:
                    message.uint64Value = reader.fixed64();
                    break;
                case 6:
                    message.floatValue = reader.float();
                    break;
                case 7:
                    message.doubleValue = reader.double();
                    break;
                case 8:
                    message.bytesValue = reader.bytes();
                    break;
                case 9:
                    message.textValue = reader.string();
                    break;
                case 10:
                    message.nullFlagValue = reader.int32();
                    break;
                case 11:
                    message.nestedValue = $root.Ydb.Value.decode(reader, reader.uint32());
                    break;
                case 15:
                    message.low_128 = reader.fixed64();
                    break;
                case 12:
                    if (!(message.items && message.items.length))
                        message.items = [];
                    message.items.push($root.Ydb.Value.decode(reader, reader.uint32()));
                    break;
                case 13:
                    if (!(message.pairs && message.pairs.length))
                        message.pairs = [];
                    message.pairs.push($root.Ydb.ValuePair.decode(reader, reader.uint32()));
                    break;
                case 14:
                    message.variantIndex = reader.uint32();
                    break;
                case 16:
                    message.high_128 = reader.fixed64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Value message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Ydb.Value
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Ydb.Value} Value
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Value.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Value message.
         * @function verify
         * @memberof Ydb.Value
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Value.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.boolValue != null && message.hasOwnProperty("boolValue")) {
                properties.value = 1;
                if (typeof message.boolValue !== "boolean")
                    return "boolValue: boolean expected";
            }
            if (message.int32Value != null && message.hasOwnProperty("int32Value")) {
                if (properties.value === 1)
                    return "value: multiple values";
                properties.value = 1;
                if (!$util.isInteger(message.int32Value))
                    return "int32Value: integer expected";
            }
            if (message.uint32Value != null && message.hasOwnProperty("uint32Value")) {
                if (properties.value === 1)
                    return "value: multiple values";
                properties.value = 1;
                if (!$util.isInteger(message.uint32Value))
                    return "uint32Value: integer expected";
            }
            if (message.int64Value != null && message.hasOwnProperty("int64Value")) {
                if (properties.value === 1)
                    return "value: multiple values";
                properties.value = 1;
                if (!$util.isInteger(message.int64Value) && !(message.int64Value && $util.isInteger(message.int64Value.low) && $util.isInteger(message.int64Value.high)))
                    return "int64Value: integer|Long expected";
            }
            if (message.uint64Value != null && message.hasOwnProperty("uint64Value")) {
                if (properties.value === 1)
                    return "value: multiple values";
                properties.value = 1;
                if (!$util.isInteger(message.uint64Value) && !(message.uint64Value && $util.isInteger(message.uint64Value.low) && $util.isInteger(message.uint64Value.high)))
                    return "uint64Value: integer|Long expected";
            }
            if (message.floatValue != null && message.hasOwnProperty("floatValue")) {
                if (properties.value === 1)
                    return "value: multiple values";
                properties.value = 1;
                if (typeof message.floatValue !== "number")
                    return "floatValue: number expected";
            }
            if (message.doubleValue != null && message.hasOwnProperty("doubleValue")) {
                if (properties.value === 1)
                    return "value: multiple values";
                properties.value = 1;
                if (typeof message.doubleValue !== "number")
                    return "doubleValue: number expected";
            }
            if (message.bytesValue != null && message.hasOwnProperty("bytesValue")) {
                if (properties.value === 1)
                    return "value: multiple values";
                properties.value = 1;
                if (!(message.bytesValue && typeof message.bytesValue.length === "number" || $util.isString(message.bytesValue)))
                    return "bytesValue: buffer expected";
            }
            if (message.textValue != null && message.hasOwnProperty("textValue")) {
                if (properties.value === 1)
                    return "value: multiple values";
                properties.value = 1;
                if (!$util.isString(message.textValue))
                    return "textValue: string expected";
            }
            if (message.nullFlagValue != null && message.hasOwnProperty("nullFlagValue")) {
                if (properties.value === 1)
                    return "value: multiple values";
                properties.value = 1;
                switch (message.nullFlagValue) {
                default:
                    return "nullFlagValue: enum value expected";
                case 0:
                    break;
                }
            }
            if (message.nestedValue != null && message.hasOwnProperty("nestedValue")) {
                if (properties.value === 1)
                    return "value: multiple values";
                properties.value = 1;
                {
                    var error = $root.Ydb.Value.verify(message.nestedValue);
                    if (error)
                        return "nestedValue." + error;
                }
            }
            if (message.low_128 != null && message.hasOwnProperty("low_128")) {
                if (properties.value === 1)
                    return "value: multiple values";
                properties.value = 1;
                if (!$util.isInteger(message.low_128) && !(message.low_128 && $util.isInteger(message.low_128.low) && $util.isInteger(message.low_128.high)))
                    return "low_128: integer|Long expected";
            }
            if (message.items != null && message.hasOwnProperty("items")) {
                if (!Array.isArray(message.items))
                    return "items: array expected";
                for (var i = 0; i < message.items.length; ++i) {
                    var error = $root.Ydb.Value.verify(message.items[i]);
                    if (error)
                        return "items." + error;
                }
            }
            if (message.pairs != null && message.hasOwnProperty("pairs")) {
                if (!Array.isArray(message.pairs))
                    return "pairs: array expected";
                for (var i = 0; i < message.pairs.length; ++i) {
                    var error = $root.Ydb.ValuePair.verify(message.pairs[i]);
                    if (error)
                        return "pairs." + error;
                }
            }
            if (message.variantIndex != null && message.hasOwnProperty("variantIndex"))
                if (!$util.isInteger(message.variantIndex))
                    return "variantIndex: integer expected";
            if (message.high_128 != null && message.hasOwnProperty("high_128"))
                if (!$util.isInteger(message.high_128) && !(message.high_128 && $util.isInteger(message.high_128.low) && $util.isInteger(message.high_128.high)))
                    return "high_128: integer|Long expected";
            return null;
        };

        /**
         * Creates a Value message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Ydb.Value
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Ydb.Value} Value
         */
        Value.fromObject = function fromObject(object) {
            if (object instanceof $root.Ydb.Value)
                return object;
            var message = new $root.Ydb.Value();
            if (object.boolValue != null)
                message.boolValue = Boolean(object.boolValue);
            if (object.int32Value != null)
                message.int32Value = object.int32Value | 0;
            if (object.uint32Value != null)
                message.uint32Value = object.uint32Value >>> 0;
            if (object.int64Value != null)
                if ($util.Long)
                    (message.int64Value = $util.Long.fromValue(object.int64Value)).unsigned = false;
                else if (typeof object.int64Value === "string")
                    message.int64Value = parseInt(object.int64Value, 10);
                else if (typeof object.int64Value === "number")
                    message.int64Value = object.int64Value;
                else if (typeof object.int64Value === "object")
                    message.int64Value = new $util.LongBits(object.int64Value.low >>> 0, object.int64Value.high >>> 0).toNumber();
            if (object.uint64Value != null)
                if ($util.Long)
                    (message.uint64Value = $util.Long.fromValue(object.uint64Value)).unsigned = false;
                else if (typeof object.uint64Value === "string")
                    message.uint64Value = parseInt(object.uint64Value, 10);
                else if (typeof object.uint64Value === "number")
                    message.uint64Value = object.uint64Value;
                else if (typeof object.uint64Value === "object")
                    message.uint64Value = new $util.LongBits(object.uint64Value.low >>> 0, object.uint64Value.high >>> 0).toNumber();
            if (object.floatValue != null)
                message.floatValue = Number(object.floatValue);
            if (object.doubleValue != null)
                message.doubleValue = Number(object.doubleValue);
            if (object.bytesValue != null)
                if (typeof object.bytesValue === "string")
                    $util.base64.decode(object.bytesValue, message.bytesValue = $util.newBuffer($util.base64.length(object.bytesValue)), 0);
                else if (object.bytesValue.length)
                    message.bytesValue = object.bytesValue;
            if (object.textValue != null)
                message.textValue = String(object.textValue);
            switch (object.nullFlagValue) {
            case "NULL_VALUE":
            case 0:
                message.nullFlagValue = 0;
                break;
            }
            if (object.nestedValue != null) {
                if (typeof object.nestedValue !== "object")
                    throw TypeError(".Ydb.Value.nestedValue: object expected");
                message.nestedValue = $root.Ydb.Value.fromObject(object.nestedValue);
            }
            if (object.low_128 != null)
                if ($util.Long)
                    (message.low_128 = $util.Long.fromValue(object.low_128)).unsigned = false;
                else if (typeof object.low_128 === "string")
                    message.low_128 = parseInt(object.low_128, 10);
                else if (typeof object.low_128 === "number")
                    message.low_128 = object.low_128;
                else if (typeof object.low_128 === "object")
                    message.low_128 = new $util.LongBits(object.low_128.low >>> 0, object.low_128.high >>> 0).toNumber();
            if (object.items) {
                if (!Array.isArray(object.items))
                    throw TypeError(".Ydb.Value.items: array expected");
                message.items = [];
                for (var i = 0; i < object.items.length; ++i) {
                    if (typeof object.items[i] !== "object")
                        throw TypeError(".Ydb.Value.items: object expected");
                    message.items[i] = $root.Ydb.Value.fromObject(object.items[i]);
                }
            }
            if (object.pairs) {
                if (!Array.isArray(object.pairs))
                    throw TypeError(".Ydb.Value.pairs: array expected");
                message.pairs = [];
                for (var i = 0; i < object.pairs.length; ++i) {
                    if (typeof object.pairs[i] !== "object")
                        throw TypeError(".Ydb.Value.pairs: object expected");
                    message.pairs[i] = $root.Ydb.ValuePair.fromObject(object.pairs[i]);
                }
            }
            if (object.variantIndex != null)
                message.variantIndex = object.variantIndex >>> 0;
            if (object.high_128 != null)
                if ($util.Long)
                    (message.high_128 = $util.Long.fromValue(object.high_128)).unsigned = false;
                else if (typeof object.high_128 === "string")
                    message.high_128 = parseInt(object.high_128, 10);
                else if (typeof object.high_128 === "number")
                    message.high_128 = object.high_128;
                else if (typeof object.high_128 === "object")
                    message.high_128 = new $util.LongBits(object.high_128.low >>> 0, object.high_128.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a Value message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Ydb.Value
         * @static
         * @param {Ydb.Value} message Value
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Value.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.items = [];
                object.pairs = [];
            }
            if (options.defaults) {
                object.variantIndex = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.high_128 = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.high_128 = options.longs === String ? "0" : 0;
            }
            if (message.boolValue != null && message.hasOwnProperty("boolValue")) {
                object.boolValue = message.boolValue;
                if (options.oneofs)
                    object.value = "boolValue";
            }
            if (message.int32Value != null && message.hasOwnProperty("int32Value")) {
                object.int32Value = message.int32Value;
                if (options.oneofs)
                    object.value = "int32Value";
            }
            if (message.uint32Value != null && message.hasOwnProperty("uint32Value")) {
                object.uint32Value = message.uint32Value;
                if (options.oneofs)
                    object.value = "uint32Value";
            }
            if (message.int64Value != null && message.hasOwnProperty("int64Value")) {
                if (typeof message.int64Value === "number")
                    object.int64Value = options.longs === String ? String(message.int64Value) : message.int64Value;
                else
                    object.int64Value = options.longs === String ? $util.Long.prototype.toString.call(message.int64Value) : options.longs === Number ? new $util.LongBits(message.int64Value.low >>> 0, message.int64Value.high >>> 0).toNumber() : message.int64Value;
                if (options.oneofs)
                    object.value = "int64Value";
            }
            if (message.uint64Value != null && message.hasOwnProperty("uint64Value")) {
                if (typeof message.uint64Value === "number")
                    object.uint64Value = options.longs === String ? String(message.uint64Value) : message.uint64Value;
                else
                    object.uint64Value = options.longs === String ? $util.Long.prototype.toString.call(message.uint64Value) : options.longs === Number ? new $util.LongBits(message.uint64Value.low >>> 0, message.uint64Value.high >>> 0).toNumber() : message.uint64Value;
                if (options.oneofs)
                    object.value = "uint64Value";
            }
            if (message.floatValue != null && message.hasOwnProperty("floatValue")) {
                object.floatValue = options.json && !isFinite(message.floatValue) ? String(message.floatValue) : message.floatValue;
                if (options.oneofs)
                    object.value = "floatValue";
            }
            if (message.doubleValue != null && message.hasOwnProperty("doubleValue")) {
                object.doubleValue = options.json && !isFinite(message.doubleValue) ? String(message.doubleValue) : message.doubleValue;
                if (options.oneofs)
                    object.value = "doubleValue";
            }
            if (message.bytesValue != null && message.hasOwnProperty("bytesValue")) {
                object.bytesValue = options.bytes === String ? $util.base64.encode(message.bytesValue, 0, message.bytesValue.length) : options.bytes === Array ? Array.prototype.slice.call(message.bytesValue) : message.bytesValue;
                if (options.oneofs)
                    object.value = "bytesValue";
            }
            if (message.textValue != null && message.hasOwnProperty("textValue")) {
                object.textValue = message.textValue;
                if (options.oneofs)
                    object.value = "textValue";
            }
            if (message.nullFlagValue != null && message.hasOwnProperty("nullFlagValue")) {
                object.nullFlagValue = options.enums === String ? $root.google.protobuf.NullValue[message.nullFlagValue] : message.nullFlagValue;
                if (options.oneofs)
                    object.value = "nullFlagValue";
            }
            if (message.nestedValue != null && message.hasOwnProperty("nestedValue")) {
                object.nestedValue = $root.Ydb.Value.toObject(message.nestedValue, options);
                if (options.oneofs)
                    object.value = "nestedValue";
            }
            if (message.items && message.items.length) {
                object.items = [];
                for (var j = 0; j < message.items.length; ++j)
                    object.items[j] = $root.Ydb.Value.toObject(message.items[j], options);
            }
            if (message.pairs && message.pairs.length) {
                object.pairs = [];
                for (var j = 0; j < message.pairs.length; ++j)
                    object.pairs[j] = $root.Ydb.ValuePair.toObject(message.pairs[j], options);
            }
            if (message.variantIndex != null && message.hasOwnProperty("variantIndex"))
                object.variantIndex = message.variantIndex;
            if (message.low_128 != null && message.hasOwnProperty("low_128")) {
                if (typeof message.low_128 === "number")
                    object.low_128 = options.longs === String ? String(message.low_128) : message.low_128;
                else
                    object.low_128 = options.longs === String ? $util.Long.prototype.toString.call(message.low_128) : options.longs === Number ? new $util.LongBits(message.low_128.low >>> 0, message.low_128.high >>> 0).toNumber() : message.low_128;
                if (options.oneofs)
                    object.value = "low_128";
            }
            if (message.high_128 != null && message.hasOwnProperty("high_128"))
                if (typeof message.high_128 === "number")
                    object.high_128 = options.longs === String ? String(message.high_128) : message.high_128;
                else
                    object.high_128 = options.longs === String ? $util.Long.prototype.toString.call(message.high_128) : options.longs === Number ? new $util.LongBits(message.high_128.low >>> 0, message.high_128.high >>> 0).toNumber() : message.high_128;
            return object;
        };

        /**
         * Converts this Value to JSON.
         * @function toJSON
         * @memberof Ydb.Value
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Value.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Value;
    })();

    Ydb.TypedValue = (function() {

        /**
         * Properties of a TypedValue.
         * @memberof Ydb
         * @interface ITypedValue
         * @property {Ydb.IType|null} [type] TypedValue type
         * @property {Ydb.IValue|null} [value] TypedValue value
         */

        /**
         * Constructs a new TypedValue.
         * @memberof Ydb
         * @classdesc Represents a TypedValue.
         * @implements ITypedValue
         * @constructor
         * @param {Ydb.ITypedValue=} [properties] Properties to set
         */
        function TypedValue(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TypedValue type.
         * @member {Ydb.IType|null|undefined} type
         * @memberof Ydb.TypedValue
         * @instance
         */
        TypedValue.prototype.type = null;

        /**
         * TypedValue value.
         * @member {Ydb.IValue|null|undefined} value
         * @memberof Ydb.TypedValue
         * @instance
         */
        TypedValue.prototype.value = null;

        /**
         * Creates a new TypedValue instance using the specified properties.
         * @function create
         * @memberof Ydb.TypedValue
         * @static
         * @param {Ydb.ITypedValue=} [properties] Properties to set
         * @returns {Ydb.TypedValue} TypedValue instance
         */
        TypedValue.create = function create(properties) {
            return new TypedValue(properties);
        };

        /**
         * Encodes the specified TypedValue message. Does not implicitly {@link Ydb.TypedValue.verify|verify} messages.
         * @function encode
         * @memberof Ydb.TypedValue
         * @static
         * @param {Ydb.ITypedValue} message TypedValue message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TypedValue.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                $root.Ydb.Type.encode(message.type, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                $root.Ydb.Value.encode(message.value, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified TypedValue message, length delimited. Does not implicitly {@link Ydb.TypedValue.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Ydb.TypedValue
         * @static
         * @param {Ydb.ITypedValue} message TypedValue message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TypedValue.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TypedValue message from the specified reader or buffer.
         * @function decode
         * @memberof Ydb.TypedValue
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Ydb.TypedValue} TypedValue
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TypedValue.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.TypedValue();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = $root.Ydb.Type.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.value = $root.Ydb.Value.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TypedValue message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Ydb.TypedValue
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Ydb.TypedValue} TypedValue
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TypedValue.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TypedValue message.
         * @function verify
         * @memberof Ydb.TypedValue
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TypedValue.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type")) {
                var error = $root.Ydb.Type.verify(message.type);
                if (error)
                    return "type." + error;
            }
            if (message.value != null && message.hasOwnProperty("value")) {
                var error = $root.Ydb.Value.verify(message.value);
                if (error)
                    return "value." + error;
            }
            return null;
        };

        /**
         * Creates a TypedValue message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Ydb.TypedValue
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Ydb.TypedValue} TypedValue
         */
        TypedValue.fromObject = function fromObject(object) {
            if (object instanceof $root.Ydb.TypedValue)
                return object;
            var message = new $root.Ydb.TypedValue();
            if (object.type != null) {
                if (typeof object.type !== "object")
                    throw TypeError(".Ydb.TypedValue.type: object expected");
                message.type = $root.Ydb.Type.fromObject(object.type);
            }
            if (object.value != null) {
                if (typeof object.value !== "object")
                    throw TypeError(".Ydb.TypedValue.value: object expected");
                message.value = $root.Ydb.Value.fromObject(object.value);
            }
            return message;
        };

        /**
         * Creates a plain object from a TypedValue message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Ydb.TypedValue
         * @static
         * @param {Ydb.TypedValue} message TypedValue
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TypedValue.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.type = null;
                object.value = null;
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = $root.Ydb.Type.toObject(message.type, options);
            if (message.value != null && message.hasOwnProperty("value"))
                object.value = $root.Ydb.Value.toObject(message.value, options);
            return object;
        };

        /**
         * Converts this TypedValue to JSON.
         * @function toJSON
         * @memberof Ydb.TypedValue
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TypedValue.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TypedValue;
    })();

    Ydb.Column = (function() {

        /**
         * Properties of a Column.
         * @memberof Ydb
         * @interface IColumn
         * @property {string|null} [name] Column name
         * @property {Ydb.IType|null} [type] Column type
         */

        /**
         * Constructs a new Column.
         * @memberof Ydb
         * @classdesc Represents a Column.
         * @implements IColumn
         * @constructor
         * @param {Ydb.IColumn=} [properties] Properties to set
         */
        function Column(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Column name.
         * @member {string} name
         * @memberof Ydb.Column
         * @instance
         */
        Column.prototype.name = "";

        /**
         * Column type.
         * @member {Ydb.IType|null|undefined} type
         * @memberof Ydb.Column
         * @instance
         */
        Column.prototype.type = null;

        /**
         * Creates a new Column instance using the specified properties.
         * @function create
         * @memberof Ydb.Column
         * @static
         * @param {Ydb.IColumn=} [properties] Properties to set
         * @returns {Ydb.Column} Column instance
         */
        Column.create = function create(properties) {
            return new Column(properties);
        };

        /**
         * Encodes the specified Column message. Does not implicitly {@link Ydb.Column.verify|verify} messages.
         * @function encode
         * @memberof Ydb.Column
         * @static
         * @param {Ydb.IColumn} message Column message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Column.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                $root.Ydb.Type.encode(message.type, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Column message, length delimited. Does not implicitly {@link Ydb.Column.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Ydb.Column
         * @static
         * @param {Ydb.IColumn} message Column message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Column.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Column message from the specified reader or buffer.
         * @function decode
         * @memberof Ydb.Column
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Ydb.Column} Column
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Column.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Column();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                case 2:
                    message.type = $root.Ydb.Type.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Column message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Ydb.Column
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Ydb.Column} Column
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Column.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Column message.
         * @function verify
         * @memberof Ydb.Column
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Column.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.type != null && message.hasOwnProperty("type")) {
                var error = $root.Ydb.Type.verify(message.type);
                if (error)
                    return "type." + error;
            }
            return null;
        };

        /**
         * Creates a Column message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Ydb.Column
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Ydb.Column} Column
         */
        Column.fromObject = function fromObject(object) {
            if (object instanceof $root.Ydb.Column)
                return object;
            var message = new $root.Ydb.Column();
            if (object.name != null)
                message.name = String(object.name);
            if (object.type != null) {
                if (typeof object.type !== "object")
                    throw TypeError(".Ydb.Column.type: object expected");
                message.type = $root.Ydb.Type.fromObject(object.type);
            }
            return message;
        };

        /**
         * Creates a plain object from a Column message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Ydb.Column
         * @static
         * @param {Ydb.Column} message Column
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Column.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.name = "";
                object.type = null;
            }
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = $root.Ydb.Type.toObject(message.type, options);
            return object;
        };

        /**
         * Converts this Column to JSON.
         * @function toJSON
         * @memberof Ydb.Column
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Column.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Column;
    })();

    Ydb.ResultSet = (function() {

        /**
         * Properties of a ResultSet.
         * @memberof Ydb
         * @interface IResultSet
         * @property {Array.<Ydb.IColumn>|null} [columns] ResultSet columns
         * @property {Array.<Ydb.IValue>|null} [rows] ResultSet rows
         * @property {boolean|null} [truncated] ResultSet truncated
         */

        /**
         * Constructs a new ResultSet.
         * @memberof Ydb
         * @classdesc Represents a ResultSet.
         * @implements IResultSet
         * @constructor
         * @param {Ydb.IResultSet=} [properties] Properties to set
         */
        function ResultSet(properties) {
            this.columns = [];
            this.rows = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ResultSet columns.
         * @member {Array.<Ydb.IColumn>} columns
         * @memberof Ydb.ResultSet
         * @instance
         */
        ResultSet.prototype.columns = $util.emptyArray;

        /**
         * ResultSet rows.
         * @member {Array.<Ydb.IValue>} rows
         * @memberof Ydb.ResultSet
         * @instance
         */
        ResultSet.prototype.rows = $util.emptyArray;

        /**
         * ResultSet truncated.
         * @member {boolean} truncated
         * @memberof Ydb.ResultSet
         * @instance
         */
        ResultSet.prototype.truncated = false;

        /**
         * Creates a new ResultSet instance using the specified properties.
         * @function create
         * @memberof Ydb.ResultSet
         * @static
         * @param {Ydb.IResultSet=} [properties] Properties to set
         * @returns {Ydb.ResultSet} ResultSet instance
         */
        ResultSet.create = function create(properties) {
            return new ResultSet(properties);
        };

        /**
         * Encodes the specified ResultSet message. Does not implicitly {@link Ydb.ResultSet.verify|verify} messages.
         * @function encode
         * @memberof Ydb.ResultSet
         * @static
         * @param {Ydb.IResultSet} message ResultSet message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResultSet.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.columns != null && message.columns.length)
                for (var i = 0; i < message.columns.length; ++i)
                    $root.Ydb.Column.encode(message.columns[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.rows != null && message.rows.length)
                for (var i = 0; i < message.rows.length; ++i)
                    $root.Ydb.Value.encode(message.rows[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.truncated != null && Object.hasOwnProperty.call(message, "truncated"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.truncated);
            return writer;
        };

        /**
         * Encodes the specified ResultSet message, length delimited. Does not implicitly {@link Ydb.ResultSet.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Ydb.ResultSet
         * @static
         * @param {Ydb.IResultSet} message ResultSet message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResultSet.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ResultSet message from the specified reader or buffer.
         * @function decode
         * @memberof Ydb.ResultSet
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Ydb.ResultSet} ResultSet
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResultSet.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.ResultSet();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.columns && message.columns.length))
                        message.columns = [];
                    message.columns.push($root.Ydb.Column.decode(reader, reader.uint32()));
                    break;
                case 2:
                    if (!(message.rows && message.rows.length))
                        message.rows = [];
                    message.rows.push($root.Ydb.Value.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.truncated = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ResultSet message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Ydb.ResultSet
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Ydb.ResultSet} ResultSet
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResultSet.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ResultSet message.
         * @function verify
         * @memberof Ydb.ResultSet
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ResultSet.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.columns != null && message.hasOwnProperty("columns")) {
                if (!Array.isArray(message.columns))
                    return "columns: array expected";
                for (var i = 0; i < message.columns.length; ++i) {
                    var error = $root.Ydb.Column.verify(message.columns[i]);
                    if (error)
                        return "columns." + error;
                }
            }
            if (message.rows != null && message.hasOwnProperty("rows")) {
                if (!Array.isArray(message.rows))
                    return "rows: array expected";
                for (var i = 0; i < message.rows.length; ++i) {
                    var error = $root.Ydb.Value.verify(message.rows[i]);
                    if (error)
                        return "rows." + error;
                }
            }
            if (message.truncated != null && message.hasOwnProperty("truncated"))
                if (typeof message.truncated !== "boolean")
                    return "truncated: boolean expected";
            return null;
        };

        /**
         * Creates a ResultSet message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Ydb.ResultSet
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Ydb.ResultSet} ResultSet
         */
        ResultSet.fromObject = function fromObject(object) {
            if (object instanceof $root.Ydb.ResultSet)
                return object;
            var message = new $root.Ydb.ResultSet();
            if (object.columns) {
                if (!Array.isArray(object.columns))
                    throw TypeError(".Ydb.ResultSet.columns: array expected");
                message.columns = [];
                for (var i = 0; i < object.columns.length; ++i) {
                    if (typeof object.columns[i] !== "object")
                        throw TypeError(".Ydb.ResultSet.columns: object expected");
                    message.columns[i] = $root.Ydb.Column.fromObject(object.columns[i]);
                }
            }
            if (object.rows) {
                if (!Array.isArray(object.rows))
                    throw TypeError(".Ydb.ResultSet.rows: array expected");
                message.rows = [];
                for (var i = 0; i < object.rows.length; ++i) {
                    if (typeof object.rows[i] !== "object")
                        throw TypeError(".Ydb.ResultSet.rows: object expected");
                    message.rows[i] = $root.Ydb.Value.fromObject(object.rows[i]);
                }
            }
            if (object.truncated != null)
                message.truncated = Boolean(object.truncated);
            return message;
        };

        /**
         * Creates a plain object from a ResultSet message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Ydb.ResultSet
         * @static
         * @param {Ydb.ResultSet} message ResultSet
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ResultSet.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.columns = [];
                object.rows = [];
            }
            if (options.defaults)
                object.truncated = false;
            if (message.columns && message.columns.length) {
                object.columns = [];
                for (var j = 0; j < message.columns.length; ++j)
                    object.columns[j] = $root.Ydb.Column.toObject(message.columns[j], options);
            }
            if (message.rows && message.rows.length) {
                object.rows = [];
                for (var j = 0; j < message.rows.length; ++j)
                    object.rows[j] = $root.Ydb.Value.toObject(message.rows[j], options);
            }
            if (message.truncated != null && message.hasOwnProperty("truncated"))
                object.truncated = message.truncated;
            return object;
        };

        /**
         * Converts this ResultSet to JSON.
         * @function toJSON
         * @memberof Ydb.ResultSet
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ResultSet.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ResultSet;
    })();

    Ydb.Scheme = (function() {

        /**
         * Namespace Scheme.
         * @memberof Ydb
         * @namespace
         */
        var Scheme = {};

        Scheme.MakeDirectoryRequest = (function() {

            /**
             * Properties of a MakeDirectoryRequest.
             * @memberof Ydb.Scheme
             * @interface IMakeDirectoryRequest
             * @property {Ydb.Operations.IOperationParams|null} [operationParams] MakeDirectoryRequest operationParams
             * @property {string|null} [path] MakeDirectoryRequest path
             */

            /**
             * Constructs a new MakeDirectoryRequest.
             * @memberof Ydb.Scheme
             * @classdesc Represents a MakeDirectoryRequest.
             * @implements IMakeDirectoryRequest
             * @constructor
             * @param {Ydb.Scheme.IMakeDirectoryRequest=} [properties] Properties to set
             */
            function MakeDirectoryRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MakeDirectoryRequest operationParams.
             * @member {Ydb.Operations.IOperationParams|null|undefined} operationParams
             * @memberof Ydb.Scheme.MakeDirectoryRequest
             * @instance
             */
            MakeDirectoryRequest.prototype.operationParams = null;

            /**
             * MakeDirectoryRequest path.
             * @member {string} path
             * @memberof Ydb.Scheme.MakeDirectoryRequest
             * @instance
             */
            MakeDirectoryRequest.prototype.path = "";

            /**
             * Creates a new MakeDirectoryRequest instance using the specified properties.
             * @function create
             * @memberof Ydb.Scheme.MakeDirectoryRequest
             * @static
             * @param {Ydb.Scheme.IMakeDirectoryRequest=} [properties] Properties to set
             * @returns {Ydb.Scheme.MakeDirectoryRequest} MakeDirectoryRequest instance
             */
            MakeDirectoryRequest.create = function create(properties) {
                return new MakeDirectoryRequest(properties);
            };

            /**
             * Encodes the specified MakeDirectoryRequest message. Does not implicitly {@link Ydb.Scheme.MakeDirectoryRequest.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Scheme.MakeDirectoryRequest
             * @static
             * @param {Ydb.Scheme.IMakeDirectoryRequest} message MakeDirectoryRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MakeDirectoryRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.operationParams != null && Object.hasOwnProperty.call(message, "operationParams"))
                    $root.Ydb.Operations.OperationParams.encode(message.operationParams, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.path != null && Object.hasOwnProperty.call(message, "path"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.path);
                return writer;
            };

            /**
             * Encodes the specified MakeDirectoryRequest message, length delimited. Does not implicitly {@link Ydb.Scheme.MakeDirectoryRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Scheme.MakeDirectoryRequest
             * @static
             * @param {Ydb.Scheme.IMakeDirectoryRequest} message MakeDirectoryRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MakeDirectoryRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MakeDirectoryRequest message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Scheme.MakeDirectoryRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Scheme.MakeDirectoryRequest} MakeDirectoryRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MakeDirectoryRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Scheme.MakeDirectoryRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.operationParams = $root.Ydb.Operations.OperationParams.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.path = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MakeDirectoryRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Scheme.MakeDirectoryRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Scheme.MakeDirectoryRequest} MakeDirectoryRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MakeDirectoryRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MakeDirectoryRequest message.
             * @function verify
             * @memberof Ydb.Scheme.MakeDirectoryRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MakeDirectoryRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.operationParams != null && message.hasOwnProperty("operationParams")) {
                    var error = $root.Ydb.Operations.OperationParams.verify(message.operationParams);
                    if (error)
                        return "operationParams." + error;
                }
                if (message.path != null && message.hasOwnProperty("path"))
                    if (!$util.isString(message.path))
                        return "path: string expected";
                return null;
            };

            /**
             * Creates a MakeDirectoryRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Scheme.MakeDirectoryRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Scheme.MakeDirectoryRequest} MakeDirectoryRequest
             */
            MakeDirectoryRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Scheme.MakeDirectoryRequest)
                    return object;
                var message = new $root.Ydb.Scheme.MakeDirectoryRequest();
                if (object.operationParams != null) {
                    if (typeof object.operationParams !== "object")
                        throw TypeError(".Ydb.Scheme.MakeDirectoryRequest.operationParams: object expected");
                    message.operationParams = $root.Ydb.Operations.OperationParams.fromObject(object.operationParams);
                }
                if (object.path != null)
                    message.path = String(object.path);
                return message;
            };

            /**
             * Creates a plain object from a MakeDirectoryRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Scheme.MakeDirectoryRequest
             * @static
             * @param {Ydb.Scheme.MakeDirectoryRequest} message MakeDirectoryRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MakeDirectoryRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.operationParams = null;
                    object.path = "";
                }
                if (message.operationParams != null && message.hasOwnProperty("operationParams"))
                    object.operationParams = $root.Ydb.Operations.OperationParams.toObject(message.operationParams, options);
                if (message.path != null && message.hasOwnProperty("path"))
                    object.path = message.path;
                return object;
            };

            /**
             * Converts this MakeDirectoryRequest to JSON.
             * @function toJSON
             * @memberof Ydb.Scheme.MakeDirectoryRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MakeDirectoryRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return MakeDirectoryRequest;
        })();

        Scheme.MakeDirectoryResponse = (function() {

            /**
             * Properties of a MakeDirectoryResponse.
             * @memberof Ydb.Scheme
             * @interface IMakeDirectoryResponse
             * @property {Ydb.Operations.IOperation|null} [operation] MakeDirectoryResponse operation
             */

            /**
             * Constructs a new MakeDirectoryResponse.
             * @memberof Ydb.Scheme
             * @classdesc Represents a MakeDirectoryResponse.
             * @implements IMakeDirectoryResponse
             * @constructor
             * @param {Ydb.Scheme.IMakeDirectoryResponse=} [properties] Properties to set
             */
            function MakeDirectoryResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MakeDirectoryResponse operation.
             * @member {Ydb.Operations.IOperation|null|undefined} operation
             * @memberof Ydb.Scheme.MakeDirectoryResponse
             * @instance
             */
            MakeDirectoryResponse.prototype.operation = null;

            /**
             * Creates a new MakeDirectoryResponse instance using the specified properties.
             * @function create
             * @memberof Ydb.Scheme.MakeDirectoryResponse
             * @static
             * @param {Ydb.Scheme.IMakeDirectoryResponse=} [properties] Properties to set
             * @returns {Ydb.Scheme.MakeDirectoryResponse} MakeDirectoryResponse instance
             */
            MakeDirectoryResponse.create = function create(properties) {
                return new MakeDirectoryResponse(properties);
            };

            /**
             * Encodes the specified MakeDirectoryResponse message. Does not implicitly {@link Ydb.Scheme.MakeDirectoryResponse.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Scheme.MakeDirectoryResponse
             * @static
             * @param {Ydb.Scheme.IMakeDirectoryResponse} message MakeDirectoryResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MakeDirectoryResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.operation != null && Object.hasOwnProperty.call(message, "operation"))
                    $root.Ydb.Operations.Operation.encode(message.operation, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified MakeDirectoryResponse message, length delimited. Does not implicitly {@link Ydb.Scheme.MakeDirectoryResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Scheme.MakeDirectoryResponse
             * @static
             * @param {Ydb.Scheme.IMakeDirectoryResponse} message MakeDirectoryResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MakeDirectoryResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MakeDirectoryResponse message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Scheme.MakeDirectoryResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Scheme.MakeDirectoryResponse} MakeDirectoryResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MakeDirectoryResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Scheme.MakeDirectoryResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.operation = $root.Ydb.Operations.Operation.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MakeDirectoryResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Scheme.MakeDirectoryResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Scheme.MakeDirectoryResponse} MakeDirectoryResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MakeDirectoryResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MakeDirectoryResponse message.
             * @function verify
             * @memberof Ydb.Scheme.MakeDirectoryResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MakeDirectoryResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.operation != null && message.hasOwnProperty("operation")) {
                    var error = $root.Ydb.Operations.Operation.verify(message.operation);
                    if (error)
                        return "operation." + error;
                }
                return null;
            };

            /**
             * Creates a MakeDirectoryResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Scheme.MakeDirectoryResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Scheme.MakeDirectoryResponse} MakeDirectoryResponse
             */
            MakeDirectoryResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Scheme.MakeDirectoryResponse)
                    return object;
                var message = new $root.Ydb.Scheme.MakeDirectoryResponse();
                if (object.operation != null) {
                    if (typeof object.operation !== "object")
                        throw TypeError(".Ydb.Scheme.MakeDirectoryResponse.operation: object expected");
                    message.operation = $root.Ydb.Operations.Operation.fromObject(object.operation);
                }
                return message;
            };

            /**
             * Creates a plain object from a MakeDirectoryResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Scheme.MakeDirectoryResponse
             * @static
             * @param {Ydb.Scheme.MakeDirectoryResponse} message MakeDirectoryResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MakeDirectoryResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.operation = null;
                if (message.operation != null && message.hasOwnProperty("operation"))
                    object.operation = $root.Ydb.Operations.Operation.toObject(message.operation, options);
                return object;
            };

            /**
             * Converts this MakeDirectoryResponse to JSON.
             * @function toJSON
             * @memberof Ydb.Scheme.MakeDirectoryResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MakeDirectoryResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return MakeDirectoryResponse;
        })();

        Scheme.RemoveDirectoryRequest = (function() {

            /**
             * Properties of a RemoveDirectoryRequest.
             * @memberof Ydb.Scheme
             * @interface IRemoveDirectoryRequest
             * @property {Ydb.Operations.IOperationParams|null} [operationParams] RemoveDirectoryRequest operationParams
             * @property {string|null} [path] RemoveDirectoryRequest path
             */

            /**
             * Constructs a new RemoveDirectoryRequest.
             * @memberof Ydb.Scheme
             * @classdesc Represents a RemoveDirectoryRequest.
             * @implements IRemoveDirectoryRequest
             * @constructor
             * @param {Ydb.Scheme.IRemoveDirectoryRequest=} [properties] Properties to set
             */
            function RemoveDirectoryRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RemoveDirectoryRequest operationParams.
             * @member {Ydb.Operations.IOperationParams|null|undefined} operationParams
             * @memberof Ydb.Scheme.RemoveDirectoryRequest
             * @instance
             */
            RemoveDirectoryRequest.prototype.operationParams = null;

            /**
             * RemoveDirectoryRequest path.
             * @member {string} path
             * @memberof Ydb.Scheme.RemoveDirectoryRequest
             * @instance
             */
            RemoveDirectoryRequest.prototype.path = "";

            /**
             * Creates a new RemoveDirectoryRequest instance using the specified properties.
             * @function create
             * @memberof Ydb.Scheme.RemoveDirectoryRequest
             * @static
             * @param {Ydb.Scheme.IRemoveDirectoryRequest=} [properties] Properties to set
             * @returns {Ydb.Scheme.RemoveDirectoryRequest} RemoveDirectoryRequest instance
             */
            RemoveDirectoryRequest.create = function create(properties) {
                return new RemoveDirectoryRequest(properties);
            };

            /**
             * Encodes the specified RemoveDirectoryRequest message. Does not implicitly {@link Ydb.Scheme.RemoveDirectoryRequest.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Scheme.RemoveDirectoryRequest
             * @static
             * @param {Ydb.Scheme.IRemoveDirectoryRequest} message RemoveDirectoryRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RemoveDirectoryRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.operationParams != null && Object.hasOwnProperty.call(message, "operationParams"))
                    $root.Ydb.Operations.OperationParams.encode(message.operationParams, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.path != null && Object.hasOwnProperty.call(message, "path"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.path);
                return writer;
            };

            /**
             * Encodes the specified RemoveDirectoryRequest message, length delimited. Does not implicitly {@link Ydb.Scheme.RemoveDirectoryRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Scheme.RemoveDirectoryRequest
             * @static
             * @param {Ydb.Scheme.IRemoveDirectoryRequest} message RemoveDirectoryRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RemoveDirectoryRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RemoveDirectoryRequest message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Scheme.RemoveDirectoryRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Scheme.RemoveDirectoryRequest} RemoveDirectoryRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RemoveDirectoryRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Scheme.RemoveDirectoryRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.operationParams = $root.Ydb.Operations.OperationParams.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.path = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RemoveDirectoryRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Scheme.RemoveDirectoryRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Scheme.RemoveDirectoryRequest} RemoveDirectoryRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RemoveDirectoryRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RemoveDirectoryRequest message.
             * @function verify
             * @memberof Ydb.Scheme.RemoveDirectoryRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RemoveDirectoryRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.operationParams != null && message.hasOwnProperty("operationParams")) {
                    var error = $root.Ydb.Operations.OperationParams.verify(message.operationParams);
                    if (error)
                        return "operationParams." + error;
                }
                if (message.path != null && message.hasOwnProperty("path"))
                    if (!$util.isString(message.path))
                        return "path: string expected";
                return null;
            };

            /**
             * Creates a RemoveDirectoryRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Scheme.RemoveDirectoryRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Scheme.RemoveDirectoryRequest} RemoveDirectoryRequest
             */
            RemoveDirectoryRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Scheme.RemoveDirectoryRequest)
                    return object;
                var message = new $root.Ydb.Scheme.RemoveDirectoryRequest();
                if (object.operationParams != null) {
                    if (typeof object.operationParams !== "object")
                        throw TypeError(".Ydb.Scheme.RemoveDirectoryRequest.operationParams: object expected");
                    message.operationParams = $root.Ydb.Operations.OperationParams.fromObject(object.operationParams);
                }
                if (object.path != null)
                    message.path = String(object.path);
                return message;
            };

            /**
             * Creates a plain object from a RemoveDirectoryRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Scheme.RemoveDirectoryRequest
             * @static
             * @param {Ydb.Scheme.RemoveDirectoryRequest} message RemoveDirectoryRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RemoveDirectoryRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.operationParams = null;
                    object.path = "";
                }
                if (message.operationParams != null && message.hasOwnProperty("operationParams"))
                    object.operationParams = $root.Ydb.Operations.OperationParams.toObject(message.operationParams, options);
                if (message.path != null && message.hasOwnProperty("path"))
                    object.path = message.path;
                return object;
            };

            /**
             * Converts this RemoveDirectoryRequest to JSON.
             * @function toJSON
             * @memberof Ydb.Scheme.RemoveDirectoryRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RemoveDirectoryRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RemoveDirectoryRequest;
        })();

        Scheme.RemoveDirectoryResponse = (function() {

            /**
             * Properties of a RemoveDirectoryResponse.
             * @memberof Ydb.Scheme
             * @interface IRemoveDirectoryResponse
             * @property {Ydb.Operations.IOperation|null} [operation] RemoveDirectoryResponse operation
             */

            /**
             * Constructs a new RemoveDirectoryResponse.
             * @memberof Ydb.Scheme
             * @classdesc Represents a RemoveDirectoryResponse.
             * @implements IRemoveDirectoryResponse
             * @constructor
             * @param {Ydb.Scheme.IRemoveDirectoryResponse=} [properties] Properties to set
             */
            function RemoveDirectoryResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RemoveDirectoryResponse operation.
             * @member {Ydb.Operations.IOperation|null|undefined} operation
             * @memberof Ydb.Scheme.RemoveDirectoryResponse
             * @instance
             */
            RemoveDirectoryResponse.prototype.operation = null;

            /**
             * Creates a new RemoveDirectoryResponse instance using the specified properties.
             * @function create
             * @memberof Ydb.Scheme.RemoveDirectoryResponse
             * @static
             * @param {Ydb.Scheme.IRemoveDirectoryResponse=} [properties] Properties to set
             * @returns {Ydb.Scheme.RemoveDirectoryResponse} RemoveDirectoryResponse instance
             */
            RemoveDirectoryResponse.create = function create(properties) {
                return new RemoveDirectoryResponse(properties);
            };

            /**
             * Encodes the specified RemoveDirectoryResponse message. Does not implicitly {@link Ydb.Scheme.RemoveDirectoryResponse.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Scheme.RemoveDirectoryResponse
             * @static
             * @param {Ydb.Scheme.IRemoveDirectoryResponse} message RemoveDirectoryResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RemoveDirectoryResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.operation != null && Object.hasOwnProperty.call(message, "operation"))
                    $root.Ydb.Operations.Operation.encode(message.operation, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified RemoveDirectoryResponse message, length delimited. Does not implicitly {@link Ydb.Scheme.RemoveDirectoryResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Scheme.RemoveDirectoryResponse
             * @static
             * @param {Ydb.Scheme.IRemoveDirectoryResponse} message RemoveDirectoryResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RemoveDirectoryResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RemoveDirectoryResponse message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Scheme.RemoveDirectoryResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Scheme.RemoveDirectoryResponse} RemoveDirectoryResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RemoveDirectoryResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Scheme.RemoveDirectoryResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.operation = $root.Ydb.Operations.Operation.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RemoveDirectoryResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Scheme.RemoveDirectoryResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Scheme.RemoveDirectoryResponse} RemoveDirectoryResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RemoveDirectoryResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RemoveDirectoryResponse message.
             * @function verify
             * @memberof Ydb.Scheme.RemoveDirectoryResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RemoveDirectoryResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.operation != null && message.hasOwnProperty("operation")) {
                    var error = $root.Ydb.Operations.Operation.verify(message.operation);
                    if (error)
                        return "operation." + error;
                }
                return null;
            };

            /**
             * Creates a RemoveDirectoryResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Scheme.RemoveDirectoryResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Scheme.RemoveDirectoryResponse} RemoveDirectoryResponse
             */
            RemoveDirectoryResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Scheme.RemoveDirectoryResponse)
                    return object;
                var message = new $root.Ydb.Scheme.RemoveDirectoryResponse();
                if (object.operation != null) {
                    if (typeof object.operation !== "object")
                        throw TypeError(".Ydb.Scheme.RemoveDirectoryResponse.operation: object expected");
                    message.operation = $root.Ydb.Operations.Operation.fromObject(object.operation);
                }
                return message;
            };

            /**
             * Creates a plain object from a RemoveDirectoryResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Scheme.RemoveDirectoryResponse
             * @static
             * @param {Ydb.Scheme.RemoveDirectoryResponse} message RemoveDirectoryResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RemoveDirectoryResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.operation = null;
                if (message.operation != null && message.hasOwnProperty("operation"))
                    object.operation = $root.Ydb.Operations.Operation.toObject(message.operation, options);
                return object;
            };

            /**
             * Converts this RemoveDirectoryResponse to JSON.
             * @function toJSON
             * @memberof Ydb.Scheme.RemoveDirectoryResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RemoveDirectoryResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RemoveDirectoryResponse;
        })();

        Scheme.ListDirectoryRequest = (function() {

            /**
             * Properties of a ListDirectoryRequest.
             * @memberof Ydb.Scheme
             * @interface IListDirectoryRequest
             * @property {Ydb.Operations.IOperationParams|null} [operationParams] ListDirectoryRequest operationParams
             * @property {string|null} [path] ListDirectoryRequest path
             */

            /**
             * Constructs a new ListDirectoryRequest.
             * @memberof Ydb.Scheme
             * @classdesc Represents a ListDirectoryRequest.
             * @implements IListDirectoryRequest
             * @constructor
             * @param {Ydb.Scheme.IListDirectoryRequest=} [properties] Properties to set
             */
            function ListDirectoryRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ListDirectoryRequest operationParams.
             * @member {Ydb.Operations.IOperationParams|null|undefined} operationParams
             * @memberof Ydb.Scheme.ListDirectoryRequest
             * @instance
             */
            ListDirectoryRequest.prototype.operationParams = null;

            /**
             * ListDirectoryRequest path.
             * @member {string} path
             * @memberof Ydb.Scheme.ListDirectoryRequest
             * @instance
             */
            ListDirectoryRequest.prototype.path = "";

            /**
             * Creates a new ListDirectoryRequest instance using the specified properties.
             * @function create
             * @memberof Ydb.Scheme.ListDirectoryRequest
             * @static
             * @param {Ydb.Scheme.IListDirectoryRequest=} [properties] Properties to set
             * @returns {Ydb.Scheme.ListDirectoryRequest} ListDirectoryRequest instance
             */
            ListDirectoryRequest.create = function create(properties) {
                return new ListDirectoryRequest(properties);
            };

            /**
             * Encodes the specified ListDirectoryRequest message. Does not implicitly {@link Ydb.Scheme.ListDirectoryRequest.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Scheme.ListDirectoryRequest
             * @static
             * @param {Ydb.Scheme.IListDirectoryRequest} message ListDirectoryRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ListDirectoryRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.operationParams != null && Object.hasOwnProperty.call(message, "operationParams"))
                    $root.Ydb.Operations.OperationParams.encode(message.operationParams, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.path != null && Object.hasOwnProperty.call(message, "path"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.path);
                return writer;
            };

            /**
             * Encodes the specified ListDirectoryRequest message, length delimited. Does not implicitly {@link Ydb.Scheme.ListDirectoryRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Scheme.ListDirectoryRequest
             * @static
             * @param {Ydb.Scheme.IListDirectoryRequest} message ListDirectoryRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ListDirectoryRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ListDirectoryRequest message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Scheme.ListDirectoryRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Scheme.ListDirectoryRequest} ListDirectoryRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ListDirectoryRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Scheme.ListDirectoryRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.operationParams = $root.Ydb.Operations.OperationParams.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.path = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ListDirectoryRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Scheme.ListDirectoryRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Scheme.ListDirectoryRequest} ListDirectoryRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ListDirectoryRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ListDirectoryRequest message.
             * @function verify
             * @memberof Ydb.Scheme.ListDirectoryRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ListDirectoryRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.operationParams != null && message.hasOwnProperty("operationParams")) {
                    var error = $root.Ydb.Operations.OperationParams.verify(message.operationParams);
                    if (error)
                        return "operationParams." + error;
                }
                if (message.path != null && message.hasOwnProperty("path"))
                    if (!$util.isString(message.path))
                        return "path: string expected";
                return null;
            };

            /**
             * Creates a ListDirectoryRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Scheme.ListDirectoryRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Scheme.ListDirectoryRequest} ListDirectoryRequest
             */
            ListDirectoryRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Scheme.ListDirectoryRequest)
                    return object;
                var message = new $root.Ydb.Scheme.ListDirectoryRequest();
                if (object.operationParams != null) {
                    if (typeof object.operationParams !== "object")
                        throw TypeError(".Ydb.Scheme.ListDirectoryRequest.operationParams: object expected");
                    message.operationParams = $root.Ydb.Operations.OperationParams.fromObject(object.operationParams);
                }
                if (object.path != null)
                    message.path = String(object.path);
                return message;
            };

            /**
             * Creates a plain object from a ListDirectoryRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Scheme.ListDirectoryRequest
             * @static
             * @param {Ydb.Scheme.ListDirectoryRequest} message ListDirectoryRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ListDirectoryRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.operationParams = null;
                    object.path = "";
                }
                if (message.operationParams != null && message.hasOwnProperty("operationParams"))
                    object.operationParams = $root.Ydb.Operations.OperationParams.toObject(message.operationParams, options);
                if (message.path != null && message.hasOwnProperty("path"))
                    object.path = message.path;
                return object;
            };

            /**
             * Converts this ListDirectoryRequest to JSON.
             * @function toJSON
             * @memberof Ydb.Scheme.ListDirectoryRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ListDirectoryRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ListDirectoryRequest;
        })();

        Scheme.ListDirectoryResponse = (function() {

            /**
             * Properties of a ListDirectoryResponse.
             * @memberof Ydb.Scheme
             * @interface IListDirectoryResponse
             * @property {Ydb.Operations.IOperation|null} [operation] ListDirectoryResponse operation
             */

            /**
             * Constructs a new ListDirectoryResponse.
             * @memberof Ydb.Scheme
             * @classdesc Represents a ListDirectoryResponse.
             * @implements IListDirectoryResponse
             * @constructor
             * @param {Ydb.Scheme.IListDirectoryResponse=} [properties] Properties to set
             */
            function ListDirectoryResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ListDirectoryResponse operation.
             * @member {Ydb.Operations.IOperation|null|undefined} operation
             * @memberof Ydb.Scheme.ListDirectoryResponse
             * @instance
             */
            ListDirectoryResponse.prototype.operation = null;

            /**
             * Creates a new ListDirectoryResponse instance using the specified properties.
             * @function create
             * @memberof Ydb.Scheme.ListDirectoryResponse
             * @static
             * @param {Ydb.Scheme.IListDirectoryResponse=} [properties] Properties to set
             * @returns {Ydb.Scheme.ListDirectoryResponse} ListDirectoryResponse instance
             */
            ListDirectoryResponse.create = function create(properties) {
                return new ListDirectoryResponse(properties);
            };

            /**
             * Encodes the specified ListDirectoryResponse message. Does not implicitly {@link Ydb.Scheme.ListDirectoryResponse.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Scheme.ListDirectoryResponse
             * @static
             * @param {Ydb.Scheme.IListDirectoryResponse} message ListDirectoryResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ListDirectoryResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.operation != null && Object.hasOwnProperty.call(message, "operation"))
                    $root.Ydb.Operations.Operation.encode(message.operation, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ListDirectoryResponse message, length delimited. Does not implicitly {@link Ydb.Scheme.ListDirectoryResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Scheme.ListDirectoryResponse
             * @static
             * @param {Ydb.Scheme.IListDirectoryResponse} message ListDirectoryResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ListDirectoryResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ListDirectoryResponse message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Scheme.ListDirectoryResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Scheme.ListDirectoryResponse} ListDirectoryResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ListDirectoryResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Scheme.ListDirectoryResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.operation = $root.Ydb.Operations.Operation.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ListDirectoryResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Scheme.ListDirectoryResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Scheme.ListDirectoryResponse} ListDirectoryResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ListDirectoryResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ListDirectoryResponse message.
             * @function verify
             * @memberof Ydb.Scheme.ListDirectoryResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ListDirectoryResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.operation != null && message.hasOwnProperty("operation")) {
                    var error = $root.Ydb.Operations.Operation.verify(message.operation);
                    if (error)
                        return "operation." + error;
                }
                return null;
            };

            /**
             * Creates a ListDirectoryResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Scheme.ListDirectoryResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Scheme.ListDirectoryResponse} ListDirectoryResponse
             */
            ListDirectoryResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Scheme.ListDirectoryResponse)
                    return object;
                var message = new $root.Ydb.Scheme.ListDirectoryResponse();
                if (object.operation != null) {
                    if (typeof object.operation !== "object")
                        throw TypeError(".Ydb.Scheme.ListDirectoryResponse.operation: object expected");
                    message.operation = $root.Ydb.Operations.Operation.fromObject(object.operation);
                }
                return message;
            };

            /**
             * Creates a plain object from a ListDirectoryResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Scheme.ListDirectoryResponse
             * @static
             * @param {Ydb.Scheme.ListDirectoryResponse} message ListDirectoryResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ListDirectoryResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.operation = null;
                if (message.operation != null && message.hasOwnProperty("operation"))
                    object.operation = $root.Ydb.Operations.Operation.toObject(message.operation, options);
                return object;
            };

            /**
             * Converts this ListDirectoryResponse to JSON.
             * @function toJSON
             * @memberof Ydb.Scheme.ListDirectoryResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ListDirectoryResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ListDirectoryResponse;
        })();

        Scheme.Permissions = (function() {

            /**
             * Properties of a Permissions.
             * @memberof Ydb.Scheme
             * @interface IPermissions
             * @property {string|null} [subject] Permissions subject
             * @property {Array.<string>|null} [permissionNames] Permissions permissionNames
             */

            /**
             * Constructs a new Permissions.
             * @memberof Ydb.Scheme
             * @classdesc Represents a Permissions.
             * @implements IPermissions
             * @constructor
             * @param {Ydb.Scheme.IPermissions=} [properties] Properties to set
             */
            function Permissions(properties) {
                this.permissionNames = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Permissions subject.
             * @member {string} subject
             * @memberof Ydb.Scheme.Permissions
             * @instance
             */
            Permissions.prototype.subject = "";

            /**
             * Permissions permissionNames.
             * @member {Array.<string>} permissionNames
             * @memberof Ydb.Scheme.Permissions
             * @instance
             */
            Permissions.prototype.permissionNames = $util.emptyArray;

            /**
             * Creates a new Permissions instance using the specified properties.
             * @function create
             * @memberof Ydb.Scheme.Permissions
             * @static
             * @param {Ydb.Scheme.IPermissions=} [properties] Properties to set
             * @returns {Ydb.Scheme.Permissions} Permissions instance
             */
            Permissions.create = function create(properties) {
                return new Permissions(properties);
            };

            /**
             * Encodes the specified Permissions message. Does not implicitly {@link Ydb.Scheme.Permissions.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Scheme.Permissions
             * @static
             * @param {Ydb.Scheme.IPermissions} message Permissions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Permissions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.subject != null && Object.hasOwnProperty.call(message, "subject"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.subject);
                if (message.permissionNames != null && message.permissionNames.length)
                    for (var i = 0; i < message.permissionNames.length; ++i)
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.permissionNames[i]);
                return writer;
            };

            /**
             * Encodes the specified Permissions message, length delimited. Does not implicitly {@link Ydb.Scheme.Permissions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Scheme.Permissions
             * @static
             * @param {Ydb.Scheme.IPermissions} message Permissions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Permissions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Permissions message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Scheme.Permissions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Scheme.Permissions} Permissions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Permissions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Scheme.Permissions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.subject = reader.string();
                        break;
                    case 2:
                        if (!(message.permissionNames && message.permissionNames.length))
                            message.permissionNames = [];
                        message.permissionNames.push(reader.string());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Permissions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Scheme.Permissions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Scheme.Permissions} Permissions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Permissions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Permissions message.
             * @function verify
             * @memberof Ydb.Scheme.Permissions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Permissions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.subject != null && message.hasOwnProperty("subject"))
                    if (!$util.isString(message.subject))
                        return "subject: string expected";
                if (message.permissionNames != null && message.hasOwnProperty("permissionNames")) {
                    if (!Array.isArray(message.permissionNames))
                        return "permissionNames: array expected";
                    for (var i = 0; i < message.permissionNames.length; ++i)
                        if (!$util.isString(message.permissionNames[i]))
                            return "permissionNames: string[] expected";
                }
                return null;
            };

            /**
             * Creates a Permissions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Scheme.Permissions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Scheme.Permissions} Permissions
             */
            Permissions.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Scheme.Permissions)
                    return object;
                var message = new $root.Ydb.Scheme.Permissions();
                if (object.subject != null)
                    message.subject = String(object.subject);
                if (object.permissionNames) {
                    if (!Array.isArray(object.permissionNames))
                        throw TypeError(".Ydb.Scheme.Permissions.permissionNames: array expected");
                    message.permissionNames = [];
                    for (var i = 0; i < object.permissionNames.length; ++i)
                        message.permissionNames[i] = String(object.permissionNames[i]);
                }
                return message;
            };

            /**
             * Creates a plain object from a Permissions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Scheme.Permissions
             * @static
             * @param {Ydb.Scheme.Permissions} message Permissions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Permissions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.permissionNames = [];
                if (options.defaults)
                    object.subject = "";
                if (message.subject != null && message.hasOwnProperty("subject"))
                    object.subject = message.subject;
                if (message.permissionNames && message.permissionNames.length) {
                    object.permissionNames = [];
                    for (var j = 0; j < message.permissionNames.length; ++j)
                        object.permissionNames[j] = message.permissionNames[j];
                }
                return object;
            };

            /**
             * Converts this Permissions to JSON.
             * @function toJSON
             * @memberof Ydb.Scheme.Permissions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Permissions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Permissions;
        })();

        Scheme.Entry = (function() {

            /**
             * Properties of an Entry.
             * @memberof Ydb.Scheme
             * @interface IEntry
             * @property {string|null} [name] Entry name
             * @property {string|null} [owner] Entry owner
             * @property {Ydb.Scheme.Entry.Type|null} [type] Entry type
             * @property {Array.<Ydb.Scheme.IPermissions>|null} [effectivePermissions] Entry effectivePermissions
             * @property {Array.<Ydb.Scheme.IPermissions>|null} [permissions] Entry permissions
             */

            /**
             * Constructs a new Entry.
             * @memberof Ydb.Scheme
             * @classdesc Represents an Entry.
             * @implements IEntry
             * @constructor
             * @param {Ydb.Scheme.IEntry=} [properties] Properties to set
             */
            function Entry(properties) {
                this.effectivePermissions = [];
                this.permissions = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Entry name.
             * @member {string} name
             * @memberof Ydb.Scheme.Entry
             * @instance
             */
            Entry.prototype.name = "";

            /**
             * Entry owner.
             * @member {string} owner
             * @memberof Ydb.Scheme.Entry
             * @instance
             */
            Entry.prototype.owner = "";

            /**
             * Entry type.
             * @member {Ydb.Scheme.Entry.Type} type
             * @memberof Ydb.Scheme.Entry
             * @instance
             */
            Entry.prototype.type = 0;

            /**
             * Entry effectivePermissions.
             * @member {Array.<Ydb.Scheme.IPermissions>} effectivePermissions
             * @memberof Ydb.Scheme.Entry
             * @instance
             */
            Entry.prototype.effectivePermissions = $util.emptyArray;

            /**
             * Entry permissions.
             * @member {Array.<Ydb.Scheme.IPermissions>} permissions
             * @memberof Ydb.Scheme.Entry
             * @instance
             */
            Entry.prototype.permissions = $util.emptyArray;

            /**
             * Creates a new Entry instance using the specified properties.
             * @function create
             * @memberof Ydb.Scheme.Entry
             * @static
             * @param {Ydb.Scheme.IEntry=} [properties] Properties to set
             * @returns {Ydb.Scheme.Entry} Entry instance
             */
            Entry.create = function create(properties) {
                return new Entry(properties);
            };

            /**
             * Encodes the specified Entry message. Does not implicitly {@link Ydb.Scheme.Entry.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Scheme.Entry
             * @static
             * @param {Ydb.Scheme.IEntry} message Entry message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Entry.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.owner != null && Object.hasOwnProperty.call(message, "owner"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.owner);
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.type);
                if (message.effectivePermissions != null && message.effectivePermissions.length)
                    for (var i = 0; i < message.effectivePermissions.length; ++i)
                        $root.Ydb.Scheme.Permissions.encode(message.effectivePermissions[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.permissions != null && message.permissions.length)
                    for (var i = 0; i < message.permissions.length; ++i)
                        $root.Ydb.Scheme.Permissions.encode(message.permissions[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Entry message, length delimited. Does not implicitly {@link Ydb.Scheme.Entry.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Scheme.Entry
             * @static
             * @param {Ydb.Scheme.IEntry} message Entry message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Entry.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an Entry message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Scheme.Entry
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Scheme.Entry} Entry
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Entry.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Scheme.Entry();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message.owner = reader.string();
                        break;
                    case 5:
                        message.type = reader.int32();
                        break;
                    case 6:
                        if (!(message.effectivePermissions && message.effectivePermissions.length))
                            message.effectivePermissions = [];
                        message.effectivePermissions.push($root.Ydb.Scheme.Permissions.decode(reader, reader.uint32()));
                        break;
                    case 7:
                        if (!(message.permissions && message.permissions.length))
                            message.permissions = [];
                        message.permissions.push($root.Ydb.Scheme.Permissions.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an Entry message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Scheme.Entry
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Scheme.Entry} Entry
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Entry.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an Entry message.
             * @function verify
             * @memberof Ydb.Scheme.Entry
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Entry.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.owner != null && message.hasOwnProperty("owner"))
                    if (!$util.isString(message.owner))
                        return "owner: string expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                        break;
                    }
                if (message.effectivePermissions != null && message.hasOwnProperty("effectivePermissions")) {
                    if (!Array.isArray(message.effectivePermissions))
                        return "effectivePermissions: array expected";
                    for (var i = 0; i < message.effectivePermissions.length; ++i) {
                        var error = $root.Ydb.Scheme.Permissions.verify(message.effectivePermissions[i]);
                        if (error)
                            return "effectivePermissions." + error;
                    }
                }
                if (message.permissions != null && message.hasOwnProperty("permissions")) {
                    if (!Array.isArray(message.permissions))
                        return "permissions: array expected";
                    for (var i = 0; i < message.permissions.length; ++i) {
                        var error = $root.Ydb.Scheme.Permissions.verify(message.permissions[i]);
                        if (error)
                            return "permissions." + error;
                    }
                }
                return null;
            };

            /**
             * Creates an Entry message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Scheme.Entry
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Scheme.Entry} Entry
             */
            Entry.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Scheme.Entry)
                    return object;
                var message = new $root.Ydb.Scheme.Entry();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.owner != null)
                    message.owner = String(object.owner);
                switch (object.type) {
                case "TYPE_UNSPECIFIED":
                case 0:
                    message.type = 0;
                    break;
                case "DIRECTORY":
                case 1:
                    message.type = 1;
                    break;
                case "TABLE":
                case 2:
                    message.type = 2;
                    break;
                case "PERS_QUEUE_GROUP":
                case 3:
                    message.type = 3;
                    break;
                case "DATABASE":
                case 4:
                    message.type = 4;
                    break;
                case "RTMR_VOLUME":
                case 5:
                    message.type = 5;
                    break;
                case "BLOCK_STORE_VOLUME":
                case 6:
                    message.type = 6;
                    break;
                case "COORDINATION_NODE":
                case 7:
                    message.type = 7;
                    break;
                }
                if (object.effectivePermissions) {
                    if (!Array.isArray(object.effectivePermissions))
                        throw TypeError(".Ydb.Scheme.Entry.effectivePermissions: array expected");
                    message.effectivePermissions = [];
                    for (var i = 0; i < object.effectivePermissions.length; ++i) {
                        if (typeof object.effectivePermissions[i] !== "object")
                            throw TypeError(".Ydb.Scheme.Entry.effectivePermissions: object expected");
                        message.effectivePermissions[i] = $root.Ydb.Scheme.Permissions.fromObject(object.effectivePermissions[i]);
                    }
                }
                if (object.permissions) {
                    if (!Array.isArray(object.permissions))
                        throw TypeError(".Ydb.Scheme.Entry.permissions: array expected");
                    message.permissions = [];
                    for (var i = 0; i < object.permissions.length; ++i) {
                        if (typeof object.permissions[i] !== "object")
                            throw TypeError(".Ydb.Scheme.Entry.permissions: object expected");
                        message.permissions[i] = $root.Ydb.Scheme.Permissions.fromObject(object.permissions[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from an Entry message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Scheme.Entry
             * @static
             * @param {Ydb.Scheme.Entry} message Entry
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Entry.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.effectivePermissions = [];
                    object.permissions = [];
                }
                if (options.defaults) {
                    object.name = "";
                    object.owner = "";
                    object.type = options.enums === String ? "TYPE_UNSPECIFIED" : 0;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.owner != null && message.hasOwnProperty("owner"))
                    object.owner = message.owner;
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.Ydb.Scheme.Entry.Type[message.type] : message.type;
                if (message.effectivePermissions && message.effectivePermissions.length) {
                    object.effectivePermissions = [];
                    for (var j = 0; j < message.effectivePermissions.length; ++j)
                        object.effectivePermissions[j] = $root.Ydb.Scheme.Permissions.toObject(message.effectivePermissions[j], options);
                }
                if (message.permissions && message.permissions.length) {
                    object.permissions = [];
                    for (var j = 0; j < message.permissions.length; ++j)
                        object.permissions[j] = $root.Ydb.Scheme.Permissions.toObject(message.permissions[j], options);
                }
                return object;
            };

            /**
             * Converts this Entry to JSON.
             * @function toJSON
             * @memberof Ydb.Scheme.Entry
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Entry.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Type enum.
             * @name Ydb.Scheme.Entry.Type
             * @enum {number}
             * @property {number} TYPE_UNSPECIFIED=0 TYPE_UNSPECIFIED value
             * @property {number} DIRECTORY=1 DIRECTORY value
             * @property {number} TABLE=2 TABLE value
             * @property {number} PERS_QUEUE_GROUP=3 PERS_QUEUE_GROUP value
             * @property {number} DATABASE=4 DATABASE value
             * @property {number} RTMR_VOLUME=5 RTMR_VOLUME value
             * @property {number} BLOCK_STORE_VOLUME=6 BLOCK_STORE_VOLUME value
             * @property {number} COORDINATION_NODE=7 COORDINATION_NODE value
             */
            Entry.Type = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "TYPE_UNSPECIFIED"] = 0;
                values[valuesById[1] = "DIRECTORY"] = 1;
                values[valuesById[2] = "TABLE"] = 2;
                values[valuesById[3] = "PERS_QUEUE_GROUP"] = 3;
                values[valuesById[4] = "DATABASE"] = 4;
                values[valuesById[5] = "RTMR_VOLUME"] = 5;
                values[valuesById[6] = "BLOCK_STORE_VOLUME"] = 6;
                values[valuesById[7] = "COORDINATION_NODE"] = 7;
                return values;
            })();

            return Entry;
        })();

        Scheme.ListDirectoryResult = (function() {

            /**
             * Properties of a ListDirectoryResult.
             * @memberof Ydb.Scheme
             * @interface IListDirectoryResult
             * @property {Ydb.Scheme.IEntry|null} [self] ListDirectoryResult self
             * @property {Array.<Ydb.Scheme.IEntry>|null} [children] ListDirectoryResult children
             */

            /**
             * Constructs a new ListDirectoryResult.
             * @memberof Ydb.Scheme
             * @classdesc Represents a ListDirectoryResult.
             * @implements IListDirectoryResult
             * @constructor
             * @param {Ydb.Scheme.IListDirectoryResult=} [properties] Properties to set
             */
            function ListDirectoryResult(properties) {
                this.children = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ListDirectoryResult self.
             * @member {Ydb.Scheme.IEntry|null|undefined} self
             * @memberof Ydb.Scheme.ListDirectoryResult
             * @instance
             */
            ListDirectoryResult.prototype.self = null;

            /**
             * ListDirectoryResult children.
             * @member {Array.<Ydb.Scheme.IEntry>} children
             * @memberof Ydb.Scheme.ListDirectoryResult
             * @instance
             */
            ListDirectoryResult.prototype.children = $util.emptyArray;

            /**
             * Creates a new ListDirectoryResult instance using the specified properties.
             * @function create
             * @memberof Ydb.Scheme.ListDirectoryResult
             * @static
             * @param {Ydb.Scheme.IListDirectoryResult=} [properties] Properties to set
             * @returns {Ydb.Scheme.ListDirectoryResult} ListDirectoryResult instance
             */
            ListDirectoryResult.create = function create(properties) {
                return new ListDirectoryResult(properties);
            };

            /**
             * Encodes the specified ListDirectoryResult message. Does not implicitly {@link Ydb.Scheme.ListDirectoryResult.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Scheme.ListDirectoryResult
             * @static
             * @param {Ydb.Scheme.IListDirectoryResult} message ListDirectoryResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ListDirectoryResult.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.self != null && Object.hasOwnProperty.call(message, "self"))
                    $root.Ydb.Scheme.Entry.encode(message.self, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.children != null && message.children.length)
                    for (var i = 0; i < message.children.length; ++i)
                        $root.Ydb.Scheme.Entry.encode(message.children[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ListDirectoryResult message, length delimited. Does not implicitly {@link Ydb.Scheme.ListDirectoryResult.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Scheme.ListDirectoryResult
             * @static
             * @param {Ydb.Scheme.IListDirectoryResult} message ListDirectoryResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ListDirectoryResult.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ListDirectoryResult message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Scheme.ListDirectoryResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Scheme.ListDirectoryResult} ListDirectoryResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ListDirectoryResult.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Scheme.ListDirectoryResult();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.self = $root.Ydb.Scheme.Entry.decode(reader, reader.uint32());
                        break;
                    case 2:
                        if (!(message.children && message.children.length))
                            message.children = [];
                        message.children.push($root.Ydb.Scheme.Entry.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ListDirectoryResult message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Scheme.ListDirectoryResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Scheme.ListDirectoryResult} ListDirectoryResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ListDirectoryResult.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ListDirectoryResult message.
             * @function verify
             * @memberof Ydb.Scheme.ListDirectoryResult
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ListDirectoryResult.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.self != null && message.hasOwnProperty("self")) {
                    var error = $root.Ydb.Scheme.Entry.verify(message.self);
                    if (error)
                        return "self." + error;
                }
                if (message.children != null && message.hasOwnProperty("children")) {
                    if (!Array.isArray(message.children))
                        return "children: array expected";
                    for (var i = 0; i < message.children.length; ++i) {
                        var error = $root.Ydb.Scheme.Entry.verify(message.children[i]);
                        if (error)
                            return "children." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a ListDirectoryResult message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Scheme.ListDirectoryResult
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Scheme.ListDirectoryResult} ListDirectoryResult
             */
            ListDirectoryResult.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Scheme.ListDirectoryResult)
                    return object;
                var message = new $root.Ydb.Scheme.ListDirectoryResult();
                if (object.self != null) {
                    if (typeof object.self !== "object")
                        throw TypeError(".Ydb.Scheme.ListDirectoryResult.self: object expected");
                    message.self = $root.Ydb.Scheme.Entry.fromObject(object.self);
                }
                if (object.children) {
                    if (!Array.isArray(object.children))
                        throw TypeError(".Ydb.Scheme.ListDirectoryResult.children: array expected");
                    message.children = [];
                    for (var i = 0; i < object.children.length; ++i) {
                        if (typeof object.children[i] !== "object")
                            throw TypeError(".Ydb.Scheme.ListDirectoryResult.children: object expected");
                        message.children[i] = $root.Ydb.Scheme.Entry.fromObject(object.children[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a ListDirectoryResult message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Scheme.ListDirectoryResult
             * @static
             * @param {Ydb.Scheme.ListDirectoryResult} message ListDirectoryResult
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ListDirectoryResult.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.children = [];
                if (options.defaults)
                    object.self = null;
                if (message.self != null && message.hasOwnProperty("self"))
                    object.self = $root.Ydb.Scheme.Entry.toObject(message.self, options);
                if (message.children && message.children.length) {
                    object.children = [];
                    for (var j = 0; j < message.children.length; ++j)
                        object.children[j] = $root.Ydb.Scheme.Entry.toObject(message.children[j], options);
                }
                return object;
            };

            /**
             * Converts this ListDirectoryResult to JSON.
             * @function toJSON
             * @memberof Ydb.Scheme.ListDirectoryResult
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ListDirectoryResult.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ListDirectoryResult;
        })();

        Scheme.DescribePathRequest = (function() {

            /**
             * Properties of a DescribePathRequest.
             * @memberof Ydb.Scheme
             * @interface IDescribePathRequest
             * @property {Ydb.Operations.IOperationParams|null} [operationParams] DescribePathRequest operationParams
             * @property {string|null} [path] DescribePathRequest path
             */

            /**
             * Constructs a new DescribePathRequest.
             * @memberof Ydb.Scheme
             * @classdesc Represents a DescribePathRequest.
             * @implements IDescribePathRequest
             * @constructor
             * @param {Ydb.Scheme.IDescribePathRequest=} [properties] Properties to set
             */
            function DescribePathRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DescribePathRequest operationParams.
             * @member {Ydb.Operations.IOperationParams|null|undefined} operationParams
             * @memberof Ydb.Scheme.DescribePathRequest
             * @instance
             */
            DescribePathRequest.prototype.operationParams = null;

            /**
             * DescribePathRequest path.
             * @member {string} path
             * @memberof Ydb.Scheme.DescribePathRequest
             * @instance
             */
            DescribePathRequest.prototype.path = "";

            /**
             * Creates a new DescribePathRequest instance using the specified properties.
             * @function create
             * @memberof Ydb.Scheme.DescribePathRequest
             * @static
             * @param {Ydb.Scheme.IDescribePathRequest=} [properties] Properties to set
             * @returns {Ydb.Scheme.DescribePathRequest} DescribePathRequest instance
             */
            DescribePathRequest.create = function create(properties) {
                return new DescribePathRequest(properties);
            };

            /**
             * Encodes the specified DescribePathRequest message. Does not implicitly {@link Ydb.Scheme.DescribePathRequest.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Scheme.DescribePathRequest
             * @static
             * @param {Ydb.Scheme.IDescribePathRequest} message DescribePathRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DescribePathRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.operationParams != null && Object.hasOwnProperty.call(message, "operationParams"))
                    $root.Ydb.Operations.OperationParams.encode(message.operationParams, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.path != null && Object.hasOwnProperty.call(message, "path"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.path);
                return writer;
            };

            /**
             * Encodes the specified DescribePathRequest message, length delimited. Does not implicitly {@link Ydb.Scheme.DescribePathRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Scheme.DescribePathRequest
             * @static
             * @param {Ydb.Scheme.IDescribePathRequest} message DescribePathRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DescribePathRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DescribePathRequest message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Scheme.DescribePathRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Scheme.DescribePathRequest} DescribePathRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DescribePathRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Scheme.DescribePathRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.operationParams = $root.Ydb.Operations.OperationParams.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.path = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DescribePathRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Scheme.DescribePathRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Scheme.DescribePathRequest} DescribePathRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DescribePathRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DescribePathRequest message.
             * @function verify
             * @memberof Ydb.Scheme.DescribePathRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DescribePathRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.operationParams != null && message.hasOwnProperty("operationParams")) {
                    var error = $root.Ydb.Operations.OperationParams.verify(message.operationParams);
                    if (error)
                        return "operationParams." + error;
                }
                if (message.path != null && message.hasOwnProperty("path"))
                    if (!$util.isString(message.path))
                        return "path: string expected";
                return null;
            };

            /**
             * Creates a DescribePathRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Scheme.DescribePathRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Scheme.DescribePathRequest} DescribePathRequest
             */
            DescribePathRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Scheme.DescribePathRequest)
                    return object;
                var message = new $root.Ydb.Scheme.DescribePathRequest();
                if (object.operationParams != null) {
                    if (typeof object.operationParams !== "object")
                        throw TypeError(".Ydb.Scheme.DescribePathRequest.operationParams: object expected");
                    message.operationParams = $root.Ydb.Operations.OperationParams.fromObject(object.operationParams);
                }
                if (object.path != null)
                    message.path = String(object.path);
                return message;
            };

            /**
             * Creates a plain object from a DescribePathRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Scheme.DescribePathRequest
             * @static
             * @param {Ydb.Scheme.DescribePathRequest} message DescribePathRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DescribePathRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.operationParams = null;
                    object.path = "";
                }
                if (message.operationParams != null && message.hasOwnProperty("operationParams"))
                    object.operationParams = $root.Ydb.Operations.OperationParams.toObject(message.operationParams, options);
                if (message.path != null && message.hasOwnProperty("path"))
                    object.path = message.path;
                return object;
            };

            /**
             * Converts this DescribePathRequest to JSON.
             * @function toJSON
             * @memberof Ydb.Scheme.DescribePathRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DescribePathRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DescribePathRequest;
        })();

        Scheme.DescribePathResponse = (function() {

            /**
             * Properties of a DescribePathResponse.
             * @memberof Ydb.Scheme
             * @interface IDescribePathResponse
             * @property {Ydb.Operations.IOperation|null} [operation] DescribePathResponse operation
             */

            /**
             * Constructs a new DescribePathResponse.
             * @memberof Ydb.Scheme
             * @classdesc Represents a DescribePathResponse.
             * @implements IDescribePathResponse
             * @constructor
             * @param {Ydb.Scheme.IDescribePathResponse=} [properties] Properties to set
             */
            function DescribePathResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DescribePathResponse operation.
             * @member {Ydb.Operations.IOperation|null|undefined} operation
             * @memberof Ydb.Scheme.DescribePathResponse
             * @instance
             */
            DescribePathResponse.prototype.operation = null;

            /**
             * Creates a new DescribePathResponse instance using the specified properties.
             * @function create
             * @memberof Ydb.Scheme.DescribePathResponse
             * @static
             * @param {Ydb.Scheme.IDescribePathResponse=} [properties] Properties to set
             * @returns {Ydb.Scheme.DescribePathResponse} DescribePathResponse instance
             */
            DescribePathResponse.create = function create(properties) {
                return new DescribePathResponse(properties);
            };

            /**
             * Encodes the specified DescribePathResponse message. Does not implicitly {@link Ydb.Scheme.DescribePathResponse.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Scheme.DescribePathResponse
             * @static
             * @param {Ydb.Scheme.IDescribePathResponse} message DescribePathResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DescribePathResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.operation != null && Object.hasOwnProperty.call(message, "operation"))
                    $root.Ydb.Operations.Operation.encode(message.operation, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified DescribePathResponse message, length delimited. Does not implicitly {@link Ydb.Scheme.DescribePathResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Scheme.DescribePathResponse
             * @static
             * @param {Ydb.Scheme.IDescribePathResponse} message DescribePathResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DescribePathResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DescribePathResponse message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Scheme.DescribePathResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Scheme.DescribePathResponse} DescribePathResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DescribePathResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Scheme.DescribePathResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.operation = $root.Ydb.Operations.Operation.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DescribePathResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Scheme.DescribePathResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Scheme.DescribePathResponse} DescribePathResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DescribePathResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DescribePathResponse message.
             * @function verify
             * @memberof Ydb.Scheme.DescribePathResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DescribePathResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.operation != null && message.hasOwnProperty("operation")) {
                    var error = $root.Ydb.Operations.Operation.verify(message.operation);
                    if (error)
                        return "operation." + error;
                }
                return null;
            };

            /**
             * Creates a DescribePathResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Scheme.DescribePathResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Scheme.DescribePathResponse} DescribePathResponse
             */
            DescribePathResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Scheme.DescribePathResponse)
                    return object;
                var message = new $root.Ydb.Scheme.DescribePathResponse();
                if (object.operation != null) {
                    if (typeof object.operation !== "object")
                        throw TypeError(".Ydb.Scheme.DescribePathResponse.operation: object expected");
                    message.operation = $root.Ydb.Operations.Operation.fromObject(object.operation);
                }
                return message;
            };

            /**
             * Creates a plain object from a DescribePathResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Scheme.DescribePathResponse
             * @static
             * @param {Ydb.Scheme.DescribePathResponse} message DescribePathResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DescribePathResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.operation = null;
                if (message.operation != null && message.hasOwnProperty("operation"))
                    object.operation = $root.Ydb.Operations.Operation.toObject(message.operation, options);
                return object;
            };

            /**
             * Converts this DescribePathResponse to JSON.
             * @function toJSON
             * @memberof Ydb.Scheme.DescribePathResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DescribePathResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DescribePathResponse;
        })();

        Scheme.DescribePathResult = (function() {

            /**
             * Properties of a DescribePathResult.
             * @memberof Ydb.Scheme
             * @interface IDescribePathResult
             * @property {Ydb.Scheme.IEntry|null} [self] DescribePathResult self
             */

            /**
             * Constructs a new DescribePathResult.
             * @memberof Ydb.Scheme
             * @classdesc Represents a DescribePathResult.
             * @implements IDescribePathResult
             * @constructor
             * @param {Ydb.Scheme.IDescribePathResult=} [properties] Properties to set
             */
            function DescribePathResult(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DescribePathResult self.
             * @member {Ydb.Scheme.IEntry|null|undefined} self
             * @memberof Ydb.Scheme.DescribePathResult
             * @instance
             */
            DescribePathResult.prototype.self = null;

            /**
             * Creates a new DescribePathResult instance using the specified properties.
             * @function create
             * @memberof Ydb.Scheme.DescribePathResult
             * @static
             * @param {Ydb.Scheme.IDescribePathResult=} [properties] Properties to set
             * @returns {Ydb.Scheme.DescribePathResult} DescribePathResult instance
             */
            DescribePathResult.create = function create(properties) {
                return new DescribePathResult(properties);
            };

            /**
             * Encodes the specified DescribePathResult message. Does not implicitly {@link Ydb.Scheme.DescribePathResult.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Scheme.DescribePathResult
             * @static
             * @param {Ydb.Scheme.IDescribePathResult} message DescribePathResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DescribePathResult.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.self != null && Object.hasOwnProperty.call(message, "self"))
                    $root.Ydb.Scheme.Entry.encode(message.self, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified DescribePathResult message, length delimited. Does not implicitly {@link Ydb.Scheme.DescribePathResult.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Scheme.DescribePathResult
             * @static
             * @param {Ydb.Scheme.IDescribePathResult} message DescribePathResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DescribePathResult.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DescribePathResult message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Scheme.DescribePathResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Scheme.DescribePathResult} DescribePathResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DescribePathResult.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Scheme.DescribePathResult();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.self = $root.Ydb.Scheme.Entry.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DescribePathResult message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Scheme.DescribePathResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Scheme.DescribePathResult} DescribePathResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DescribePathResult.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DescribePathResult message.
             * @function verify
             * @memberof Ydb.Scheme.DescribePathResult
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DescribePathResult.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.self != null && message.hasOwnProperty("self")) {
                    var error = $root.Ydb.Scheme.Entry.verify(message.self);
                    if (error)
                        return "self." + error;
                }
                return null;
            };

            /**
             * Creates a DescribePathResult message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Scheme.DescribePathResult
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Scheme.DescribePathResult} DescribePathResult
             */
            DescribePathResult.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Scheme.DescribePathResult)
                    return object;
                var message = new $root.Ydb.Scheme.DescribePathResult();
                if (object.self != null) {
                    if (typeof object.self !== "object")
                        throw TypeError(".Ydb.Scheme.DescribePathResult.self: object expected");
                    message.self = $root.Ydb.Scheme.Entry.fromObject(object.self);
                }
                return message;
            };

            /**
             * Creates a plain object from a DescribePathResult message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Scheme.DescribePathResult
             * @static
             * @param {Ydb.Scheme.DescribePathResult} message DescribePathResult
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DescribePathResult.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.self = null;
                if (message.self != null && message.hasOwnProperty("self"))
                    object.self = $root.Ydb.Scheme.Entry.toObject(message.self, options);
                return object;
            };

            /**
             * Converts this DescribePathResult to JSON.
             * @function toJSON
             * @memberof Ydb.Scheme.DescribePathResult
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DescribePathResult.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DescribePathResult;
        })();

        Scheme.PermissionsAction = (function() {

            /**
             * Properties of a PermissionsAction.
             * @memberof Ydb.Scheme
             * @interface IPermissionsAction
             * @property {Ydb.Scheme.IPermissions|null} [grant] PermissionsAction grant
             * @property {Ydb.Scheme.IPermissions|null} [revoke] PermissionsAction revoke
             * @property {Ydb.Scheme.IPermissions|null} [set] PermissionsAction set
             * @property {string|null} [changeOwner] PermissionsAction changeOwner
             */

            /**
             * Constructs a new PermissionsAction.
             * @memberof Ydb.Scheme
             * @classdesc Represents a PermissionsAction.
             * @implements IPermissionsAction
             * @constructor
             * @param {Ydb.Scheme.IPermissionsAction=} [properties] Properties to set
             */
            function PermissionsAction(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PermissionsAction grant.
             * @member {Ydb.Scheme.IPermissions|null|undefined} grant
             * @memberof Ydb.Scheme.PermissionsAction
             * @instance
             */
            PermissionsAction.prototype.grant = null;

            /**
             * PermissionsAction revoke.
             * @member {Ydb.Scheme.IPermissions|null|undefined} revoke
             * @memberof Ydb.Scheme.PermissionsAction
             * @instance
             */
            PermissionsAction.prototype.revoke = null;

            /**
             * PermissionsAction set.
             * @member {Ydb.Scheme.IPermissions|null|undefined} set
             * @memberof Ydb.Scheme.PermissionsAction
             * @instance
             */
            PermissionsAction.prototype.set = null;

            /**
             * PermissionsAction changeOwner.
             * @member {string|null|undefined} changeOwner
             * @memberof Ydb.Scheme.PermissionsAction
             * @instance
             */
            PermissionsAction.prototype.changeOwner = null;

            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;

            /**
             * PermissionsAction action.
             * @member {"grant"|"revoke"|"set"|"changeOwner"|undefined} action
             * @memberof Ydb.Scheme.PermissionsAction
             * @instance
             */
            Object.defineProperty(PermissionsAction.prototype, "action", {
                get: $util.oneOfGetter($oneOfFields = ["grant", "revoke", "set", "changeOwner"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new PermissionsAction instance using the specified properties.
             * @function create
             * @memberof Ydb.Scheme.PermissionsAction
             * @static
             * @param {Ydb.Scheme.IPermissionsAction=} [properties] Properties to set
             * @returns {Ydb.Scheme.PermissionsAction} PermissionsAction instance
             */
            PermissionsAction.create = function create(properties) {
                return new PermissionsAction(properties);
            };

            /**
             * Encodes the specified PermissionsAction message. Does not implicitly {@link Ydb.Scheme.PermissionsAction.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Scheme.PermissionsAction
             * @static
             * @param {Ydb.Scheme.IPermissionsAction} message PermissionsAction message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PermissionsAction.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.grant != null && Object.hasOwnProperty.call(message, "grant"))
                    $root.Ydb.Scheme.Permissions.encode(message.grant, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.revoke != null && Object.hasOwnProperty.call(message, "revoke"))
                    $root.Ydb.Scheme.Permissions.encode(message.revoke, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.set != null && Object.hasOwnProperty.call(message, "set"))
                    $root.Ydb.Scheme.Permissions.encode(message.set, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.changeOwner != null && Object.hasOwnProperty.call(message, "changeOwner"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.changeOwner);
                return writer;
            };

            /**
             * Encodes the specified PermissionsAction message, length delimited. Does not implicitly {@link Ydb.Scheme.PermissionsAction.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Scheme.PermissionsAction
             * @static
             * @param {Ydb.Scheme.IPermissionsAction} message PermissionsAction message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PermissionsAction.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PermissionsAction message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Scheme.PermissionsAction
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Scheme.PermissionsAction} PermissionsAction
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PermissionsAction.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Scheme.PermissionsAction();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.grant = $root.Ydb.Scheme.Permissions.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.revoke = $root.Ydb.Scheme.Permissions.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.set = $root.Ydb.Scheme.Permissions.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.changeOwner = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a PermissionsAction message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Scheme.PermissionsAction
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Scheme.PermissionsAction} PermissionsAction
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PermissionsAction.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PermissionsAction message.
             * @function verify
             * @memberof Ydb.Scheme.PermissionsAction
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PermissionsAction.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.grant != null && message.hasOwnProperty("grant")) {
                    properties.action = 1;
                    {
                        var error = $root.Ydb.Scheme.Permissions.verify(message.grant);
                        if (error)
                            return "grant." + error;
                    }
                }
                if (message.revoke != null && message.hasOwnProperty("revoke")) {
                    if (properties.action === 1)
                        return "action: multiple values";
                    properties.action = 1;
                    {
                        var error = $root.Ydb.Scheme.Permissions.verify(message.revoke);
                        if (error)
                            return "revoke." + error;
                    }
                }
                if (message.set != null && message.hasOwnProperty("set")) {
                    if (properties.action === 1)
                        return "action: multiple values";
                    properties.action = 1;
                    {
                        var error = $root.Ydb.Scheme.Permissions.verify(message.set);
                        if (error)
                            return "set." + error;
                    }
                }
                if (message.changeOwner != null && message.hasOwnProperty("changeOwner")) {
                    if (properties.action === 1)
                        return "action: multiple values";
                    properties.action = 1;
                    if (!$util.isString(message.changeOwner))
                        return "changeOwner: string expected";
                }
                return null;
            };

            /**
             * Creates a PermissionsAction message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Scheme.PermissionsAction
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Scheme.PermissionsAction} PermissionsAction
             */
            PermissionsAction.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Scheme.PermissionsAction)
                    return object;
                var message = new $root.Ydb.Scheme.PermissionsAction();
                if (object.grant != null) {
                    if (typeof object.grant !== "object")
                        throw TypeError(".Ydb.Scheme.PermissionsAction.grant: object expected");
                    message.grant = $root.Ydb.Scheme.Permissions.fromObject(object.grant);
                }
                if (object.revoke != null) {
                    if (typeof object.revoke !== "object")
                        throw TypeError(".Ydb.Scheme.PermissionsAction.revoke: object expected");
                    message.revoke = $root.Ydb.Scheme.Permissions.fromObject(object.revoke);
                }
                if (object.set != null) {
                    if (typeof object.set !== "object")
                        throw TypeError(".Ydb.Scheme.PermissionsAction.set: object expected");
                    message.set = $root.Ydb.Scheme.Permissions.fromObject(object.set);
                }
                if (object.changeOwner != null)
                    message.changeOwner = String(object.changeOwner);
                return message;
            };

            /**
             * Creates a plain object from a PermissionsAction message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Scheme.PermissionsAction
             * @static
             * @param {Ydb.Scheme.PermissionsAction} message PermissionsAction
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PermissionsAction.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (message.grant != null && message.hasOwnProperty("grant")) {
                    object.grant = $root.Ydb.Scheme.Permissions.toObject(message.grant, options);
                    if (options.oneofs)
                        object.action = "grant";
                }
                if (message.revoke != null && message.hasOwnProperty("revoke")) {
                    object.revoke = $root.Ydb.Scheme.Permissions.toObject(message.revoke, options);
                    if (options.oneofs)
                        object.action = "revoke";
                }
                if (message.set != null && message.hasOwnProperty("set")) {
                    object.set = $root.Ydb.Scheme.Permissions.toObject(message.set, options);
                    if (options.oneofs)
                        object.action = "set";
                }
                if (message.changeOwner != null && message.hasOwnProperty("changeOwner")) {
                    object.changeOwner = message.changeOwner;
                    if (options.oneofs)
                        object.action = "changeOwner";
                }
                return object;
            };

            /**
             * Converts this PermissionsAction to JSON.
             * @function toJSON
             * @memberof Ydb.Scheme.PermissionsAction
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PermissionsAction.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return PermissionsAction;
        })();

        Scheme.ModifyPermissionsRequest = (function() {

            /**
             * Properties of a ModifyPermissionsRequest.
             * @memberof Ydb.Scheme
             * @interface IModifyPermissionsRequest
             * @property {Ydb.Operations.IOperationParams|null} [operationParams] ModifyPermissionsRequest operationParams
             * @property {string|null} [path] ModifyPermissionsRequest path
             * @property {Array.<Ydb.Scheme.IPermissionsAction>|null} [actions] ModifyPermissionsRequest actions
             * @property {boolean|null} [clearPermissions] ModifyPermissionsRequest clearPermissions
             */

            /**
             * Constructs a new ModifyPermissionsRequest.
             * @memberof Ydb.Scheme
             * @classdesc Represents a ModifyPermissionsRequest.
             * @implements IModifyPermissionsRequest
             * @constructor
             * @param {Ydb.Scheme.IModifyPermissionsRequest=} [properties] Properties to set
             */
            function ModifyPermissionsRequest(properties) {
                this.actions = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ModifyPermissionsRequest operationParams.
             * @member {Ydb.Operations.IOperationParams|null|undefined} operationParams
             * @memberof Ydb.Scheme.ModifyPermissionsRequest
             * @instance
             */
            ModifyPermissionsRequest.prototype.operationParams = null;

            /**
             * ModifyPermissionsRequest path.
             * @member {string} path
             * @memberof Ydb.Scheme.ModifyPermissionsRequest
             * @instance
             */
            ModifyPermissionsRequest.prototype.path = "";

            /**
             * ModifyPermissionsRequest actions.
             * @member {Array.<Ydb.Scheme.IPermissionsAction>} actions
             * @memberof Ydb.Scheme.ModifyPermissionsRequest
             * @instance
             */
            ModifyPermissionsRequest.prototype.actions = $util.emptyArray;

            /**
             * ModifyPermissionsRequest clearPermissions.
             * @member {boolean} clearPermissions
             * @memberof Ydb.Scheme.ModifyPermissionsRequest
             * @instance
             */
            ModifyPermissionsRequest.prototype.clearPermissions = false;

            /**
             * Creates a new ModifyPermissionsRequest instance using the specified properties.
             * @function create
             * @memberof Ydb.Scheme.ModifyPermissionsRequest
             * @static
             * @param {Ydb.Scheme.IModifyPermissionsRequest=} [properties] Properties to set
             * @returns {Ydb.Scheme.ModifyPermissionsRequest} ModifyPermissionsRequest instance
             */
            ModifyPermissionsRequest.create = function create(properties) {
                return new ModifyPermissionsRequest(properties);
            };

            /**
             * Encodes the specified ModifyPermissionsRequest message. Does not implicitly {@link Ydb.Scheme.ModifyPermissionsRequest.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Scheme.ModifyPermissionsRequest
             * @static
             * @param {Ydb.Scheme.IModifyPermissionsRequest} message ModifyPermissionsRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ModifyPermissionsRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.operationParams != null && Object.hasOwnProperty.call(message, "operationParams"))
                    $root.Ydb.Operations.OperationParams.encode(message.operationParams, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.path != null && Object.hasOwnProperty.call(message, "path"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.path);
                if (message.actions != null && message.actions.length)
                    for (var i = 0; i < message.actions.length; ++i)
                        $root.Ydb.Scheme.PermissionsAction.encode(message.actions[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.clearPermissions != null && Object.hasOwnProperty.call(message, "clearPermissions"))
                    writer.uint32(/* id 4, wireType 0 =*/32).bool(message.clearPermissions);
                return writer;
            };

            /**
             * Encodes the specified ModifyPermissionsRequest message, length delimited. Does not implicitly {@link Ydb.Scheme.ModifyPermissionsRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Scheme.ModifyPermissionsRequest
             * @static
             * @param {Ydb.Scheme.IModifyPermissionsRequest} message ModifyPermissionsRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ModifyPermissionsRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ModifyPermissionsRequest message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Scheme.ModifyPermissionsRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Scheme.ModifyPermissionsRequest} ModifyPermissionsRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ModifyPermissionsRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Scheme.ModifyPermissionsRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.operationParams = $root.Ydb.Operations.OperationParams.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.path = reader.string();
                        break;
                    case 3:
                        if (!(message.actions && message.actions.length))
                            message.actions = [];
                        message.actions.push($root.Ydb.Scheme.PermissionsAction.decode(reader, reader.uint32()));
                        break;
                    case 4:
                        message.clearPermissions = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ModifyPermissionsRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Scheme.ModifyPermissionsRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Scheme.ModifyPermissionsRequest} ModifyPermissionsRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ModifyPermissionsRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ModifyPermissionsRequest message.
             * @function verify
             * @memberof Ydb.Scheme.ModifyPermissionsRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ModifyPermissionsRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.operationParams != null && message.hasOwnProperty("operationParams")) {
                    var error = $root.Ydb.Operations.OperationParams.verify(message.operationParams);
                    if (error)
                        return "operationParams." + error;
                }
                if (message.path != null && message.hasOwnProperty("path"))
                    if (!$util.isString(message.path))
                        return "path: string expected";
                if (message.actions != null && message.hasOwnProperty("actions")) {
                    if (!Array.isArray(message.actions))
                        return "actions: array expected";
                    for (var i = 0; i < message.actions.length; ++i) {
                        var error = $root.Ydb.Scheme.PermissionsAction.verify(message.actions[i]);
                        if (error)
                            return "actions." + error;
                    }
                }
                if (message.clearPermissions != null && message.hasOwnProperty("clearPermissions"))
                    if (typeof message.clearPermissions !== "boolean")
                        return "clearPermissions: boolean expected";
                return null;
            };

            /**
             * Creates a ModifyPermissionsRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Scheme.ModifyPermissionsRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Scheme.ModifyPermissionsRequest} ModifyPermissionsRequest
             */
            ModifyPermissionsRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Scheme.ModifyPermissionsRequest)
                    return object;
                var message = new $root.Ydb.Scheme.ModifyPermissionsRequest();
                if (object.operationParams != null) {
                    if (typeof object.operationParams !== "object")
                        throw TypeError(".Ydb.Scheme.ModifyPermissionsRequest.operationParams: object expected");
                    message.operationParams = $root.Ydb.Operations.OperationParams.fromObject(object.operationParams);
                }
                if (object.path != null)
                    message.path = String(object.path);
                if (object.actions) {
                    if (!Array.isArray(object.actions))
                        throw TypeError(".Ydb.Scheme.ModifyPermissionsRequest.actions: array expected");
                    message.actions = [];
                    for (var i = 0; i < object.actions.length; ++i) {
                        if (typeof object.actions[i] !== "object")
                            throw TypeError(".Ydb.Scheme.ModifyPermissionsRequest.actions: object expected");
                        message.actions[i] = $root.Ydb.Scheme.PermissionsAction.fromObject(object.actions[i]);
                    }
                }
                if (object.clearPermissions != null)
                    message.clearPermissions = Boolean(object.clearPermissions);
                return message;
            };

            /**
             * Creates a plain object from a ModifyPermissionsRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Scheme.ModifyPermissionsRequest
             * @static
             * @param {Ydb.Scheme.ModifyPermissionsRequest} message ModifyPermissionsRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ModifyPermissionsRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.actions = [];
                if (options.defaults) {
                    object.operationParams = null;
                    object.path = "";
                    object.clearPermissions = false;
                }
                if (message.operationParams != null && message.hasOwnProperty("operationParams"))
                    object.operationParams = $root.Ydb.Operations.OperationParams.toObject(message.operationParams, options);
                if (message.path != null && message.hasOwnProperty("path"))
                    object.path = message.path;
                if (message.actions && message.actions.length) {
                    object.actions = [];
                    for (var j = 0; j < message.actions.length; ++j)
                        object.actions[j] = $root.Ydb.Scheme.PermissionsAction.toObject(message.actions[j], options);
                }
                if (message.clearPermissions != null && message.hasOwnProperty("clearPermissions"))
                    object.clearPermissions = message.clearPermissions;
                return object;
            };

            /**
             * Converts this ModifyPermissionsRequest to JSON.
             * @function toJSON
             * @memberof Ydb.Scheme.ModifyPermissionsRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ModifyPermissionsRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ModifyPermissionsRequest;
        })();

        Scheme.ModifyPermissionsResponse = (function() {

            /**
             * Properties of a ModifyPermissionsResponse.
             * @memberof Ydb.Scheme
             * @interface IModifyPermissionsResponse
             * @property {Ydb.Operations.IOperation|null} [operation] ModifyPermissionsResponse operation
             */

            /**
             * Constructs a new ModifyPermissionsResponse.
             * @memberof Ydb.Scheme
             * @classdesc Represents a ModifyPermissionsResponse.
             * @implements IModifyPermissionsResponse
             * @constructor
             * @param {Ydb.Scheme.IModifyPermissionsResponse=} [properties] Properties to set
             */
            function ModifyPermissionsResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ModifyPermissionsResponse operation.
             * @member {Ydb.Operations.IOperation|null|undefined} operation
             * @memberof Ydb.Scheme.ModifyPermissionsResponse
             * @instance
             */
            ModifyPermissionsResponse.prototype.operation = null;

            /**
             * Creates a new ModifyPermissionsResponse instance using the specified properties.
             * @function create
             * @memberof Ydb.Scheme.ModifyPermissionsResponse
             * @static
             * @param {Ydb.Scheme.IModifyPermissionsResponse=} [properties] Properties to set
             * @returns {Ydb.Scheme.ModifyPermissionsResponse} ModifyPermissionsResponse instance
             */
            ModifyPermissionsResponse.create = function create(properties) {
                return new ModifyPermissionsResponse(properties);
            };

            /**
             * Encodes the specified ModifyPermissionsResponse message. Does not implicitly {@link Ydb.Scheme.ModifyPermissionsResponse.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Scheme.ModifyPermissionsResponse
             * @static
             * @param {Ydb.Scheme.IModifyPermissionsResponse} message ModifyPermissionsResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ModifyPermissionsResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.operation != null && Object.hasOwnProperty.call(message, "operation"))
                    $root.Ydb.Operations.Operation.encode(message.operation, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ModifyPermissionsResponse message, length delimited. Does not implicitly {@link Ydb.Scheme.ModifyPermissionsResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Scheme.ModifyPermissionsResponse
             * @static
             * @param {Ydb.Scheme.IModifyPermissionsResponse} message ModifyPermissionsResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ModifyPermissionsResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ModifyPermissionsResponse message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Scheme.ModifyPermissionsResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Scheme.ModifyPermissionsResponse} ModifyPermissionsResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ModifyPermissionsResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Scheme.ModifyPermissionsResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.operation = $root.Ydb.Operations.Operation.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ModifyPermissionsResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Scheme.ModifyPermissionsResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Scheme.ModifyPermissionsResponse} ModifyPermissionsResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ModifyPermissionsResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ModifyPermissionsResponse message.
             * @function verify
             * @memberof Ydb.Scheme.ModifyPermissionsResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ModifyPermissionsResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.operation != null && message.hasOwnProperty("operation")) {
                    var error = $root.Ydb.Operations.Operation.verify(message.operation);
                    if (error)
                        return "operation." + error;
                }
                return null;
            };

            /**
             * Creates a ModifyPermissionsResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Scheme.ModifyPermissionsResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Scheme.ModifyPermissionsResponse} ModifyPermissionsResponse
             */
            ModifyPermissionsResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Scheme.ModifyPermissionsResponse)
                    return object;
                var message = new $root.Ydb.Scheme.ModifyPermissionsResponse();
                if (object.operation != null) {
                    if (typeof object.operation !== "object")
                        throw TypeError(".Ydb.Scheme.ModifyPermissionsResponse.operation: object expected");
                    message.operation = $root.Ydb.Operations.Operation.fromObject(object.operation);
                }
                return message;
            };

            /**
             * Creates a plain object from a ModifyPermissionsResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Scheme.ModifyPermissionsResponse
             * @static
             * @param {Ydb.Scheme.ModifyPermissionsResponse} message ModifyPermissionsResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ModifyPermissionsResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.operation = null;
                if (message.operation != null && message.hasOwnProperty("operation"))
                    object.operation = $root.Ydb.Operations.Operation.toObject(message.operation, options);
                return object;
            };

            /**
             * Converts this ModifyPermissionsResponse to JSON.
             * @function toJSON
             * @memberof Ydb.Scheme.ModifyPermissionsResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ModifyPermissionsResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ModifyPermissionsResponse;
        })();

        return Scheme;
    })();

    Ydb.Scripting = (function() {

        /**
         * Namespace Scripting.
         * @memberof Ydb
         * @namespace
         */
        var Scripting = {};

        Scripting.V1 = (function() {

            /**
             * Namespace V1.
             * @memberof Ydb.Scripting
             * @namespace
             */
            var V1 = {};

            V1.ScriptingService = (function() {

                /**
                 * Constructs a new ScriptingService service.
                 * @memberof Ydb.Scripting.V1
                 * @classdesc Represents a ScriptingService
                 * @extends $protobuf.rpc.Service
                 * @constructor
                 * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                 */
                function ScriptingService(rpcImpl, requestDelimited, responseDelimited) {
                    $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
                }

                (ScriptingService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = ScriptingService;

                /**
                 * Creates new ScriptingService service using the specified rpc implementation.
                 * @function create
                 * @memberof Ydb.Scripting.V1.ScriptingService
                 * @static
                 * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                 * @returns {ScriptingService} RPC service. Useful where requests and/or responses are streamed.
                 */
                ScriptingService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                    return new this(rpcImpl, requestDelimited, responseDelimited);
                };

                /**
                 * Callback as used by {@link Ydb.Scripting.V1.ScriptingService#executeYql}.
                 * @memberof Ydb.Scripting.V1.ScriptingService
                 * @typedef ExecuteYqlCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {Ydb.Scripting.ExecuteYqlResponse} [response] ExecuteYqlResponse
                 */

                /**
                 * Calls ExecuteYql.
                 * @function executeYql
                 * @memberof Ydb.Scripting.V1.ScriptingService
                 * @instance
                 * @param {Ydb.Scripting.IExecuteYqlRequest} request ExecuteYqlRequest message or plain object
                 * @param {Ydb.Scripting.V1.ScriptingService.ExecuteYqlCallback} callback Node-style callback called with the error, if any, and ExecuteYqlResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(ScriptingService.prototype.executeYql = function executeYql(request, callback) {
                    return this.rpcCall(executeYql, $root.Ydb.Scripting.ExecuteYqlRequest, $root.Ydb.Scripting.ExecuteYqlResponse, request, callback);
                }, "name", { value: "ExecuteYql" });

                /**
                 * Calls ExecuteYql.
                 * @function executeYql
                 * @memberof Ydb.Scripting.V1.ScriptingService
                 * @instance
                 * @param {Ydb.Scripting.IExecuteYqlRequest} request ExecuteYqlRequest message or plain object
                 * @returns {Promise<Ydb.Scripting.ExecuteYqlResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link Ydb.Scripting.V1.ScriptingService#streamExecuteYql}.
                 * @memberof Ydb.Scripting.V1.ScriptingService
                 * @typedef StreamExecuteYqlCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {Ydb.Scripting.ExecuteYqlPartialResponse} [response] ExecuteYqlPartialResponse
                 */

                /**
                 * Calls StreamExecuteYql.
                 * @function streamExecuteYql
                 * @memberof Ydb.Scripting.V1.ScriptingService
                 * @instance
                 * @param {Ydb.Scripting.IExecuteYqlRequest} request ExecuteYqlRequest message or plain object
                 * @param {Ydb.Scripting.V1.ScriptingService.StreamExecuteYqlCallback} callback Node-style callback called with the error, if any, and ExecuteYqlPartialResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(ScriptingService.prototype.streamExecuteYql = function streamExecuteYql(request, callback) {
                    return this.rpcCall(streamExecuteYql, $root.Ydb.Scripting.ExecuteYqlRequest, $root.Ydb.Scripting.ExecuteYqlPartialResponse, request, callback);
                }, "name", { value: "StreamExecuteYql" });

                /**
                 * Calls StreamExecuteYql.
                 * @function streamExecuteYql
                 * @memberof Ydb.Scripting.V1.ScriptingService
                 * @instance
                 * @param {Ydb.Scripting.IExecuteYqlRequest} request ExecuteYqlRequest message or plain object
                 * @returns {Promise<Ydb.Scripting.ExecuteYqlPartialResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link Ydb.Scripting.V1.ScriptingService#explainYql}.
                 * @memberof Ydb.Scripting.V1.ScriptingService
                 * @typedef ExplainYqlCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {Ydb.Scripting.ExplainYqlResponse} [response] ExplainYqlResponse
                 */

                /**
                 * Calls ExplainYql.
                 * @function explainYql
                 * @memberof Ydb.Scripting.V1.ScriptingService
                 * @instance
                 * @param {Ydb.Scripting.IExplainYqlRequest} request ExplainYqlRequest message or plain object
                 * @param {Ydb.Scripting.V1.ScriptingService.ExplainYqlCallback} callback Node-style callback called with the error, if any, and ExplainYqlResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(ScriptingService.prototype.explainYql = function explainYql(request, callback) {
                    return this.rpcCall(explainYql, $root.Ydb.Scripting.ExplainYqlRequest, $root.Ydb.Scripting.ExplainYqlResponse, request, callback);
                }, "name", { value: "ExplainYql" });

                /**
                 * Calls ExplainYql.
                 * @function explainYql
                 * @memberof Ydb.Scripting.V1.ScriptingService
                 * @instance
                 * @param {Ydb.Scripting.IExplainYqlRequest} request ExplainYqlRequest message or plain object
                 * @returns {Promise<Ydb.Scripting.ExplainYqlResponse>} Promise
                 * @variation 2
                 */

                return ScriptingService;
            })();

            return V1;
        })();

        Scripting.ExecuteYqlRequest = (function() {

            /**
             * Properties of an ExecuteYqlRequest.
             * @memberof Ydb.Scripting
             * @interface IExecuteYqlRequest
             * @property {Ydb.Operations.IOperationParams|null} [operationParams] ExecuteYqlRequest operationParams
             * @property {string|null} [script] ExecuteYqlRequest script
             * @property {Object.<string,Ydb.ITypedValue>|null} [parameters] ExecuteYqlRequest parameters
             * @property {Ydb.Table.QueryStatsCollection.Mode|null} [collectStats] ExecuteYqlRequest collectStats
             */

            /**
             * Constructs a new ExecuteYqlRequest.
             * @memberof Ydb.Scripting
             * @classdesc Represents an ExecuteYqlRequest.
             * @implements IExecuteYqlRequest
             * @constructor
             * @param {Ydb.Scripting.IExecuteYqlRequest=} [properties] Properties to set
             */
            function ExecuteYqlRequest(properties) {
                this.parameters = {};
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ExecuteYqlRequest operationParams.
             * @member {Ydb.Operations.IOperationParams|null|undefined} operationParams
             * @memberof Ydb.Scripting.ExecuteYqlRequest
             * @instance
             */
            ExecuteYqlRequest.prototype.operationParams = null;

            /**
             * ExecuteYqlRequest script.
             * @member {string} script
             * @memberof Ydb.Scripting.ExecuteYqlRequest
             * @instance
             */
            ExecuteYqlRequest.prototype.script = "";

            /**
             * ExecuteYqlRequest parameters.
             * @member {Object.<string,Ydb.ITypedValue>} parameters
             * @memberof Ydb.Scripting.ExecuteYqlRequest
             * @instance
             */
            ExecuteYqlRequest.prototype.parameters = $util.emptyObject;

            /**
             * ExecuteYqlRequest collectStats.
             * @member {Ydb.Table.QueryStatsCollection.Mode} collectStats
             * @memberof Ydb.Scripting.ExecuteYqlRequest
             * @instance
             */
            ExecuteYqlRequest.prototype.collectStats = 0;

            /**
             * Creates a new ExecuteYqlRequest instance using the specified properties.
             * @function create
             * @memberof Ydb.Scripting.ExecuteYqlRequest
             * @static
             * @param {Ydb.Scripting.IExecuteYqlRequest=} [properties] Properties to set
             * @returns {Ydb.Scripting.ExecuteYqlRequest} ExecuteYqlRequest instance
             */
            ExecuteYqlRequest.create = function create(properties) {
                return new ExecuteYqlRequest(properties);
            };

            /**
             * Encodes the specified ExecuteYqlRequest message. Does not implicitly {@link Ydb.Scripting.ExecuteYqlRequest.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Scripting.ExecuteYqlRequest
             * @static
             * @param {Ydb.Scripting.IExecuteYqlRequest} message ExecuteYqlRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExecuteYqlRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.operationParams != null && Object.hasOwnProperty.call(message, "operationParams"))
                    $root.Ydb.Operations.OperationParams.encode(message.operationParams, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.script != null && Object.hasOwnProperty.call(message, "script"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.script);
                if (message.parameters != null && Object.hasOwnProperty.call(message, "parameters"))
                    for (var keys = Object.keys(message.parameters), i = 0; i < keys.length; ++i) {
                        writer.uint32(/* id 3, wireType 2 =*/26).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                        $root.Ydb.TypedValue.encode(message.parameters[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                    }
                if (message.collectStats != null && Object.hasOwnProperty.call(message, "collectStats"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.collectStats);
                return writer;
            };

            /**
             * Encodes the specified ExecuteYqlRequest message, length delimited. Does not implicitly {@link Ydb.Scripting.ExecuteYqlRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Scripting.ExecuteYqlRequest
             * @static
             * @param {Ydb.Scripting.IExecuteYqlRequest} message ExecuteYqlRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExecuteYqlRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ExecuteYqlRequest message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Scripting.ExecuteYqlRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Scripting.ExecuteYqlRequest} ExecuteYqlRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExecuteYqlRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Scripting.ExecuteYqlRequest(), key, value;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.operationParams = $root.Ydb.Operations.OperationParams.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.script = reader.string();
                        break;
                    case 3:
                        if (message.parameters === $util.emptyObject)
                            message.parameters = {};
                        var end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = null;
                        while (reader.pos < end2) {
                            var tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = $root.Ydb.TypedValue.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.parameters[key] = value;
                        break;
                    case 4:
                        message.collectStats = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an ExecuteYqlRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Scripting.ExecuteYqlRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Scripting.ExecuteYqlRequest} ExecuteYqlRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExecuteYqlRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ExecuteYqlRequest message.
             * @function verify
             * @memberof Ydb.Scripting.ExecuteYqlRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ExecuteYqlRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.operationParams != null && message.hasOwnProperty("operationParams")) {
                    var error = $root.Ydb.Operations.OperationParams.verify(message.operationParams);
                    if (error)
                        return "operationParams." + error;
                }
                if (message.script != null && message.hasOwnProperty("script"))
                    if (!$util.isString(message.script))
                        return "script: string expected";
                if (message.parameters != null && message.hasOwnProperty("parameters")) {
                    if (!$util.isObject(message.parameters))
                        return "parameters: object expected";
                    var key = Object.keys(message.parameters);
                    for (var i = 0; i < key.length; ++i) {
                        var error = $root.Ydb.TypedValue.verify(message.parameters[key[i]]);
                        if (error)
                            return "parameters." + error;
                    }
                }
                if (message.collectStats != null && message.hasOwnProperty("collectStats"))
                    switch (message.collectStats) {
                    default:
                        return "collectStats: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                        break;
                    }
                return null;
            };

            /**
             * Creates an ExecuteYqlRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Scripting.ExecuteYqlRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Scripting.ExecuteYqlRequest} ExecuteYqlRequest
             */
            ExecuteYqlRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Scripting.ExecuteYqlRequest)
                    return object;
                var message = new $root.Ydb.Scripting.ExecuteYqlRequest();
                if (object.operationParams != null) {
                    if (typeof object.operationParams !== "object")
                        throw TypeError(".Ydb.Scripting.ExecuteYqlRequest.operationParams: object expected");
                    message.operationParams = $root.Ydb.Operations.OperationParams.fromObject(object.operationParams);
                }
                if (object.script != null)
                    message.script = String(object.script);
                if (object.parameters) {
                    if (typeof object.parameters !== "object")
                        throw TypeError(".Ydb.Scripting.ExecuteYqlRequest.parameters: object expected");
                    message.parameters = {};
                    for (var keys = Object.keys(object.parameters), i = 0; i < keys.length; ++i) {
                        if (typeof object.parameters[keys[i]] !== "object")
                            throw TypeError(".Ydb.Scripting.ExecuteYqlRequest.parameters: object expected");
                        message.parameters[keys[i]] = $root.Ydb.TypedValue.fromObject(object.parameters[keys[i]]);
                    }
                }
                switch (object.collectStats) {
                case "STATS_COLLECTION_UNSPECIFIED":
                case 0:
                    message.collectStats = 0;
                    break;
                case "STATS_COLLECTION_NONE":
                case 1:
                    message.collectStats = 1;
                    break;
                case "STATS_COLLECTION_BASIC":
                case 2:
                    message.collectStats = 2;
                    break;
                case "STATS_COLLECTION_FULL":
                case 3:
                    message.collectStats = 3;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from an ExecuteYqlRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Scripting.ExecuteYqlRequest
             * @static
             * @param {Ydb.Scripting.ExecuteYqlRequest} message ExecuteYqlRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ExecuteYqlRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.objects || options.defaults)
                    object.parameters = {};
                if (options.defaults) {
                    object.operationParams = null;
                    object.script = "";
                    object.collectStats = options.enums === String ? "STATS_COLLECTION_UNSPECIFIED" : 0;
                }
                if (message.operationParams != null && message.hasOwnProperty("operationParams"))
                    object.operationParams = $root.Ydb.Operations.OperationParams.toObject(message.operationParams, options);
                if (message.script != null && message.hasOwnProperty("script"))
                    object.script = message.script;
                var keys2;
                if (message.parameters && (keys2 = Object.keys(message.parameters)).length) {
                    object.parameters = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.parameters[keys2[j]] = $root.Ydb.TypedValue.toObject(message.parameters[keys2[j]], options);
                }
                if (message.collectStats != null && message.hasOwnProperty("collectStats"))
                    object.collectStats = options.enums === String ? $root.Ydb.Table.QueryStatsCollection.Mode[message.collectStats] : message.collectStats;
                return object;
            };

            /**
             * Converts this ExecuteYqlRequest to JSON.
             * @function toJSON
             * @memberof Ydb.Scripting.ExecuteYqlRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ExecuteYqlRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ExecuteYqlRequest;
        })();

        Scripting.ExecuteYqlResponse = (function() {

            /**
             * Properties of an ExecuteYqlResponse.
             * @memberof Ydb.Scripting
             * @interface IExecuteYqlResponse
             * @property {Ydb.Operations.IOperation|null} [operation] ExecuteYqlResponse operation
             */

            /**
             * Constructs a new ExecuteYqlResponse.
             * @memberof Ydb.Scripting
             * @classdesc Represents an ExecuteYqlResponse.
             * @implements IExecuteYqlResponse
             * @constructor
             * @param {Ydb.Scripting.IExecuteYqlResponse=} [properties] Properties to set
             */
            function ExecuteYqlResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ExecuteYqlResponse operation.
             * @member {Ydb.Operations.IOperation|null|undefined} operation
             * @memberof Ydb.Scripting.ExecuteYqlResponse
             * @instance
             */
            ExecuteYqlResponse.prototype.operation = null;

            /**
             * Creates a new ExecuteYqlResponse instance using the specified properties.
             * @function create
             * @memberof Ydb.Scripting.ExecuteYqlResponse
             * @static
             * @param {Ydb.Scripting.IExecuteYqlResponse=} [properties] Properties to set
             * @returns {Ydb.Scripting.ExecuteYqlResponse} ExecuteYqlResponse instance
             */
            ExecuteYqlResponse.create = function create(properties) {
                return new ExecuteYqlResponse(properties);
            };

            /**
             * Encodes the specified ExecuteYqlResponse message. Does not implicitly {@link Ydb.Scripting.ExecuteYqlResponse.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Scripting.ExecuteYqlResponse
             * @static
             * @param {Ydb.Scripting.IExecuteYqlResponse} message ExecuteYqlResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExecuteYqlResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.operation != null && Object.hasOwnProperty.call(message, "operation"))
                    $root.Ydb.Operations.Operation.encode(message.operation, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ExecuteYqlResponse message, length delimited. Does not implicitly {@link Ydb.Scripting.ExecuteYqlResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Scripting.ExecuteYqlResponse
             * @static
             * @param {Ydb.Scripting.IExecuteYqlResponse} message ExecuteYqlResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExecuteYqlResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ExecuteYqlResponse message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Scripting.ExecuteYqlResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Scripting.ExecuteYqlResponse} ExecuteYqlResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExecuteYqlResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Scripting.ExecuteYqlResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.operation = $root.Ydb.Operations.Operation.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an ExecuteYqlResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Scripting.ExecuteYqlResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Scripting.ExecuteYqlResponse} ExecuteYqlResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExecuteYqlResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ExecuteYqlResponse message.
             * @function verify
             * @memberof Ydb.Scripting.ExecuteYqlResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ExecuteYqlResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.operation != null && message.hasOwnProperty("operation")) {
                    var error = $root.Ydb.Operations.Operation.verify(message.operation);
                    if (error)
                        return "operation." + error;
                }
                return null;
            };

            /**
             * Creates an ExecuteYqlResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Scripting.ExecuteYqlResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Scripting.ExecuteYqlResponse} ExecuteYqlResponse
             */
            ExecuteYqlResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Scripting.ExecuteYqlResponse)
                    return object;
                var message = new $root.Ydb.Scripting.ExecuteYqlResponse();
                if (object.operation != null) {
                    if (typeof object.operation !== "object")
                        throw TypeError(".Ydb.Scripting.ExecuteYqlResponse.operation: object expected");
                    message.operation = $root.Ydb.Operations.Operation.fromObject(object.operation);
                }
                return message;
            };

            /**
             * Creates a plain object from an ExecuteYqlResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Scripting.ExecuteYqlResponse
             * @static
             * @param {Ydb.Scripting.ExecuteYqlResponse} message ExecuteYqlResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ExecuteYqlResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.operation = null;
                if (message.operation != null && message.hasOwnProperty("operation"))
                    object.operation = $root.Ydb.Operations.Operation.toObject(message.operation, options);
                return object;
            };

            /**
             * Converts this ExecuteYqlResponse to JSON.
             * @function toJSON
             * @memberof Ydb.Scripting.ExecuteYqlResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ExecuteYqlResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ExecuteYqlResponse;
        })();

        Scripting.ExecuteYqlResult = (function() {

            /**
             * Properties of an ExecuteYqlResult.
             * @memberof Ydb.Scripting
             * @interface IExecuteYqlResult
             * @property {Array.<Ydb.IResultSet>|null} [resultSets] ExecuteYqlResult resultSets
             * @property {Ydb.TableStats.IQueryStats|null} [queryStats] ExecuteYqlResult queryStats
             */

            /**
             * Constructs a new ExecuteYqlResult.
             * @memberof Ydb.Scripting
             * @classdesc Represents an ExecuteYqlResult.
             * @implements IExecuteYqlResult
             * @constructor
             * @param {Ydb.Scripting.IExecuteYqlResult=} [properties] Properties to set
             */
            function ExecuteYqlResult(properties) {
                this.resultSets = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ExecuteYqlResult resultSets.
             * @member {Array.<Ydb.IResultSet>} resultSets
             * @memberof Ydb.Scripting.ExecuteYqlResult
             * @instance
             */
            ExecuteYqlResult.prototype.resultSets = $util.emptyArray;

            /**
             * ExecuteYqlResult queryStats.
             * @member {Ydb.TableStats.IQueryStats|null|undefined} queryStats
             * @memberof Ydb.Scripting.ExecuteYqlResult
             * @instance
             */
            ExecuteYqlResult.prototype.queryStats = null;

            /**
             * Creates a new ExecuteYqlResult instance using the specified properties.
             * @function create
             * @memberof Ydb.Scripting.ExecuteYqlResult
             * @static
             * @param {Ydb.Scripting.IExecuteYqlResult=} [properties] Properties to set
             * @returns {Ydb.Scripting.ExecuteYqlResult} ExecuteYqlResult instance
             */
            ExecuteYqlResult.create = function create(properties) {
                return new ExecuteYqlResult(properties);
            };

            /**
             * Encodes the specified ExecuteYqlResult message. Does not implicitly {@link Ydb.Scripting.ExecuteYqlResult.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Scripting.ExecuteYqlResult
             * @static
             * @param {Ydb.Scripting.IExecuteYqlResult} message ExecuteYqlResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExecuteYqlResult.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.resultSets != null && message.resultSets.length)
                    for (var i = 0; i < message.resultSets.length; ++i)
                        $root.Ydb.ResultSet.encode(message.resultSets[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.queryStats != null && Object.hasOwnProperty.call(message, "queryStats"))
                    $root.Ydb.TableStats.QueryStats.encode(message.queryStats, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ExecuteYqlResult message, length delimited. Does not implicitly {@link Ydb.Scripting.ExecuteYqlResult.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Scripting.ExecuteYqlResult
             * @static
             * @param {Ydb.Scripting.IExecuteYqlResult} message ExecuteYqlResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExecuteYqlResult.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ExecuteYqlResult message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Scripting.ExecuteYqlResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Scripting.ExecuteYqlResult} ExecuteYqlResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExecuteYqlResult.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Scripting.ExecuteYqlResult();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.resultSets && message.resultSets.length))
                            message.resultSets = [];
                        message.resultSets.push($root.Ydb.ResultSet.decode(reader, reader.uint32()));
                        break;
                    case 2:
                        message.queryStats = $root.Ydb.TableStats.QueryStats.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an ExecuteYqlResult message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Scripting.ExecuteYqlResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Scripting.ExecuteYqlResult} ExecuteYqlResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExecuteYqlResult.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ExecuteYqlResult message.
             * @function verify
             * @memberof Ydb.Scripting.ExecuteYqlResult
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ExecuteYqlResult.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.resultSets != null && message.hasOwnProperty("resultSets")) {
                    if (!Array.isArray(message.resultSets))
                        return "resultSets: array expected";
                    for (var i = 0; i < message.resultSets.length; ++i) {
                        var error = $root.Ydb.ResultSet.verify(message.resultSets[i]);
                        if (error)
                            return "resultSets." + error;
                    }
                }
                if (message.queryStats != null && message.hasOwnProperty("queryStats")) {
                    var error = $root.Ydb.TableStats.QueryStats.verify(message.queryStats);
                    if (error)
                        return "queryStats." + error;
                }
                return null;
            };

            /**
             * Creates an ExecuteYqlResult message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Scripting.ExecuteYqlResult
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Scripting.ExecuteYqlResult} ExecuteYqlResult
             */
            ExecuteYqlResult.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Scripting.ExecuteYqlResult)
                    return object;
                var message = new $root.Ydb.Scripting.ExecuteYqlResult();
                if (object.resultSets) {
                    if (!Array.isArray(object.resultSets))
                        throw TypeError(".Ydb.Scripting.ExecuteYqlResult.resultSets: array expected");
                    message.resultSets = [];
                    for (var i = 0; i < object.resultSets.length; ++i) {
                        if (typeof object.resultSets[i] !== "object")
                            throw TypeError(".Ydb.Scripting.ExecuteYqlResult.resultSets: object expected");
                        message.resultSets[i] = $root.Ydb.ResultSet.fromObject(object.resultSets[i]);
                    }
                }
                if (object.queryStats != null) {
                    if (typeof object.queryStats !== "object")
                        throw TypeError(".Ydb.Scripting.ExecuteYqlResult.queryStats: object expected");
                    message.queryStats = $root.Ydb.TableStats.QueryStats.fromObject(object.queryStats);
                }
                return message;
            };

            /**
             * Creates a plain object from an ExecuteYqlResult message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Scripting.ExecuteYqlResult
             * @static
             * @param {Ydb.Scripting.ExecuteYqlResult} message ExecuteYqlResult
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ExecuteYqlResult.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.resultSets = [];
                if (options.defaults)
                    object.queryStats = null;
                if (message.resultSets && message.resultSets.length) {
                    object.resultSets = [];
                    for (var j = 0; j < message.resultSets.length; ++j)
                        object.resultSets[j] = $root.Ydb.ResultSet.toObject(message.resultSets[j], options);
                }
                if (message.queryStats != null && message.hasOwnProperty("queryStats"))
                    object.queryStats = $root.Ydb.TableStats.QueryStats.toObject(message.queryStats, options);
                return object;
            };

            /**
             * Converts this ExecuteYqlResult to JSON.
             * @function toJSON
             * @memberof Ydb.Scripting.ExecuteYqlResult
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ExecuteYqlResult.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ExecuteYqlResult;
        })();

        Scripting.ExecuteYqlPartialResponse = (function() {

            /**
             * Properties of an ExecuteYqlPartialResponse.
             * @memberof Ydb.Scripting
             * @interface IExecuteYqlPartialResponse
             * @property {Ydb.StatusIds.StatusCode|null} [status] ExecuteYqlPartialResponse status
             * @property {Array.<Ydb.Issue.IIssueMessage>|null} [issues] ExecuteYqlPartialResponse issues
             * @property {Ydb.Scripting.IExecuteYqlPartialResult|null} [result] ExecuteYqlPartialResponse result
             */

            /**
             * Constructs a new ExecuteYqlPartialResponse.
             * @memberof Ydb.Scripting
             * @classdesc Represents an ExecuteYqlPartialResponse.
             * @implements IExecuteYqlPartialResponse
             * @constructor
             * @param {Ydb.Scripting.IExecuteYqlPartialResponse=} [properties] Properties to set
             */
            function ExecuteYqlPartialResponse(properties) {
                this.issues = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ExecuteYqlPartialResponse status.
             * @member {Ydb.StatusIds.StatusCode} status
             * @memberof Ydb.Scripting.ExecuteYqlPartialResponse
             * @instance
             */
            ExecuteYqlPartialResponse.prototype.status = 0;

            /**
             * ExecuteYqlPartialResponse issues.
             * @member {Array.<Ydb.Issue.IIssueMessage>} issues
             * @memberof Ydb.Scripting.ExecuteYqlPartialResponse
             * @instance
             */
            ExecuteYqlPartialResponse.prototype.issues = $util.emptyArray;

            /**
             * ExecuteYqlPartialResponse result.
             * @member {Ydb.Scripting.IExecuteYqlPartialResult|null|undefined} result
             * @memberof Ydb.Scripting.ExecuteYqlPartialResponse
             * @instance
             */
            ExecuteYqlPartialResponse.prototype.result = null;

            /**
             * Creates a new ExecuteYqlPartialResponse instance using the specified properties.
             * @function create
             * @memberof Ydb.Scripting.ExecuteYqlPartialResponse
             * @static
             * @param {Ydb.Scripting.IExecuteYqlPartialResponse=} [properties] Properties to set
             * @returns {Ydb.Scripting.ExecuteYqlPartialResponse} ExecuteYqlPartialResponse instance
             */
            ExecuteYqlPartialResponse.create = function create(properties) {
                return new ExecuteYqlPartialResponse(properties);
            };

            /**
             * Encodes the specified ExecuteYqlPartialResponse message. Does not implicitly {@link Ydb.Scripting.ExecuteYqlPartialResponse.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Scripting.ExecuteYqlPartialResponse
             * @static
             * @param {Ydb.Scripting.IExecuteYqlPartialResponse} message ExecuteYqlPartialResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExecuteYqlPartialResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.status);
                if (message.issues != null && message.issues.length)
                    for (var i = 0; i < message.issues.length; ++i)
                        $root.Ydb.Issue.IssueMessage.encode(message.issues[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.result != null && Object.hasOwnProperty.call(message, "result"))
                    $root.Ydb.Scripting.ExecuteYqlPartialResult.encode(message.result, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ExecuteYqlPartialResponse message, length delimited. Does not implicitly {@link Ydb.Scripting.ExecuteYqlPartialResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Scripting.ExecuteYqlPartialResponse
             * @static
             * @param {Ydb.Scripting.IExecuteYqlPartialResponse} message ExecuteYqlPartialResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExecuteYqlPartialResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ExecuteYqlPartialResponse message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Scripting.ExecuteYqlPartialResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Scripting.ExecuteYqlPartialResponse} ExecuteYqlPartialResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExecuteYqlPartialResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Scripting.ExecuteYqlPartialResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.status = reader.int32();
                        break;
                    case 2:
                        if (!(message.issues && message.issues.length))
                            message.issues = [];
                        message.issues.push($root.Ydb.Issue.IssueMessage.decode(reader, reader.uint32()));
                        break;
                    case 3:
                        message.result = $root.Ydb.Scripting.ExecuteYqlPartialResult.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an ExecuteYqlPartialResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Scripting.ExecuteYqlPartialResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Scripting.ExecuteYqlPartialResponse} ExecuteYqlPartialResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExecuteYqlPartialResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ExecuteYqlPartialResponse message.
             * @function verify
             * @memberof Ydb.Scripting.ExecuteYqlPartialResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ExecuteYqlPartialResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.status != null && message.hasOwnProperty("status"))
                    switch (message.status) {
                    default:
                        return "status: enum value expected";
                    case 0:
                    case 400000:
                    case 400010:
                    case 400020:
                    case 400030:
                    case 400040:
                    case 400050:
                    case 400060:
                    case 400070:
                    case 400080:
                    case 400090:
                    case 400100:
                    case 400120:
                    case 400130:
                    case 400140:
                    case 400150:
                    case 400160:
                    case 400170:
                    case 400180:
                    case 400190:
                        break;
                    }
                if (message.issues != null && message.hasOwnProperty("issues")) {
                    if (!Array.isArray(message.issues))
                        return "issues: array expected";
                    for (var i = 0; i < message.issues.length; ++i) {
                        var error = $root.Ydb.Issue.IssueMessage.verify(message.issues[i]);
                        if (error)
                            return "issues." + error;
                    }
                }
                if (message.result != null && message.hasOwnProperty("result")) {
                    var error = $root.Ydb.Scripting.ExecuteYqlPartialResult.verify(message.result);
                    if (error)
                        return "result." + error;
                }
                return null;
            };

            /**
             * Creates an ExecuteYqlPartialResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Scripting.ExecuteYqlPartialResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Scripting.ExecuteYqlPartialResponse} ExecuteYqlPartialResponse
             */
            ExecuteYqlPartialResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Scripting.ExecuteYqlPartialResponse)
                    return object;
                var message = new $root.Ydb.Scripting.ExecuteYqlPartialResponse();
                switch (object.status) {
                case "STATUS_CODE_UNSPECIFIED":
                case 0:
                    message.status = 0;
                    break;
                case "SUCCESS":
                case 400000:
                    message.status = 400000;
                    break;
                case "BAD_REQUEST":
                case 400010:
                    message.status = 400010;
                    break;
                case "UNAUTHORIZED":
                case 400020:
                    message.status = 400020;
                    break;
                case "INTERNAL_ERROR":
                case 400030:
                    message.status = 400030;
                    break;
                case "ABORTED":
                case 400040:
                    message.status = 400040;
                    break;
                case "UNAVAILABLE":
                case 400050:
                    message.status = 400050;
                    break;
                case "OVERLOADED":
                case 400060:
                    message.status = 400060;
                    break;
                case "SCHEME_ERROR":
                case 400070:
                    message.status = 400070;
                    break;
                case "GENERIC_ERROR":
                case 400080:
                    message.status = 400080;
                    break;
                case "TIMEOUT":
                case 400090:
                    message.status = 400090;
                    break;
                case "BAD_SESSION":
                case 400100:
                    message.status = 400100;
                    break;
                case "PRECONDITION_FAILED":
                case 400120:
                    message.status = 400120;
                    break;
                case "ALREADY_EXISTS":
                case 400130:
                    message.status = 400130;
                    break;
                case "NOT_FOUND":
                case 400140:
                    message.status = 400140;
                    break;
                case "SESSION_EXPIRED":
                case 400150:
                    message.status = 400150;
                    break;
                case "CANCELLED":
                case 400160:
                    message.status = 400160;
                    break;
                case "UNDETERMINED":
                case 400170:
                    message.status = 400170;
                    break;
                case "UNSUPPORTED":
                case 400180:
                    message.status = 400180;
                    break;
                case "SESSION_BUSY":
                case 400190:
                    message.status = 400190;
                    break;
                }
                if (object.issues) {
                    if (!Array.isArray(object.issues))
                        throw TypeError(".Ydb.Scripting.ExecuteYqlPartialResponse.issues: array expected");
                    message.issues = [];
                    for (var i = 0; i < object.issues.length; ++i) {
                        if (typeof object.issues[i] !== "object")
                            throw TypeError(".Ydb.Scripting.ExecuteYqlPartialResponse.issues: object expected");
                        message.issues[i] = $root.Ydb.Issue.IssueMessage.fromObject(object.issues[i]);
                    }
                }
                if (object.result != null) {
                    if (typeof object.result !== "object")
                        throw TypeError(".Ydb.Scripting.ExecuteYqlPartialResponse.result: object expected");
                    message.result = $root.Ydb.Scripting.ExecuteYqlPartialResult.fromObject(object.result);
                }
                return message;
            };

            /**
             * Creates a plain object from an ExecuteYqlPartialResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Scripting.ExecuteYqlPartialResponse
             * @static
             * @param {Ydb.Scripting.ExecuteYqlPartialResponse} message ExecuteYqlPartialResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ExecuteYqlPartialResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.issues = [];
                if (options.defaults) {
                    object.status = options.enums === String ? "STATUS_CODE_UNSPECIFIED" : 0;
                    object.result = null;
                }
                if (message.status != null && message.hasOwnProperty("status"))
                    object.status = options.enums === String ? $root.Ydb.StatusIds.StatusCode[message.status] : message.status;
                if (message.issues && message.issues.length) {
                    object.issues = [];
                    for (var j = 0; j < message.issues.length; ++j)
                        object.issues[j] = $root.Ydb.Issue.IssueMessage.toObject(message.issues[j], options);
                }
                if (message.result != null && message.hasOwnProperty("result"))
                    object.result = $root.Ydb.Scripting.ExecuteYqlPartialResult.toObject(message.result, options);
                return object;
            };

            /**
             * Converts this ExecuteYqlPartialResponse to JSON.
             * @function toJSON
             * @memberof Ydb.Scripting.ExecuteYqlPartialResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ExecuteYqlPartialResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ExecuteYqlPartialResponse;
        })();

        Scripting.ExecuteYqlPartialResult = (function() {

            /**
             * Properties of an ExecuteYqlPartialResult.
             * @memberof Ydb.Scripting
             * @interface IExecuteYqlPartialResult
             * @property {number|null} [resultSetIndex] ExecuteYqlPartialResult resultSetIndex
             * @property {Ydb.IResultSet|null} [resultSet] ExecuteYqlPartialResult resultSet
             * @property {Ydb.TableStats.IQueryStats|null} [queryStats] ExecuteYqlPartialResult queryStats
             */

            /**
             * Constructs a new ExecuteYqlPartialResult.
             * @memberof Ydb.Scripting
             * @classdesc Represents an ExecuteYqlPartialResult.
             * @implements IExecuteYqlPartialResult
             * @constructor
             * @param {Ydb.Scripting.IExecuteYqlPartialResult=} [properties] Properties to set
             */
            function ExecuteYqlPartialResult(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ExecuteYqlPartialResult resultSetIndex.
             * @member {number} resultSetIndex
             * @memberof Ydb.Scripting.ExecuteYqlPartialResult
             * @instance
             */
            ExecuteYqlPartialResult.prototype.resultSetIndex = 0;

            /**
             * ExecuteYqlPartialResult resultSet.
             * @member {Ydb.IResultSet|null|undefined} resultSet
             * @memberof Ydb.Scripting.ExecuteYqlPartialResult
             * @instance
             */
            ExecuteYqlPartialResult.prototype.resultSet = null;

            /**
             * ExecuteYqlPartialResult queryStats.
             * @member {Ydb.TableStats.IQueryStats|null|undefined} queryStats
             * @memberof Ydb.Scripting.ExecuteYqlPartialResult
             * @instance
             */
            ExecuteYqlPartialResult.prototype.queryStats = null;

            /**
             * Creates a new ExecuteYqlPartialResult instance using the specified properties.
             * @function create
             * @memberof Ydb.Scripting.ExecuteYqlPartialResult
             * @static
             * @param {Ydb.Scripting.IExecuteYqlPartialResult=} [properties] Properties to set
             * @returns {Ydb.Scripting.ExecuteYqlPartialResult} ExecuteYqlPartialResult instance
             */
            ExecuteYqlPartialResult.create = function create(properties) {
                return new ExecuteYqlPartialResult(properties);
            };

            /**
             * Encodes the specified ExecuteYqlPartialResult message. Does not implicitly {@link Ydb.Scripting.ExecuteYqlPartialResult.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Scripting.ExecuteYqlPartialResult
             * @static
             * @param {Ydb.Scripting.IExecuteYqlPartialResult} message ExecuteYqlPartialResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExecuteYqlPartialResult.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.resultSetIndex != null && Object.hasOwnProperty.call(message, "resultSetIndex"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.resultSetIndex);
                if (message.resultSet != null && Object.hasOwnProperty.call(message, "resultSet"))
                    $root.Ydb.ResultSet.encode(message.resultSet, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.queryStats != null && Object.hasOwnProperty.call(message, "queryStats"))
                    $root.Ydb.TableStats.QueryStats.encode(message.queryStats, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ExecuteYqlPartialResult message, length delimited. Does not implicitly {@link Ydb.Scripting.ExecuteYqlPartialResult.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Scripting.ExecuteYqlPartialResult
             * @static
             * @param {Ydb.Scripting.IExecuteYqlPartialResult} message ExecuteYqlPartialResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExecuteYqlPartialResult.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ExecuteYqlPartialResult message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Scripting.ExecuteYqlPartialResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Scripting.ExecuteYqlPartialResult} ExecuteYqlPartialResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExecuteYqlPartialResult.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Scripting.ExecuteYqlPartialResult();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.resultSetIndex = reader.uint32();
                        break;
                    case 2:
                        message.resultSet = $root.Ydb.ResultSet.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.queryStats = $root.Ydb.TableStats.QueryStats.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an ExecuteYqlPartialResult message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Scripting.ExecuteYqlPartialResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Scripting.ExecuteYqlPartialResult} ExecuteYqlPartialResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExecuteYqlPartialResult.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ExecuteYqlPartialResult message.
             * @function verify
             * @memberof Ydb.Scripting.ExecuteYqlPartialResult
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ExecuteYqlPartialResult.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.resultSetIndex != null && message.hasOwnProperty("resultSetIndex"))
                    if (!$util.isInteger(message.resultSetIndex))
                        return "resultSetIndex: integer expected";
                if (message.resultSet != null && message.hasOwnProperty("resultSet")) {
                    var error = $root.Ydb.ResultSet.verify(message.resultSet);
                    if (error)
                        return "resultSet." + error;
                }
                if (message.queryStats != null && message.hasOwnProperty("queryStats")) {
                    var error = $root.Ydb.TableStats.QueryStats.verify(message.queryStats);
                    if (error)
                        return "queryStats." + error;
                }
                return null;
            };

            /**
             * Creates an ExecuteYqlPartialResult message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Scripting.ExecuteYqlPartialResult
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Scripting.ExecuteYqlPartialResult} ExecuteYqlPartialResult
             */
            ExecuteYqlPartialResult.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Scripting.ExecuteYqlPartialResult)
                    return object;
                var message = new $root.Ydb.Scripting.ExecuteYqlPartialResult();
                if (object.resultSetIndex != null)
                    message.resultSetIndex = object.resultSetIndex >>> 0;
                if (object.resultSet != null) {
                    if (typeof object.resultSet !== "object")
                        throw TypeError(".Ydb.Scripting.ExecuteYqlPartialResult.resultSet: object expected");
                    message.resultSet = $root.Ydb.ResultSet.fromObject(object.resultSet);
                }
                if (object.queryStats != null) {
                    if (typeof object.queryStats !== "object")
                        throw TypeError(".Ydb.Scripting.ExecuteYqlPartialResult.queryStats: object expected");
                    message.queryStats = $root.Ydb.TableStats.QueryStats.fromObject(object.queryStats);
                }
                return message;
            };

            /**
             * Creates a plain object from an ExecuteYqlPartialResult message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Scripting.ExecuteYqlPartialResult
             * @static
             * @param {Ydb.Scripting.ExecuteYqlPartialResult} message ExecuteYqlPartialResult
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ExecuteYqlPartialResult.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.resultSetIndex = 0;
                    object.resultSet = null;
                    object.queryStats = null;
                }
                if (message.resultSetIndex != null && message.hasOwnProperty("resultSetIndex"))
                    object.resultSetIndex = message.resultSetIndex;
                if (message.resultSet != null && message.hasOwnProperty("resultSet"))
                    object.resultSet = $root.Ydb.ResultSet.toObject(message.resultSet, options);
                if (message.queryStats != null && message.hasOwnProperty("queryStats"))
                    object.queryStats = $root.Ydb.TableStats.QueryStats.toObject(message.queryStats, options);
                return object;
            };

            /**
             * Converts this ExecuteYqlPartialResult to JSON.
             * @function toJSON
             * @memberof Ydb.Scripting.ExecuteYqlPartialResult
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ExecuteYqlPartialResult.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ExecuteYqlPartialResult;
        })();

        Scripting.ExplainYqlRequest = (function() {

            /**
             * Properties of an ExplainYqlRequest.
             * @memberof Ydb.Scripting
             * @interface IExplainYqlRequest
             * @property {Ydb.Operations.IOperationParams|null} [operationParams] ExplainYqlRequest operationParams
             * @property {string|null} [script] ExplainYqlRequest script
             * @property {Ydb.Scripting.ExplainYqlRequest.Mode|null} [mode] ExplainYqlRequest mode
             */

            /**
             * Constructs a new ExplainYqlRequest.
             * @memberof Ydb.Scripting
             * @classdesc Represents an ExplainYqlRequest.
             * @implements IExplainYqlRequest
             * @constructor
             * @param {Ydb.Scripting.IExplainYqlRequest=} [properties] Properties to set
             */
            function ExplainYqlRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ExplainYqlRequest operationParams.
             * @member {Ydb.Operations.IOperationParams|null|undefined} operationParams
             * @memberof Ydb.Scripting.ExplainYqlRequest
             * @instance
             */
            ExplainYqlRequest.prototype.operationParams = null;

            /**
             * ExplainYqlRequest script.
             * @member {string} script
             * @memberof Ydb.Scripting.ExplainYqlRequest
             * @instance
             */
            ExplainYqlRequest.prototype.script = "";

            /**
             * ExplainYqlRequest mode.
             * @member {Ydb.Scripting.ExplainYqlRequest.Mode} mode
             * @memberof Ydb.Scripting.ExplainYqlRequest
             * @instance
             */
            ExplainYqlRequest.prototype.mode = 0;

            /**
             * Creates a new ExplainYqlRequest instance using the specified properties.
             * @function create
             * @memberof Ydb.Scripting.ExplainYqlRequest
             * @static
             * @param {Ydb.Scripting.IExplainYqlRequest=} [properties] Properties to set
             * @returns {Ydb.Scripting.ExplainYqlRequest} ExplainYqlRequest instance
             */
            ExplainYqlRequest.create = function create(properties) {
                return new ExplainYqlRequest(properties);
            };

            /**
             * Encodes the specified ExplainYqlRequest message. Does not implicitly {@link Ydb.Scripting.ExplainYqlRequest.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Scripting.ExplainYqlRequest
             * @static
             * @param {Ydb.Scripting.IExplainYqlRequest} message ExplainYqlRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExplainYqlRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.operationParams != null && Object.hasOwnProperty.call(message, "operationParams"))
                    $root.Ydb.Operations.OperationParams.encode(message.operationParams, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.script != null && Object.hasOwnProperty.call(message, "script"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.script);
                if (message.mode != null && Object.hasOwnProperty.call(message, "mode"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.mode);
                return writer;
            };

            /**
             * Encodes the specified ExplainYqlRequest message, length delimited. Does not implicitly {@link Ydb.Scripting.ExplainYqlRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Scripting.ExplainYqlRequest
             * @static
             * @param {Ydb.Scripting.IExplainYqlRequest} message ExplainYqlRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExplainYqlRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ExplainYqlRequest message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Scripting.ExplainYqlRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Scripting.ExplainYqlRequest} ExplainYqlRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExplainYqlRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Scripting.ExplainYqlRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.operationParams = $root.Ydb.Operations.OperationParams.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.script = reader.string();
                        break;
                    case 3:
                        message.mode = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an ExplainYqlRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Scripting.ExplainYqlRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Scripting.ExplainYqlRequest} ExplainYqlRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExplainYqlRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ExplainYqlRequest message.
             * @function verify
             * @memberof Ydb.Scripting.ExplainYqlRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ExplainYqlRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.operationParams != null && message.hasOwnProperty("operationParams")) {
                    var error = $root.Ydb.Operations.OperationParams.verify(message.operationParams);
                    if (error)
                        return "operationParams." + error;
                }
                if (message.script != null && message.hasOwnProperty("script"))
                    if (!$util.isString(message.script))
                        return "script: string expected";
                if (message.mode != null && message.hasOwnProperty("mode"))
                    switch (message.mode) {
                    default:
                        return "mode: enum value expected";
                    case 0:
                    case 2:
                    case 3:
                        break;
                    }
                return null;
            };

            /**
             * Creates an ExplainYqlRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Scripting.ExplainYqlRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Scripting.ExplainYqlRequest} ExplainYqlRequest
             */
            ExplainYqlRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Scripting.ExplainYqlRequest)
                    return object;
                var message = new $root.Ydb.Scripting.ExplainYqlRequest();
                if (object.operationParams != null) {
                    if (typeof object.operationParams !== "object")
                        throw TypeError(".Ydb.Scripting.ExplainYqlRequest.operationParams: object expected");
                    message.operationParams = $root.Ydb.Operations.OperationParams.fromObject(object.operationParams);
                }
                if (object.script != null)
                    message.script = String(object.script);
                switch (object.mode) {
                case "MODE_UNSPECIFIED":
                case 0:
                    message.mode = 0;
                    break;
                case "VALIDATE":
                case 2:
                    message.mode = 2;
                    break;
                case "PLAN":
                case 3:
                    message.mode = 3;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from an ExplainYqlRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Scripting.ExplainYqlRequest
             * @static
             * @param {Ydb.Scripting.ExplainYqlRequest} message ExplainYqlRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ExplainYqlRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.operationParams = null;
                    object.script = "";
                    object.mode = options.enums === String ? "MODE_UNSPECIFIED" : 0;
                }
                if (message.operationParams != null && message.hasOwnProperty("operationParams"))
                    object.operationParams = $root.Ydb.Operations.OperationParams.toObject(message.operationParams, options);
                if (message.script != null && message.hasOwnProperty("script"))
                    object.script = message.script;
                if (message.mode != null && message.hasOwnProperty("mode"))
                    object.mode = options.enums === String ? $root.Ydb.Scripting.ExplainYqlRequest.Mode[message.mode] : message.mode;
                return object;
            };

            /**
             * Converts this ExplainYqlRequest to JSON.
             * @function toJSON
             * @memberof Ydb.Scripting.ExplainYqlRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ExplainYqlRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Mode enum.
             * @name Ydb.Scripting.ExplainYqlRequest.Mode
             * @enum {number}
             * @property {number} MODE_UNSPECIFIED=0 MODE_UNSPECIFIED value
             * @property {number} VALIDATE=2 VALIDATE value
             * @property {number} PLAN=3 PLAN value
             */
            ExplainYqlRequest.Mode = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "MODE_UNSPECIFIED"] = 0;
                values[valuesById[2] = "VALIDATE"] = 2;
                values[valuesById[3] = "PLAN"] = 3;
                return values;
            })();

            return ExplainYqlRequest;
        })();

        Scripting.ExplainYqlResponse = (function() {

            /**
             * Properties of an ExplainYqlResponse.
             * @memberof Ydb.Scripting
             * @interface IExplainYqlResponse
             * @property {Ydb.Operations.IOperation|null} [operation] ExplainYqlResponse operation
             */

            /**
             * Constructs a new ExplainYqlResponse.
             * @memberof Ydb.Scripting
             * @classdesc Represents an ExplainYqlResponse.
             * @implements IExplainYqlResponse
             * @constructor
             * @param {Ydb.Scripting.IExplainYqlResponse=} [properties] Properties to set
             */
            function ExplainYqlResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ExplainYqlResponse operation.
             * @member {Ydb.Operations.IOperation|null|undefined} operation
             * @memberof Ydb.Scripting.ExplainYqlResponse
             * @instance
             */
            ExplainYqlResponse.prototype.operation = null;

            /**
             * Creates a new ExplainYqlResponse instance using the specified properties.
             * @function create
             * @memberof Ydb.Scripting.ExplainYqlResponse
             * @static
             * @param {Ydb.Scripting.IExplainYqlResponse=} [properties] Properties to set
             * @returns {Ydb.Scripting.ExplainYqlResponse} ExplainYqlResponse instance
             */
            ExplainYqlResponse.create = function create(properties) {
                return new ExplainYqlResponse(properties);
            };

            /**
             * Encodes the specified ExplainYqlResponse message. Does not implicitly {@link Ydb.Scripting.ExplainYqlResponse.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Scripting.ExplainYqlResponse
             * @static
             * @param {Ydb.Scripting.IExplainYqlResponse} message ExplainYqlResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExplainYqlResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.operation != null && Object.hasOwnProperty.call(message, "operation"))
                    $root.Ydb.Operations.Operation.encode(message.operation, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ExplainYqlResponse message, length delimited. Does not implicitly {@link Ydb.Scripting.ExplainYqlResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Scripting.ExplainYqlResponse
             * @static
             * @param {Ydb.Scripting.IExplainYqlResponse} message ExplainYqlResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExplainYqlResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ExplainYqlResponse message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Scripting.ExplainYqlResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Scripting.ExplainYqlResponse} ExplainYqlResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExplainYqlResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Scripting.ExplainYqlResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.operation = $root.Ydb.Operations.Operation.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an ExplainYqlResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Scripting.ExplainYqlResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Scripting.ExplainYqlResponse} ExplainYqlResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExplainYqlResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ExplainYqlResponse message.
             * @function verify
             * @memberof Ydb.Scripting.ExplainYqlResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ExplainYqlResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.operation != null && message.hasOwnProperty("operation")) {
                    var error = $root.Ydb.Operations.Operation.verify(message.operation);
                    if (error)
                        return "operation." + error;
                }
                return null;
            };

            /**
             * Creates an ExplainYqlResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Scripting.ExplainYqlResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Scripting.ExplainYqlResponse} ExplainYqlResponse
             */
            ExplainYqlResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Scripting.ExplainYqlResponse)
                    return object;
                var message = new $root.Ydb.Scripting.ExplainYqlResponse();
                if (object.operation != null) {
                    if (typeof object.operation !== "object")
                        throw TypeError(".Ydb.Scripting.ExplainYqlResponse.operation: object expected");
                    message.operation = $root.Ydb.Operations.Operation.fromObject(object.operation);
                }
                return message;
            };

            /**
             * Creates a plain object from an ExplainYqlResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Scripting.ExplainYqlResponse
             * @static
             * @param {Ydb.Scripting.ExplainYqlResponse} message ExplainYqlResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ExplainYqlResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.operation = null;
                if (message.operation != null && message.hasOwnProperty("operation"))
                    object.operation = $root.Ydb.Operations.Operation.toObject(message.operation, options);
                return object;
            };

            /**
             * Converts this ExplainYqlResponse to JSON.
             * @function toJSON
             * @memberof Ydb.Scripting.ExplainYqlResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ExplainYqlResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ExplainYqlResponse;
        })();

        Scripting.ExplainYqlResult = (function() {

            /**
             * Properties of an ExplainYqlResult.
             * @memberof Ydb.Scripting
             * @interface IExplainYqlResult
             * @property {Object.<string,Ydb.IType>|null} [parametersTypes] ExplainYqlResult parametersTypes
             * @property {string|null} [plan] ExplainYqlResult plan
             */

            /**
             * Constructs a new ExplainYqlResult.
             * @memberof Ydb.Scripting
             * @classdesc Represents an ExplainYqlResult.
             * @implements IExplainYqlResult
             * @constructor
             * @param {Ydb.Scripting.IExplainYqlResult=} [properties] Properties to set
             */
            function ExplainYqlResult(properties) {
                this.parametersTypes = {};
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ExplainYqlResult parametersTypes.
             * @member {Object.<string,Ydb.IType>} parametersTypes
             * @memberof Ydb.Scripting.ExplainYqlResult
             * @instance
             */
            ExplainYqlResult.prototype.parametersTypes = $util.emptyObject;

            /**
             * ExplainYqlResult plan.
             * @member {string} plan
             * @memberof Ydb.Scripting.ExplainYqlResult
             * @instance
             */
            ExplainYqlResult.prototype.plan = "";

            /**
             * Creates a new ExplainYqlResult instance using the specified properties.
             * @function create
             * @memberof Ydb.Scripting.ExplainYqlResult
             * @static
             * @param {Ydb.Scripting.IExplainYqlResult=} [properties] Properties to set
             * @returns {Ydb.Scripting.ExplainYqlResult} ExplainYqlResult instance
             */
            ExplainYqlResult.create = function create(properties) {
                return new ExplainYqlResult(properties);
            };

            /**
             * Encodes the specified ExplainYqlResult message. Does not implicitly {@link Ydb.Scripting.ExplainYqlResult.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Scripting.ExplainYqlResult
             * @static
             * @param {Ydb.Scripting.IExplainYqlResult} message ExplainYqlResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExplainYqlResult.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.parametersTypes != null && Object.hasOwnProperty.call(message, "parametersTypes"))
                    for (var keys = Object.keys(message.parametersTypes), i = 0; i < keys.length; ++i) {
                        writer.uint32(/* id 1, wireType 2 =*/10).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                        $root.Ydb.Type.encode(message.parametersTypes[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                    }
                if (message.plan != null && Object.hasOwnProperty.call(message, "plan"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.plan);
                return writer;
            };

            /**
             * Encodes the specified ExplainYqlResult message, length delimited. Does not implicitly {@link Ydb.Scripting.ExplainYqlResult.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Scripting.ExplainYqlResult
             * @static
             * @param {Ydb.Scripting.IExplainYqlResult} message ExplainYqlResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExplainYqlResult.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ExplainYqlResult message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Scripting.ExplainYqlResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Scripting.ExplainYqlResult} ExplainYqlResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExplainYqlResult.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Scripting.ExplainYqlResult(), key, value;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (message.parametersTypes === $util.emptyObject)
                            message.parametersTypes = {};
                        var end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = null;
                        while (reader.pos < end2) {
                            var tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = $root.Ydb.Type.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.parametersTypes[key] = value;
                        break;
                    case 2:
                        message.plan = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an ExplainYqlResult message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Scripting.ExplainYqlResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Scripting.ExplainYqlResult} ExplainYqlResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExplainYqlResult.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ExplainYqlResult message.
             * @function verify
             * @memberof Ydb.Scripting.ExplainYqlResult
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ExplainYqlResult.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.parametersTypes != null && message.hasOwnProperty("parametersTypes")) {
                    if (!$util.isObject(message.parametersTypes))
                        return "parametersTypes: object expected";
                    var key = Object.keys(message.parametersTypes);
                    for (var i = 0; i < key.length; ++i) {
                        var error = $root.Ydb.Type.verify(message.parametersTypes[key[i]]);
                        if (error)
                            return "parametersTypes." + error;
                    }
                }
                if (message.plan != null && message.hasOwnProperty("plan"))
                    if (!$util.isString(message.plan))
                        return "plan: string expected";
                return null;
            };

            /**
             * Creates an ExplainYqlResult message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Scripting.ExplainYqlResult
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Scripting.ExplainYqlResult} ExplainYqlResult
             */
            ExplainYqlResult.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Scripting.ExplainYqlResult)
                    return object;
                var message = new $root.Ydb.Scripting.ExplainYqlResult();
                if (object.parametersTypes) {
                    if (typeof object.parametersTypes !== "object")
                        throw TypeError(".Ydb.Scripting.ExplainYqlResult.parametersTypes: object expected");
                    message.parametersTypes = {};
                    for (var keys = Object.keys(object.parametersTypes), i = 0; i < keys.length; ++i) {
                        if (typeof object.parametersTypes[keys[i]] !== "object")
                            throw TypeError(".Ydb.Scripting.ExplainYqlResult.parametersTypes: object expected");
                        message.parametersTypes[keys[i]] = $root.Ydb.Type.fromObject(object.parametersTypes[keys[i]]);
                    }
                }
                if (object.plan != null)
                    message.plan = String(object.plan);
                return message;
            };

            /**
             * Creates a plain object from an ExplainYqlResult message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Scripting.ExplainYqlResult
             * @static
             * @param {Ydb.Scripting.ExplainYqlResult} message ExplainYqlResult
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ExplainYqlResult.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.objects || options.defaults)
                    object.parametersTypes = {};
                if (options.defaults)
                    object.plan = "";
                var keys2;
                if (message.parametersTypes && (keys2 = Object.keys(message.parametersTypes)).length) {
                    object.parametersTypes = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.parametersTypes[keys2[j]] = $root.Ydb.Type.toObject(message.parametersTypes[keys2[j]], options);
                }
                if (message.plan != null && message.hasOwnProperty("plan"))
                    object.plan = message.plan;
                return object;
            };

            /**
             * Converts this ExplainYqlResult to JSON.
             * @function toJSON
             * @memberof Ydb.Scripting.ExplainYqlResult
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ExplainYqlResult.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ExplainYqlResult;
        })();

        return Scripting;
    })();

    Ydb.Discovery = (function() {

        /**
         * Namespace Discovery.
         * @memberof Ydb
         * @namespace
         */
        var Discovery = {};

        Discovery.V1 = (function() {

            /**
             * Namespace V1.
             * @memberof Ydb.Discovery
             * @namespace
             */
            var V1 = {};

            V1.DiscoveryService = (function() {

                /**
                 * Constructs a new DiscoveryService service.
                 * @memberof Ydb.Discovery.V1
                 * @classdesc Represents a DiscoveryService
                 * @extends $protobuf.rpc.Service
                 * @constructor
                 * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                 */
                function DiscoveryService(rpcImpl, requestDelimited, responseDelimited) {
                    $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
                }

                (DiscoveryService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = DiscoveryService;

                /**
                 * Creates new DiscoveryService service using the specified rpc implementation.
                 * @function create
                 * @memberof Ydb.Discovery.V1.DiscoveryService
                 * @static
                 * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                 * @returns {DiscoveryService} RPC service. Useful where requests and/or responses are streamed.
                 */
                DiscoveryService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                    return new this(rpcImpl, requestDelimited, responseDelimited);
                };

                /**
                 * Callback as used by {@link Ydb.Discovery.V1.DiscoveryService#listEndpoints}.
                 * @memberof Ydb.Discovery.V1.DiscoveryService
                 * @typedef ListEndpointsCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {Ydb.Discovery.ListEndpointsResponse} [response] ListEndpointsResponse
                 */

                /**
                 * Calls ListEndpoints.
                 * @function listEndpoints
                 * @memberof Ydb.Discovery.V1.DiscoveryService
                 * @instance
                 * @param {Ydb.Discovery.IListEndpointsRequest} request ListEndpointsRequest message or plain object
                 * @param {Ydb.Discovery.V1.DiscoveryService.ListEndpointsCallback} callback Node-style callback called with the error, if any, and ListEndpointsResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(DiscoveryService.prototype.listEndpoints = function listEndpoints(request, callback) {
                    return this.rpcCall(listEndpoints, $root.Ydb.Discovery.ListEndpointsRequest, $root.Ydb.Discovery.ListEndpointsResponse, request, callback);
                }, "name", { value: "ListEndpoints" });

                /**
                 * Calls ListEndpoints.
                 * @function listEndpoints
                 * @memberof Ydb.Discovery.V1.DiscoveryService
                 * @instance
                 * @param {Ydb.Discovery.IListEndpointsRequest} request ListEndpointsRequest message or plain object
                 * @returns {Promise<Ydb.Discovery.ListEndpointsResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link Ydb.Discovery.V1.DiscoveryService#whoAmI}.
                 * @memberof Ydb.Discovery.V1.DiscoveryService
                 * @typedef WhoAmICallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {Ydb.Discovery.WhoAmIResponse} [response] WhoAmIResponse
                 */

                /**
                 * Calls WhoAmI.
                 * @function whoAmI
                 * @memberof Ydb.Discovery.V1.DiscoveryService
                 * @instance
                 * @param {Ydb.Discovery.IWhoAmIRequest} request WhoAmIRequest message or plain object
                 * @param {Ydb.Discovery.V1.DiscoveryService.WhoAmICallback} callback Node-style callback called with the error, if any, and WhoAmIResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(DiscoveryService.prototype.whoAmI = function whoAmI(request, callback) {
                    return this.rpcCall(whoAmI, $root.Ydb.Discovery.WhoAmIRequest, $root.Ydb.Discovery.WhoAmIResponse, request, callback);
                }, "name", { value: "WhoAmI" });

                /**
                 * Calls WhoAmI.
                 * @function whoAmI
                 * @memberof Ydb.Discovery.V1.DiscoveryService
                 * @instance
                 * @param {Ydb.Discovery.IWhoAmIRequest} request WhoAmIRequest message or plain object
                 * @returns {Promise<Ydb.Discovery.WhoAmIResponse>} Promise
                 * @variation 2
                 */

                return DiscoveryService;
            })();

            return V1;
        })();

        Discovery.ListEndpointsRequest = (function() {

            /**
             * Properties of a ListEndpointsRequest.
             * @memberof Ydb.Discovery
             * @interface IListEndpointsRequest
             * @property {string|null} [database] ListEndpointsRequest database
             * @property {Array.<string>|null} [service] ListEndpointsRequest service
             */

            /**
             * Constructs a new ListEndpointsRequest.
             * @memberof Ydb.Discovery
             * @classdesc Represents a ListEndpointsRequest.
             * @implements IListEndpointsRequest
             * @constructor
             * @param {Ydb.Discovery.IListEndpointsRequest=} [properties] Properties to set
             */
            function ListEndpointsRequest(properties) {
                this.service = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ListEndpointsRequest database.
             * @member {string} database
             * @memberof Ydb.Discovery.ListEndpointsRequest
             * @instance
             */
            ListEndpointsRequest.prototype.database = "";

            /**
             * ListEndpointsRequest service.
             * @member {Array.<string>} service
             * @memberof Ydb.Discovery.ListEndpointsRequest
             * @instance
             */
            ListEndpointsRequest.prototype.service = $util.emptyArray;

            /**
             * Creates a new ListEndpointsRequest instance using the specified properties.
             * @function create
             * @memberof Ydb.Discovery.ListEndpointsRequest
             * @static
             * @param {Ydb.Discovery.IListEndpointsRequest=} [properties] Properties to set
             * @returns {Ydb.Discovery.ListEndpointsRequest} ListEndpointsRequest instance
             */
            ListEndpointsRequest.create = function create(properties) {
                return new ListEndpointsRequest(properties);
            };

            /**
             * Encodes the specified ListEndpointsRequest message. Does not implicitly {@link Ydb.Discovery.ListEndpointsRequest.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Discovery.ListEndpointsRequest
             * @static
             * @param {Ydb.Discovery.IListEndpointsRequest} message ListEndpointsRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ListEndpointsRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.database != null && Object.hasOwnProperty.call(message, "database"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.database);
                if (message.service != null && message.service.length)
                    for (var i = 0; i < message.service.length; ++i)
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.service[i]);
                return writer;
            };

            /**
             * Encodes the specified ListEndpointsRequest message, length delimited. Does not implicitly {@link Ydb.Discovery.ListEndpointsRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Discovery.ListEndpointsRequest
             * @static
             * @param {Ydb.Discovery.IListEndpointsRequest} message ListEndpointsRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ListEndpointsRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ListEndpointsRequest message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Discovery.ListEndpointsRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Discovery.ListEndpointsRequest} ListEndpointsRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ListEndpointsRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Discovery.ListEndpointsRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.database = reader.string();
                        break;
                    case 2:
                        if (!(message.service && message.service.length))
                            message.service = [];
                        message.service.push(reader.string());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ListEndpointsRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Discovery.ListEndpointsRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Discovery.ListEndpointsRequest} ListEndpointsRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ListEndpointsRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ListEndpointsRequest message.
             * @function verify
             * @memberof Ydb.Discovery.ListEndpointsRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ListEndpointsRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.database != null && message.hasOwnProperty("database"))
                    if (!$util.isString(message.database))
                        return "database: string expected";
                if (message.service != null && message.hasOwnProperty("service")) {
                    if (!Array.isArray(message.service))
                        return "service: array expected";
                    for (var i = 0; i < message.service.length; ++i)
                        if (!$util.isString(message.service[i]))
                            return "service: string[] expected";
                }
                return null;
            };

            /**
             * Creates a ListEndpointsRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Discovery.ListEndpointsRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Discovery.ListEndpointsRequest} ListEndpointsRequest
             */
            ListEndpointsRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Discovery.ListEndpointsRequest)
                    return object;
                var message = new $root.Ydb.Discovery.ListEndpointsRequest();
                if (object.database != null)
                    message.database = String(object.database);
                if (object.service) {
                    if (!Array.isArray(object.service))
                        throw TypeError(".Ydb.Discovery.ListEndpointsRequest.service: array expected");
                    message.service = [];
                    for (var i = 0; i < object.service.length; ++i)
                        message.service[i] = String(object.service[i]);
                }
                return message;
            };

            /**
             * Creates a plain object from a ListEndpointsRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Discovery.ListEndpointsRequest
             * @static
             * @param {Ydb.Discovery.ListEndpointsRequest} message ListEndpointsRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ListEndpointsRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.service = [];
                if (options.defaults)
                    object.database = "";
                if (message.database != null && message.hasOwnProperty("database"))
                    object.database = message.database;
                if (message.service && message.service.length) {
                    object.service = [];
                    for (var j = 0; j < message.service.length; ++j)
                        object.service[j] = message.service[j];
                }
                return object;
            };

            /**
             * Converts this ListEndpointsRequest to JSON.
             * @function toJSON
             * @memberof Ydb.Discovery.ListEndpointsRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ListEndpointsRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ListEndpointsRequest;
        })();

        Discovery.EndpointInfo = (function() {

            /**
             * Properties of an EndpointInfo.
             * @memberof Ydb.Discovery
             * @interface IEndpointInfo
             * @property {string|null} [address] EndpointInfo address
             * @property {number|null} [port] EndpointInfo port
             * @property {number|null} [loadFactor] EndpointInfo loadFactor
             * @property {boolean|null} [ssl] EndpointInfo ssl
             * @property {Array.<string>|null} [service] EndpointInfo service
             * @property {string|null} [location] EndpointInfo location
             * @property {number|null} [nodeId] EndpointInfo nodeId
             */

            /**
             * Constructs a new EndpointInfo.
             * @memberof Ydb.Discovery
             * @classdesc Represents an EndpointInfo.
             * @implements IEndpointInfo
             * @constructor
             * @param {Ydb.Discovery.IEndpointInfo=} [properties] Properties to set
             */
            function EndpointInfo(properties) {
                this.service = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * EndpointInfo address.
             * @member {string} address
             * @memberof Ydb.Discovery.EndpointInfo
             * @instance
             */
            EndpointInfo.prototype.address = "";

            /**
             * EndpointInfo port.
             * @member {number} port
             * @memberof Ydb.Discovery.EndpointInfo
             * @instance
             */
            EndpointInfo.prototype.port = 0;

            /**
             * EndpointInfo loadFactor.
             * @member {number} loadFactor
             * @memberof Ydb.Discovery.EndpointInfo
             * @instance
             */
            EndpointInfo.prototype.loadFactor = 0;

            /**
             * EndpointInfo ssl.
             * @member {boolean} ssl
             * @memberof Ydb.Discovery.EndpointInfo
             * @instance
             */
            EndpointInfo.prototype.ssl = false;

            /**
             * EndpointInfo service.
             * @member {Array.<string>} service
             * @memberof Ydb.Discovery.EndpointInfo
             * @instance
             */
            EndpointInfo.prototype.service = $util.emptyArray;

            /**
             * EndpointInfo location.
             * @member {string} location
             * @memberof Ydb.Discovery.EndpointInfo
             * @instance
             */
            EndpointInfo.prototype.location = "";

            /**
             * EndpointInfo nodeId.
             * @member {number} nodeId
             * @memberof Ydb.Discovery.EndpointInfo
             * @instance
             */
            EndpointInfo.prototype.nodeId = 0;

            /**
             * Creates a new EndpointInfo instance using the specified properties.
             * @function create
             * @memberof Ydb.Discovery.EndpointInfo
             * @static
             * @param {Ydb.Discovery.IEndpointInfo=} [properties] Properties to set
             * @returns {Ydb.Discovery.EndpointInfo} EndpointInfo instance
             */
            EndpointInfo.create = function create(properties) {
                return new EndpointInfo(properties);
            };

            /**
             * Encodes the specified EndpointInfo message. Does not implicitly {@link Ydb.Discovery.EndpointInfo.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Discovery.EndpointInfo
             * @static
             * @param {Ydb.Discovery.IEndpointInfo} message EndpointInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EndpointInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.address != null && Object.hasOwnProperty.call(message, "address"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.address);
                if (message.port != null && Object.hasOwnProperty.call(message, "port"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.port);
                if (message.loadFactor != null && Object.hasOwnProperty.call(message, "loadFactor"))
                    writer.uint32(/* id 3, wireType 5 =*/29).float(message.loadFactor);
                if (message.ssl != null && Object.hasOwnProperty.call(message, "ssl"))
                    writer.uint32(/* id 4, wireType 0 =*/32).bool(message.ssl);
                if (message.service != null && message.service.length)
                    for (var i = 0; i < message.service.length; ++i)
                        writer.uint32(/* id 5, wireType 2 =*/42).string(message.service[i]);
                if (message.location != null && Object.hasOwnProperty.call(message, "location"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.location);
                if (message.nodeId != null && Object.hasOwnProperty.call(message, "nodeId"))
                    writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.nodeId);
                return writer;
            };

            /**
             * Encodes the specified EndpointInfo message, length delimited. Does not implicitly {@link Ydb.Discovery.EndpointInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Discovery.EndpointInfo
             * @static
             * @param {Ydb.Discovery.IEndpointInfo} message EndpointInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EndpointInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an EndpointInfo message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Discovery.EndpointInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Discovery.EndpointInfo} EndpointInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EndpointInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Discovery.EndpointInfo();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.address = reader.string();
                        break;
                    case 2:
                        message.port = reader.uint32();
                        break;
                    case 3:
                        message.loadFactor = reader.float();
                        break;
                    case 4:
                        message.ssl = reader.bool();
                        break;
                    case 5:
                        if (!(message.service && message.service.length))
                            message.service = [];
                        message.service.push(reader.string());
                        break;
                    case 6:
                        message.location = reader.string();
                        break;
                    case 7:
                        message.nodeId = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an EndpointInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Discovery.EndpointInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Discovery.EndpointInfo} EndpointInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EndpointInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an EndpointInfo message.
             * @function verify
             * @memberof Ydb.Discovery.EndpointInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            EndpointInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.address != null && message.hasOwnProperty("address"))
                    if (!$util.isString(message.address))
                        return "address: string expected";
                if (message.port != null && message.hasOwnProperty("port"))
                    if (!$util.isInteger(message.port))
                        return "port: integer expected";
                if (message.loadFactor != null && message.hasOwnProperty("loadFactor"))
                    if (typeof message.loadFactor !== "number")
                        return "loadFactor: number expected";
                if (message.ssl != null && message.hasOwnProperty("ssl"))
                    if (typeof message.ssl !== "boolean")
                        return "ssl: boolean expected";
                if (message.service != null && message.hasOwnProperty("service")) {
                    if (!Array.isArray(message.service))
                        return "service: array expected";
                    for (var i = 0; i < message.service.length; ++i)
                        if (!$util.isString(message.service[i]))
                            return "service: string[] expected";
                }
                if (message.location != null && message.hasOwnProperty("location"))
                    if (!$util.isString(message.location))
                        return "location: string expected";
                if (message.nodeId != null && message.hasOwnProperty("nodeId"))
                    if (!$util.isInteger(message.nodeId))
                        return "nodeId: integer expected";
                return null;
            };

            /**
             * Creates an EndpointInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Discovery.EndpointInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Discovery.EndpointInfo} EndpointInfo
             */
            EndpointInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Discovery.EndpointInfo)
                    return object;
                var message = new $root.Ydb.Discovery.EndpointInfo();
                if (object.address != null)
                    message.address = String(object.address);
                if (object.port != null)
                    message.port = object.port >>> 0;
                if (object.loadFactor != null)
                    message.loadFactor = Number(object.loadFactor);
                if (object.ssl != null)
                    message.ssl = Boolean(object.ssl);
                if (object.service) {
                    if (!Array.isArray(object.service))
                        throw TypeError(".Ydb.Discovery.EndpointInfo.service: array expected");
                    message.service = [];
                    for (var i = 0; i < object.service.length; ++i)
                        message.service[i] = String(object.service[i]);
                }
                if (object.location != null)
                    message.location = String(object.location);
                if (object.nodeId != null)
                    message.nodeId = object.nodeId >>> 0;
                return message;
            };

            /**
             * Creates a plain object from an EndpointInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Discovery.EndpointInfo
             * @static
             * @param {Ydb.Discovery.EndpointInfo} message EndpointInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            EndpointInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.service = [];
                if (options.defaults) {
                    object.address = "";
                    object.port = 0;
                    object.loadFactor = 0;
                    object.ssl = false;
                    object.location = "";
                    object.nodeId = 0;
                }
                if (message.address != null && message.hasOwnProperty("address"))
                    object.address = message.address;
                if (message.port != null && message.hasOwnProperty("port"))
                    object.port = message.port;
                if (message.loadFactor != null && message.hasOwnProperty("loadFactor"))
                    object.loadFactor = options.json && !isFinite(message.loadFactor) ? String(message.loadFactor) : message.loadFactor;
                if (message.ssl != null && message.hasOwnProperty("ssl"))
                    object.ssl = message.ssl;
                if (message.service && message.service.length) {
                    object.service = [];
                    for (var j = 0; j < message.service.length; ++j)
                        object.service[j] = message.service[j];
                }
                if (message.location != null && message.hasOwnProperty("location"))
                    object.location = message.location;
                if (message.nodeId != null && message.hasOwnProperty("nodeId"))
                    object.nodeId = message.nodeId;
                return object;
            };

            /**
             * Converts this EndpointInfo to JSON.
             * @function toJSON
             * @memberof Ydb.Discovery.EndpointInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            EndpointInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return EndpointInfo;
        })();

        Discovery.ListEndpointsResult = (function() {

            /**
             * Properties of a ListEndpointsResult.
             * @memberof Ydb.Discovery
             * @interface IListEndpointsResult
             * @property {Array.<Ydb.Discovery.IEndpointInfo>|null} [endpoints] ListEndpointsResult endpoints
             * @property {string|null} [selfLocation] ListEndpointsResult selfLocation
             */

            /**
             * Constructs a new ListEndpointsResult.
             * @memberof Ydb.Discovery
             * @classdesc Represents a ListEndpointsResult.
             * @implements IListEndpointsResult
             * @constructor
             * @param {Ydb.Discovery.IListEndpointsResult=} [properties] Properties to set
             */
            function ListEndpointsResult(properties) {
                this.endpoints = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ListEndpointsResult endpoints.
             * @member {Array.<Ydb.Discovery.IEndpointInfo>} endpoints
             * @memberof Ydb.Discovery.ListEndpointsResult
             * @instance
             */
            ListEndpointsResult.prototype.endpoints = $util.emptyArray;

            /**
             * ListEndpointsResult selfLocation.
             * @member {string} selfLocation
             * @memberof Ydb.Discovery.ListEndpointsResult
             * @instance
             */
            ListEndpointsResult.prototype.selfLocation = "";

            /**
             * Creates a new ListEndpointsResult instance using the specified properties.
             * @function create
             * @memberof Ydb.Discovery.ListEndpointsResult
             * @static
             * @param {Ydb.Discovery.IListEndpointsResult=} [properties] Properties to set
             * @returns {Ydb.Discovery.ListEndpointsResult} ListEndpointsResult instance
             */
            ListEndpointsResult.create = function create(properties) {
                return new ListEndpointsResult(properties);
            };

            /**
             * Encodes the specified ListEndpointsResult message. Does not implicitly {@link Ydb.Discovery.ListEndpointsResult.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Discovery.ListEndpointsResult
             * @static
             * @param {Ydb.Discovery.IListEndpointsResult} message ListEndpointsResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ListEndpointsResult.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.endpoints != null && message.endpoints.length)
                    for (var i = 0; i < message.endpoints.length; ++i)
                        $root.Ydb.Discovery.EndpointInfo.encode(message.endpoints[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.selfLocation != null && Object.hasOwnProperty.call(message, "selfLocation"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.selfLocation);
                return writer;
            };

            /**
             * Encodes the specified ListEndpointsResult message, length delimited. Does not implicitly {@link Ydb.Discovery.ListEndpointsResult.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Discovery.ListEndpointsResult
             * @static
             * @param {Ydb.Discovery.IListEndpointsResult} message ListEndpointsResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ListEndpointsResult.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ListEndpointsResult message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Discovery.ListEndpointsResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Discovery.ListEndpointsResult} ListEndpointsResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ListEndpointsResult.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Discovery.ListEndpointsResult();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.endpoints && message.endpoints.length))
                            message.endpoints = [];
                        message.endpoints.push($root.Ydb.Discovery.EndpointInfo.decode(reader, reader.uint32()));
                        break;
                    case 2:
                        message.selfLocation = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ListEndpointsResult message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Discovery.ListEndpointsResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Discovery.ListEndpointsResult} ListEndpointsResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ListEndpointsResult.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ListEndpointsResult message.
             * @function verify
             * @memberof Ydb.Discovery.ListEndpointsResult
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ListEndpointsResult.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.endpoints != null && message.hasOwnProperty("endpoints")) {
                    if (!Array.isArray(message.endpoints))
                        return "endpoints: array expected";
                    for (var i = 0; i < message.endpoints.length; ++i) {
                        var error = $root.Ydb.Discovery.EndpointInfo.verify(message.endpoints[i]);
                        if (error)
                            return "endpoints." + error;
                    }
                }
                if (message.selfLocation != null && message.hasOwnProperty("selfLocation"))
                    if (!$util.isString(message.selfLocation))
                        return "selfLocation: string expected";
                return null;
            };

            /**
             * Creates a ListEndpointsResult message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Discovery.ListEndpointsResult
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Discovery.ListEndpointsResult} ListEndpointsResult
             */
            ListEndpointsResult.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Discovery.ListEndpointsResult)
                    return object;
                var message = new $root.Ydb.Discovery.ListEndpointsResult();
                if (object.endpoints) {
                    if (!Array.isArray(object.endpoints))
                        throw TypeError(".Ydb.Discovery.ListEndpointsResult.endpoints: array expected");
                    message.endpoints = [];
                    for (var i = 0; i < object.endpoints.length; ++i) {
                        if (typeof object.endpoints[i] !== "object")
                            throw TypeError(".Ydb.Discovery.ListEndpointsResult.endpoints: object expected");
                        message.endpoints[i] = $root.Ydb.Discovery.EndpointInfo.fromObject(object.endpoints[i]);
                    }
                }
                if (object.selfLocation != null)
                    message.selfLocation = String(object.selfLocation);
                return message;
            };

            /**
             * Creates a plain object from a ListEndpointsResult message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Discovery.ListEndpointsResult
             * @static
             * @param {Ydb.Discovery.ListEndpointsResult} message ListEndpointsResult
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ListEndpointsResult.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.endpoints = [];
                if (options.defaults)
                    object.selfLocation = "";
                if (message.endpoints && message.endpoints.length) {
                    object.endpoints = [];
                    for (var j = 0; j < message.endpoints.length; ++j)
                        object.endpoints[j] = $root.Ydb.Discovery.EndpointInfo.toObject(message.endpoints[j], options);
                }
                if (message.selfLocation != null && message.hasOwnProperty("selfLocation"))
                    object.selfLocation = message.selfLocation;
                return object;
            };

            /**
             * Converts this ListEndpointsResult to JSON.
             * @function toJSON
             * @memberof Ydb.Discovery.ListEndpointsResult
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ListEndpointsResult.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ListEndpointsResult;
        })();

        Discovery.ListEndpointsResponse = (function() {

            /**
             * Properties of a ListEndpointsResponse.
             * @memberof Ydb.Discovery
             * @interface IListEndpointsResponse
             * @property {Ydb.Operations.IOperation|null} [operation] ListEndpointsResponse operation
             */

            /**
             * Constructs a new ListEndpointsResponse.
             * @memberof Ydb.Discovery
             * @classdesc Represents a ListEndpointsResponse.
             * @implements IListEndpointsResponse
             * @constructor
             * @param {Ydb.Discovery.IListEndpointsResponse=} [properties] Properties to set
             */
            function ListEndpointsResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ListEndpointsResponse operation.
             * @member {Ydb.Operations.IOperation|null|undefined} operation
             * @memberof Ydb.Discovery.ListEndpointsResponse
             * @instance
             */
            ListEndpointsResponse.prototype.operation = null;

            /**
             * Creates a new ListEndpointsResponse instance using the specified properties.
             * @function create
             * @memberof Ydb.Discovery.ListEndpointsResponse
             * @static
             * @param {Ydb.Discovery.IListEndpointsResponse=} [properties] Properties to set
             * @returns {Ydb.Discovery.ListEndpointsResponse} ListEndpointsResponse instance
             */
            ListEndpointsResponse.create = function create(properties) {
                return new ListEndpointsResponse(properties);
            };

            /**
             * Encodes the specified ListEndpointsResponse message. Does not implicitly {@link Ydb.Discovery.ListEndpointsResponse.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Discovery.ListEndpointsResponse
             * @static
             * @param {Ydb.Discovery.IListEndpointsResponse} message ListEndpointsResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ListEndpointsResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.operation != null && Object.hasOwnProperty.call(message, "operation"))
                    $root.Ydb.Operations.Operation.encode(message.operation, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ListEndpointsResponse message, length delimited. Does not implicitly {@link Ydb.Discovery.ListEndpointsResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Discovery.ListEndpointsResponse
             * @static
             * @param {Ydb.Discovery.IListEndpointsResponse} message ListEndpointsResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ListEndpointsResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ListEndpointsResponse message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Discovery.ListEndpointsResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Discovery.ListEndpointsResponse} ListEndpointsResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ListEndpointsResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Discovery.ListEndpointsResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.operation = $root.Ydb.Operations.Operation.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ListEndpointsResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Discovery.ListEndpointsResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Discovery.ListEndpointsResponse} ListEndpointsResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ListEndpointsResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ListEndpointsResponse message.
             * @function verify
             * @memberof Ydb.Discovery.ListEndpointsResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ListEndpointsResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.operation != null && message.hasOwnProperty("operation")) {
                    var error = $root.Ydb.Operations.Operation.verify(message.operation);
                    if (error)
                        return "operation." + error;
                }
                return null;
            };

            /**
             * Creates a ListEndpointsResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Discovery.ListEndpointsResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Discovery.ListEndpointsResponse} ListEndpointsResponse
             */
            ListEndpointsResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Discovery.ListEndpointsResponse)
                    return object;
                var message = new $root.Ydb.Discovery.ListEndpointsResponse();
                if (object.operation != null) {
                    if (typeof object.operation !== "object")
                        throw TypeError(".Ydb.Discovery.ListEndpointsResponse.operation: object expected");
                    message.operation = $root.Ydb.Operations.Operation.fromObject(object.operation);
                }
                return message;
            };

            /**
             * Creates a plain object from a ListEndpointsResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Discovery.ListEndpointsResponse
             * @static
             * @param {Ydb.Discovery.ListEndpointsResponse} message ListEndpointsResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ListEndpointsResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.operation = null;
                if (message.operation != null && message.hasOwnProperty("operation"))
                    object.operation = $root.Ydb.Operations.Operation.toObject(message.operation, options);
                return object;
            };

            /**
             * Converts this ListEndpointsResponse to JSON.
             * @function toJSON
             * @memberof Ydb.Discovery.ListEndpointsResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ListEndpointsResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ListEndpointsResponse;
        })();

        Discovery.WhoAmIRequest = (function() {

            /**
             * Properties of a WhoAmIRequest.
             * @memberof Ydb.Discovery
             * @interface IWhoAmIRequest
             * @property {boolean|null} [includeGroups] WhoAmIRequest includeGroups
             */

            /**
             * Constructs a new WhoAmIRequest.
             * @memberof Ydb.Discovery
             * @classdesc Represents a WhoAmIRequest.
             * @implements IWhoAmIRequest
             * @constructor
             * @param {Ydb.Discovery.IWhoAmIRequest=} [properties] Properties to set
             */
            function WhoAmIRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * WhoAmIRequest includeGroups.
             * @member {boolean} includeGroups
             * @memberof Ydb.Discovery.WhoAmIRequest
             * @instance
             */
            WhoAmIRequest.prototype.includeGroups = false;

            /**
             * Creates a new WhoAmIRequest instance using the specified properties.
             * @function create
             * @memberof Ydb.Discovery.WhoAmIRequest
             * @static
             * @param {Ydb.Discovery.IWhoAmIRequest=} [properties] Properties to set
             * @returns {Ydb.Discovery.WhoAmIRequest} WhoAmIRequest instance
             */
            WhoAmIRequest.create = function create(properties) {
                return new WhoAmIRequest(properties);
            };

            /**
             * Encodes the specified WhoAmIRequest message. Does not implicitly {@link Ydb.Discovery.WhoAmIRequest.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Discovery.WhoAmIRequest
             * @static
             * @param {Ydb.Discovery.IWhoAmIRequest} message WhoAmIRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WhoAmIRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.includeGroups != null && Object.hasOwnProperty.call(message, "includeGroups"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.includeGroups);
                return writer;
            };

            /**
             * Encodes the specified WhoAmIRequest message, length delimited. Does not implicitly {@link Ydb.Discovery.WhoAmIRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Discovery.WhoAmIRequest
             * @static
             * @param {Ydb.Discovery.IWhoAmIRequest} message WhoAmIRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WhoAmIRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a WhoAmIRequest message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Discovery.WhoAmIRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Discovery.WhoAmIRequest} WhoAmIRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WhoAmIRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Discovery.WhoAmIRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.includeGroups = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a WhoAmIRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Discovery.WhoAmIRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Discovery.WhoAmIRequest} WhoAmIRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WhoAmIRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a WhoAmIRequest message.
             * @function verify
             * @memberof Ydb.Discovery.WhoAmIRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WhoAmIRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.includeGroups != null && message.hasOwnProperty("includeGroups"))
                    if (typeof message.includeGroups !== "boolean")
                        return "includeGroups: boolean expected";
                return null;
            };

            /**
             * Creates a WhoAmIRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Discovery.WhoAmIRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Discovery.WhoAmIRequest} WhoAmIRequest
             */
            WhoAmIRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Discovery.WhoAmIRequest)
                    return object;
                var message = new $root.Ydb.Discovery.WhoAmIRequest();
                if (object.includeGroups != null)
                    message.includeGroups = Boolean(object.includeGroups);
                return message;
            };

            /**
             * Creates a plain object from a WhoAmIRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Discovery.WhoAmIRequest
             * @static
             * @param {Ydb.Discovery.WhoAmIRequest} message WhoAmIRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            WhoAmIRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.includeGroups = false;
                if (message.includeGroups != null && message.hasOwnProperty("includeGroups"))
                    object.includeGroups = message.includeGroups;
                return object;
            };

            /**
             * Converts this WhoAmIRequest to JSON.
             * @function toJSON
             * @memberof Ydb.Discovery.WhoAmIRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            WhoAmIRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return WhoAmIRequest;
        })();

        Discovery.WhoAmIResult = (function() {

            /**
             * Properties of a WhoAmIResult.
             * @memberof Ydb.Discovery
             * @interface IWhoAmIResult
             * @property {string|null} [user] WhoAmIResult user
             * @property {Array.<string>|null} [groups] WhoAmIResult groups
             */

            /**
             * Constructs a new WhoAmIResult.
             * @memberof Ydb.Discovery
             * @classdesc Represents a WhoAmIResult.
             * @implements IWhoAmIResult
             * @constructor
             * @param {Ydb.Discovery.IWhoAmIResult=} [properties] Properties to set
             */
            function WhoAmIResult(properties) {
                this.groups = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * WhoAmIResult user.
             * @member {string} user
             * @memberof Ydb.Discovery.WhoAmIResult
             * @instance
             */
            WhoAmIResult.prototype.user = "";

            /**
             * WhoAmIResult groups.
             * @member {Array.<string>} groups
             * @memberof Ydb.Discovery.WhoAmIResult
             * @instance
             */
            WhoAmIResult.prototype.groups = $util.emptyArray;

            /**
             * Creates a new WhoAmIResult instance using the specified properties.
             * @function create
             * @memberof Ydb.Discovery.WhoAmIResult
             * @static
             * @param {Ydb.Discovery.IWhoAmIResult=} [properties] Properties to set
             * @returns {Ydb.Discovery.WhoAmIResult} WhoAmIResult instance
             */
            WhoAmIResult.create = function create(properties) {
                return new WhoAmIResult(properties);
            };

            /**
             * Encodes the specified WhoAmIResult message. Does not implicitly {@link Ydb.Discovery.WhoAmIResult.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Discovery.WhoAmIResult
             * @static
             * @param {Ydb.Discovery.IWhoAmIResult} message WhoAmIResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WhoAmIResult.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.user != null && Object.hasOwnProperty.call(message, "user"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.user);
                if (message.groups != null && message.groups.length)
                    for (var i = 0; i < message.groups.length; ++i)
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.groups[i]);
                return writer;
            };

            /**
             * Encodes the specified WhoAmIResult message, length delimited. Does not implicitly {@link Ydb.Discovery.WhoAmIResult.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Discovery.WhoAmIResult
             * @static
             * @param {Ydb.Discovery.IWhoAmIResult} message WhoAmIResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WhoAmIResult.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a WhoAmIResult message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Discovery.WhoAmIResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Discovery.WhoAmIResult} WhoAmIResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WhoAmIResult.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Discovery.WhoAmIResult();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.user = reader.string();
                        break;
                    case 2:
                        if (!(message.groups && message.groups.length))
                            message.groups = [];
                        message.groups.push(reader.string());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a WhoAmIResult message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Discovery.WhoAmIResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Discovery.WhoAmIResult} WhoAmIResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WhoAmIResult.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a WhoAmIResult message.
             * @function verify
             * @memberof Ydb.Discovery.WhoAmIResult
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WhoAmIResult.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.user != null && message.hasOwnProperty("user"))
                    if (!$util.isString(message.user))
                        return "user: string expected";
                if (message.groups != null && message.hasOwnProperty("groups")) {
                    if (!Array.isArray(message.groups))
                        return "groups: array expected";
                    for (var i = 0; i < message.groups.length; ++i)
                        if (!$util.isString(message.groups[i]))
                            return "groups: string[] expected";
                }
                return null;
            };

            /**
             * Creates a WhoAmIResult message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Discovery.WhoAmIResult
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Discovery.WhoAmIResult} WhoAmIResult
             */
            WhoAmIResult.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Discovery.WhoAmIResult)
                    return object;
                var message = new $root.Ydb.Discovery.WhoAmIResult();
                if (object.user != null)
                    message.user = String(object.user);
                if (object.groups) {
                    if (!Array.isArray(object.groups))
                        throw TypeError(".Ydb.Discovery.WhoAmIResult.groups: array expected");
                    message.groups = [];
                    for (var i = 0; i < object.groups.length; ++i)
                        message.groups[i] = String(object.groups[i]);
                }
                return message;
            };

            /**
             * Creates a plain object from a WhoAmIResult message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Discovery.WhoAmIResult
             * @static
             * @param {Ydb.Discovery.WhoAmIResult} message WhoAmIResult
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            WhoAmIResult.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.groups = [];
                if (options.defaults)
                    object.user = "";
                if (message.user != null && message.hasOwnProperty("user"))
                    object.user = message.user;
                if (message.groups && message.groups.length) {
                    object.groups = [];
                    for (var j = 0; j < message.groups.length; ++j)
                        object.groups[j] = message.groups[j];
                }
                return object;
            };

            /**
             * Converts this WhoAmIResult to JSON.
             * @function toJSON
             * @memberof Ydb.Discovery.WhoAmIResult
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            WhoAmIResult.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return WhoAmIResult;
        })();

        Discovery.WhoAmIResponse = (function() {

            /**
             * Properties of a WhoAmIResponse.
             * @memberof Ydb.Discovery
             * @interface IWhoAmIResponse
             * @property {Ydb.Operations.IOperation|null} [operation] WhoAmIResponse operation
             */

            /**
             * Constructs a new WhoAmIResponse.
             * @memberof Ydb.Discovery
             * @classdesc Represents a WhoAmIResponse.
             * @implements IWhoAmIResponse
             * @constructor
             * @param {Ydb.Discovery.IWhoAmIResponse=} [properties] Properties to set
             */
            function WhoAmIResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * WhoAmIResponse operation.
             * @member {Ydb.Operations.IOperation|null|undefined} operation
             * @memberof Ydb.Discovery.WhoAmIResponse
             * @instance
             */
            WhoAmIResponse.prototype.operation = null;

            /**
             * Creates a new WhoAmIResponse instance using the specified properties.
             * @function create
             * @memberof Ydb.Discovery.WhoAmIResponse
             * @static
             * @param {Ydb.Discovery.IWhoAmIResponse=} [properties] Properties to set
             * @returns {Ydb.Discovery.WhoAmIResponse} WhoAmIResponse instance
             */
            WhoAmIResponse.create = function create(properties) {
                return new WhoAmIResponse(properties);
            };

            /**
             * Encodes the specified WhoAmIResponse message. Does not implicitly {@link Ydb.Discovery.WhoAmIResponse.verify|verify} messages.
             * @function encode
             * @memberof Ydb.Discovery.WhoAmIResponse
             * @static
             * @param {Ydb.Discovery.IWhoAmIResponse} message WhoAmIResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WhoAmIResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.operation != null && Object.hasOwnProperty.call(message, "operation"))
                    $root.Ydb.Operations.Operation.encode(message.operation, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified WhoAmIResponse message, length delimited. Does not implicitly {@link Ydb.Discovery.WhoAmIResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Ydb.Discovery.WhoAmIResponse
             * @static
             * @param {Ydb.Discovery.IWhoAmIResponse} message WhoAmIResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WhoAmIResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a WhoAmIResponse message from the specified reader or buffer.
             * @function decode
             * @memberof Ydb.Discovery.WhoAmIResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Ydb.Discovery.WhoAmIResponse} WhoAmIResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WhoAmIResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Ydb.Discovery.WhoAmIResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.operation = $root.Ydb.Operations.Operation.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a WhoAmIResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Ydb.Discovery.WhoAmIResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Ydb.Discovery.WhoAmIResponse} WhoAmIResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WhoAmIResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a WhoAmIResponse message.
             * @function verify
             * @memberof Ydb.Discovery.WhoAmIResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WhoAmIResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.operation != null && message.hasOwnProperty("operation")) {
                    var error = $root.Ydb.Operations.Operation.verify(message.operation);
                    if (error)
                        return "operation." + error;
                }
                return null;
            };

            /**
             * Creates a WhoAmIResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Ydb.Discovery.WhoAmIResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Ydb.Discovery.WhoAmIResponse} WhoAmIResponse
             */
            WhoAmIResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.Ydb.Discovery.WhoAmIResponse)
                    return object;
                var message = new $root.Ydb.Discovery.WhoAmIResponse();
                if (object.operation != null) {
                    if (typeof object.operation !== "object")
                        throw TypeError(".Ydb.Discovery.WhoAmIResponse.operation: object expected");
                    message.operation = $root.Ydb.Operations.Operation.fromObject(object.operation);
                }
                return message;
            };

            /**
             * Creates a plain object from a WhoAmIResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Ydb.Discovery.WhoAmIResponse
             * @static
             * @param {Ydb.Discovery.WhoAmIResponse} message WhoAmIResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            WhoAmIResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.operation = null;
                if (message.operation != null && message.hasOwnProperty("operation"))
                    object.operation = $root.Ydb.Operations.Operation.toObject(message.operation, options);
                return object;
            };

            /**
             * Converts this WhoAmIResponse to JSON.
             * @function toJSON
             * @memberof Ydb.Discovery.WhoAmIResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            WhoAmIResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return WhoAmIResponse;
        })();

        return Discovery;
    })();

    return Ydb;
})();

$root.google = (function() {

    /**
     * Namespace google.
     * @exports google
     * @namespace
     */
    var google = {};

    google.protobuf = (function() {

        /**
         * Namespace protobuf.
         * @memberof google
         * @namespace
         */
        var protobuf = {};

        protobuf.FileDescriptorSet = (function() {

            /**
             * Properties of a FileDescriptorSet.
             * @memberof google.protobuf
             * @interface IFileDescriptorSet
             * @property {Array.<google.protobuf.IFileDescriptorProto>|null} [file] FileDescriptorSet file
             */

            /**
             * Constructs a new FileDescriptorSet.
             * @memberof google.protobuf
             * @classdesc Represents a FileDescriptorSet.
             * @implements IFileDescriptorSet
             * @constructor
             * @param {google.protobuf.IFileDescriptorSet=} [properties] Properties to set
             */
            function FileDescriptorSet(properties) {
                this.file = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FileDescriptorSet file.
             * @member {Array.<google.protobuf.IFileDescriptorProto>} file
             * @memberof google.protobuf.FileDescriptorSet
             * @instance
             */
            FileDescriptorSet.prototype.file = $util.emptyArray;

            /**
             * Creates a new FileDescriptorSet instance using the specified properties.
             * @function create
             * @memberof google.protobuf.FileDescriptorSet
             * @static
             * @param {google.protobuf.IFileDescriptorSet=} [properties] Properties to set
             * @returns {google.protobuf.FileDescriptorSet} FileDescriptorSet instance
             */
            FileDescriptorSet.create = function create(properties) {
                return new FileDescriptorSet(properties);
            };

            /**
             * Encodes the specified FileDescriptorSet message. Does not implicitly {@link google.protobuf.FileDescriptorSet.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.FileDescriptorSet
             * @static
             * @param {google.protobuf.IFileDescriptorSet} message FileDescriptorSet message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FileDescriptorSet.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.file != null && message.file.length)
                    for (var i = 0; i < message.file.length; ++i)
                        $root.google.protobuf.FileDescriptorProto.encode(message.file[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified FileDescriptorSet message, length delimited. Does not implicitly {@link google.protobuf.FileDescriptorSet.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.FileDescriptorSet
             * @static
             * @param {google.protobuf.IFileDescriptorSet} message FileDescriptorSet message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FileDescriptorSet.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a FileDescriptorSet message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.FileDescriptorSet
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.FileDescriptorSet} FileDescriptorSet
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FileDescriptorSet.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FileDescriptorSet();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.file && message.file.length))
                            message.file = [];
                        message.file.push($root.google.protobuf.FileDescriptorProto.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a FileDescriptorSet message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.FileDescriptorSet
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.FileDescriptorSet} FileDescriptorSet
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FileDescriptorSet.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a FileDescriptorSet message.
             * @function verify
             * @memberof google.protobuf.FileDescriptorSet
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FileDescriptorSet.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.file != null && message.hasOwnProperty("file")) {
                    if (!Array.isArray(message.file))
                        return "file: array expected";
                    for (var i = 0; i < message.file.length; ++i) {
                        var error = $root.google.protobuf.FileDescriptorProto.verify(message.file[i]);
                        if (error)
                            return "file." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a FileDescriptorSet message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.FileDescriptorSet
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.FileDescriptorSet} FileDescriptorSet
             */
            FileDescriptorSet.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.FileDescriptorSet)
                    return object;
                var message = new $root.google.protobuf.FileDescriptorSet();
                if (object.file) {
                    if (!Array.isArray(object.file))
                        throw TypeError(".google.protobuf.FileDescriptorSet.file: array expected");
                    message.file = [];
                    for (var i = 0; i < object.file.length; ++i) {
                        if (typeof object.file[i] !== "object")
                            throw TypeError(".google.protobuf.FileDescriptorSet.file: object expected");
                        message.file[i] = $root.google.protobuf.FileDescriptorProto.fromObject(object.file[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a FileDescriptorSet message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.FileDescriptorSet
             * @static
             * @param {google.protobuf.FileDescriptorSet} message FileDescriptorSet
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FileDescriptorSet.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.file = [];
                if (message.file && message.file.length) {
                    object.file = [];
                    for (var j = 0; j < message.file.length; ++j)
                        object.file[j] = $root.google.protobuf.FileDescriptorProto.toObject(message.file[j], options);
                }
                return object;
            };

            /**
             * Converts this FileDescriptorSet to JSON.
             * @function toJSON
             * @memberof google.protobuf.FileDescriptorSet
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FileDescriptorSet.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return FileDescriptorSet;
        })();

        protobuf.FileDescriptorProto = (function() {

            /**
             * Properties of a FileDescriptorProto.
             * @memberof google.protobuf
             * @interface IFileDescriptorProto
             * @property {string|null} [name] FileDescriptorProto name
             * @property {string|null} ["package"] FileDescriptorProto package
             * @property {Array.<string>|null} [dependency] FileDescriptorProto dependency
             * @property {Array.<number>|null} [publicDependency] FileDescriptorProto publicDependency
             * @property {Array.<number>|null} [weakDependency] FileDescriptorProto weakDependency
             * @property {Array.<google.protobuf.IDescriptorProto>|null} [messageType] FileDescriptorProto messageType
             * @property {Array.<google.protobuf.IEnumDescriptorProto>|null} [enumType] FileDescriptorProto enumType
             * @property {Array.<google.protobuf.IServiceDescriptorProto>|null} [service] FileDescriptorProto service
             * @property {Array.<google.protobuf.IFieldDescriptorProto>|null} [extension] FileDescriptorProto extension
             * @property {google.protobuf.IFileOptions|null} [options] FileDescriptorProto options
             * @property {google.protobuf.ISourceCodeInfo|null} [sourceCodeInfo] FileDescriptorProto sourceCodeInfo
             * @property {string|null} [syntax] FileDescriptorProto syntax
             */

            /**
             * Constructs a new FileDescriptorProto.
             * @memberof google.protobuf
             * @classdesc Represents a FileDescriptorProto.
             * @implements IFileDescriptorProto
             * @constructor
             * @param {google.protobuf.IFileDescriptorProto=} [properties] Properties to set
             */
            function FileDescriptorProto(properties) {
                this.dependency = [];
                this.publicDependency = [];
                this.weakDependency = [];
                this.messageType = [];
                this.enumType = [];
                this.service = [];
                this.extension = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FileDescriptorProto name.
             * @member {string} name
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.name = "";

            /**
             * FileDescriptorProto package.
             * @member {string} package
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype["package"] = "";

            /**
             * FileDescriptorProto dependency.
             * @member {Array.<string>} dependency
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.dependency = $util.emptyArray;

            /**
             * FileDescriptorProto publicDependency.
             * @member {Array.<number>} publicDependency
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.publicDependency = $util.emptyArray;

            /**
             * FileDescriptorProto weakDependency.
             * @member {Array.<number>} weakDependency
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.weakDependency = $util.emptyArray;

            /**
             * FileDescriptorProto messageType.
             * @member {Array.<google.protobuf.IDescriptorProto>} messageType
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.messageType = $util.emptyArray;

            /**
             * FileDescriptorProto enumType.
             * @member {Array.<google.protobuf.IEnumDescriptorProto>} enumType
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.enumType = $util.emptyArray;

            /**
             * FileDescriptorProto service.
             * @member {Array.<google.protobuf.IServiceDescriptorProto>} service
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.service = $util.emptyArray;

            /**
             * FileDescriptorProto extension.
             * @member {Array.<google.protobuf.IFieldDescriptorProto>} extension
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.extension = $util.emptyArray;

            /**
             * FileDescriptorProto options.
             * @member {google.protobuf.IFileOptions|null|undefined} options
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.options = null;

            /**
             * FileDescriptorProto sourceCodeInfo.
             * @member {google.protobuf.ISourceCodeInfo|null|undefined} sourceCodeInfo
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.sourceCodeInfo = null;

            /**
             * FileDescriptorProto syntax.
             * @member {string} syntax
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.syntax = "";

            /**
             * Creates a new FileDescriptorProto instance using the specified properties.
             * @function create
             * @memberof google.protobuf.FileDescriptorProto
             * @static
             * @param {google.protobuf.IFileDescriptorProto=} [properties] Properties to set
             * @returns {google.protobuf.FileDescriptorProto} FileDescriptorProto instance
             */
            FileDescriptorProto.create = function create(properties) {
                return new FileDescriptorProto(properties);
            };

            /**
             * Encodes the specified FileDescriptorProto message. Does not implicitly {@link google.protobuf.FileDescriptorProto.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.FileDescriptorProto
             * @static
             * @param {google.protobuf.IFileDescriptorProto} message FileDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FileDescriptorProto.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message["package"] != null && Object.hasOwnProperty.call(message, "package"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message["package"]);
                if (message.dependency != null && message.dependency.length)
                    for (var i = 0; i < message.dependency.length; ++i)
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.dependency[i]);
                if (message.messageType != null && message.messageType.length)
                    for (var i = 0; i < message.messageType.length; ++i)
                        $root.google.protobuf.DescriptorProto.encode(message.messageType[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.enumType != null && message.enumType.length)
                    for (var i = 0; i < message.enumType.length; ++i)
                        $root.google.protobuf.EnumDescriptorProto.encode(message.enumType[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.service != null && message.service.length)
                    for (var i = 0; i < message.service.length; ++i)
                        $root.google.protobuf.ServiceDescriptorProto.encode(message.service[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.extension != null && message.extension.length)
                    for (var i = 0; i < message.extension.length; ++i)
                        $root.google.protobuf.FieldDescriptorProto.encode(message.extension[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                    $root.google.protobuf.FileOptions.encode(message.options, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                if (message.sourceCodeInfo != null && Object.hasOwnProperty.call(message, "sourceCodeInfo"))
                    $root.google.protobuf.SourceCodeInfo.encode(message.sourceCodeInfo, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                if (message.publicDependency != null && message.publicDependency.length)
                    for (var i = 0; i < message.publicDependency.length; ++i)
                        writer.uint32(/* id 10, wireType 0 =*/80).int32(message.publicDependency[i]);
                if (message.weakDependency != null && message.weakDependency.length)
                    for (var i = 0; i < message.weakDependency.length; ++i)
                        writer.uint32(/* id 11, wireType 0 =*/88).int32(message.weakDependency[i]);
                if (message.syntax != null && Object.hasOwnProperty.call(message, "syntax"))
                    writer.uint32(/* id 12, wireType 2 =*/98).string(message.syntax);
                return writer;
            };

            /**
             * Encodes the specified FileDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.FileDescriptorProto.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.FileDescriptorProto
             * @static
             * @param {google.protobuf.IFileDescriptorProto} message FileDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FileDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a FileDescriptorProto message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.FileDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.FileDescriptorProto} FileDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FileDescriptorProto.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FileDescriptorProto();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message["package"] = reader.string();
                        break;
                    case 3:
                        if (!(message.dependency && message.dependency.length))
                            message.dependency = [];
                        message.dependency.push(reader.string());
                        break;
                    case 10:
                        if (!(message.publicDependency && message.publicDependency.length))
                            message.publicDependency = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.publicDependency.push(reader.int32());
                        } else
                            message.publicDependency.push(reader.int32());
                        break;
                    case 11:
                        if (!(message.weakDependency && message.weakDependency.length))
                            message.weakDependency = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.weakDependency.push(reader.int32());
                        } else
                            message.weakDependency.push(reader.int32());
                        break;
                    case 4:
                        if (!(message.messageType && message.messageType.length))
                            message.messageType = [];
                        message.messageType.push($root.google.protobuf.DescriptorProto.decode(reader, reader.uint32()));
                        break;
                    case 5:
                        if (!(message.enumType && message.enumType.length))
                            message.enumType = [];
                        message.enumType.push($root.google.protobuf.EnumDescriptorProto.decode(reader, reader.uint32()));
                        break;
                    case 6:
                        if (!(message.service && message.service.length))
                            message.service = [];
                        message.service.push($root.google.protobuf.ServiceDescriptorProto.decode(reader, reader.uint32()));
                        break;
                    case 7:
                        if (!(message.extension && message.extension.length))
                            message.extension = [];
                        message.extension.push($root.google.protobuf.FieldDescriptorProto.decode(reader, reader.uint32()));
                        break;
                    case 8:
                        message.options = $root.google.protobuf.FileOptions.decode(reader, reader.uint32());
                        break;
                    case 9:
                        message.sourceCodeInfo = $root.google.protobuf.SourceCodeInfo.decode(reader, reader.uint32());
                        break;
                    case 12:
                        message.syntax = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a FileDescriptorProto message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.FileDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.FileDescriptorProto} FileDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FileDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a FileDescriptorProto message.
             * @function verify
             * @memberof google.protobuf.FileDescriptorProto
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FileDescriptorProto.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message["package"] != null && message.hasOwnProperty("package"))
                    if (!$util.isString(message["package"]))
                        return "package: string expected";
                if (message.dependency != null && message.hasOwnProperty("dependency")) {
                    if (!Array.isArray(message.dependency))
                        return "dependency: array expected";
                    for (var i = 0; i < message.dependency.length; ++i)
                        if (!$util.isString(message.dependency[i]))
                            return "dependency: string[] expected";
                }
                if (message.publicDependency != null && message.hasOwnProperty("publicDependency")) {
                    if (!Array.isArray(message.publicDependency))
                        return "publicDependency: array expected";
                    for (var i = 0; i < message.publicDependency.length; ++i)
                        if (!$util.isInteger(message.publicDependency[i]))
                            return "publicDependency: integer[] expected";
                }
                if (message.weakDependency != null && message.hasOwnProperty("weakDependency")) {
                    if (!Array.isArray(message.weakDependency))
                        return "weakDependency: array expected";
                    for (var i = 0; i < message.weakDependency.length; ++i)
                        if (!$util.isInteger(message.weakDependency[i]))
                            return "weakDependency: integer[] expected";
                }
                if (message.messageType != null && message.hasOwnProperty("messageType")) {
                    if (!Array.isArray(message.messageType))
                        return "messageType: array expected";
                    for (var i = 0; i < message.messageType.length; ++i) {
                        var error = $root.google.protobuf.DescriptorProto.verify(message.messageType[i]);
                        if (error)
                            return "messageType." + error;
                    }
                }
                if (message.enumType != null && message.hasOwnProperty("enumType")) {
                    if (!Array.isArray(message.enumType))
                        return "enumType: array expected";
                    for (var i = 0; i < message.enumType.length; ++i) {
                        var error = $root.google.protobuf.EnumDescriptorProto.verify(message.enumType[i]);
                        if (error)
                            return "enumType." + error;
                    }
                }
                if (message.service != null && message.hasOwnProperty("service")) {
                    if (!Array.isArray(message.service))
                        return "service: array expected";
                    for (var i = 0; i < message.service.length; ++i) {
                        var error = $root.google.protobuf.ServiceDescriptorProto.verify(message.service[i]);
                        if (error)
                            return "service." + error;
                    }
                }
                if (message.extension != null && message.hasOwnProperty("extension")) {
                    if (!Array.isArray(message.extension))
                        return "extension: array expected";
                    for (var i = 0; i < message.extension.length; ++i) {
                        var error = $root.google.protobuf.FieldDescriptorProto.verify(message.extension[i]);
                        if (error)
                            return "extension." + error;
                    }
                }
                if (message.options != null && message.hasOwnProperty("options")) {
                    var error = $root.google.protobuf.FileOptions.verify(message.options);
                    if (error)
                        return "options." + error;
                }
                if (message.sourceCodeInfo != null && message.hasOwnProperty("sourceCodeInfo")) {
                    var error = $root.google.protobuf.SourceCodeInfo.verify(message.sourceCodeInfo);
                    if (error)
                        return "sourceCodeInfo." + error;
                }
                if (message.syntax != null && message.hasOwnProperty("syntax"))
                    if (!$util.isString(message.syntax))
                        return "syntax: string expected";
                return null;
            };

            /**
             * Creates a FileDescriptorProto message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.FileDescriptorProto
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.FileDescriptorProto} FileDescriptorProto
             */
            FileDescriptorProto.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.FileDescriptorProto)
                    return object;
                var message = new $root.google.protobuf.FileDescriptorProto();
                if (object.name != null)
                    message.name = String(object.name);
                if (object["package"] != null)
                    message["package"] = String(object["package"]);
                if (object.dependency) {
                    if (!Array.isArray(object.dependency))
                        throw TypeError(".google.protobuf.FileDescriptorProto.dependency: array expected");
                    message.dependency = [];
                    for (var i = 0; i < object.dependency.length; ++i)
                        message.dependency[i] = String(object.dependency[i]);
                }
                if (object.publicDependency) {
                    if (!Array.isArray(object.publicDependency))
                        throw TypeError(".google.protobuf.FileDescriptorProto.publicDependency: array expected");
                    message.publicDependency = [];
                    for (var i = 0; i < object.publicDependency.length; ++i)
                        message.publicDependency[i] = object.publicDependency[i] | 0;
                }
                if (object.weakDependency) {
                    if (!Array.isArray(object.weakDependency))
                        throw TypeError(".google.protobuf.FileDescriptorProto.weakDependency: array expected");
                    message.weakDependency = [];
                    for (var i = 0; i < object.weakDependency.length; ++i)
                        message.weakDependency[i] = object.weakDependency[i] | 0;
                }
                if (object.messageType) {
                    if (!Array.isArray(object.messageType))
                        throw TypeError(".google.protobuf.FileDescriptorProto.messageType: array expected");
                    message.messageType = [];
                    for (var i = 0; i < object.messageType.length; ++i) {
                        if (typeof object.messageType[i] !== "object")
                            throw TypeError(".google.protobuf.FileDescriptorProto.messageType: object expected");
                        message.messageType[i] = $root.google.protobuf.DescriptorProto.fromObject(object.messageType[i]);
                    }
                }
                if (object.enumType) {
                    if (!Array.isArray(object.enumType))
                        throw TypeError(".google.protobuf.FileDescriptorProto.enumType: array expected");
                    message.enumType = [];
                    for (var i = 0; i < object.enumType.length; ++i) {
                        if (typeof object.enumType[i] !== "object")
                            throw TypeError(".google.protobuf.FileDescriptorProto.enumType: object expected");
                        message.enumType[i] = $root.google.protobuf.EnumDescriptorProto.fromObject(object.enumType[i]);
                    }
                }
                if (object.service) {
                    if (!Array.isArray(object.service))
                        throw TypeError(".google.protobuf.FileDescriptorProto.service: array expected");
                    message.service = [];
                    for (var i = 0; i < object.service.length; ++i) {
                        if (typeof object.service[i] !== "object")
                            throw TypeError(".google.protobuf.FileDescriptorProto.service: object expected");
                        message.service[i] = $root.google.protobuf.ServiceDescriptorProto.fromObject(object.service[i]);
                    }
                }
                if (object.extension) {
                    if (!Array.isArray(object.extension))
                        throw TypeError(".google.protobuf.FileDescriptorProto.extension: array expected");
                    message.extension = [];
                    for (var i = 0; i < object.extension.length; ++i) {
                        if (typeof object.extension[i] !== "object")
                            throw TypeError(".google.protobuf.FileDescriptorProto.extension: object expected");
                        message.extension[i] = $root.google.protobuf.FieldDescriptorProto.fromObject(object.extension[i]);
                    }
                }
                if (object.options != null) {
                    if (typeof object.options !== "object")
                        throw TypeError(".google.protobuf.FileDescriptorProto.options: object expected");
                    message.options = $root.google.protobuf.FileOptions.fromObject(object.options);
                }
                if (object.sourceCodeInfo != null) {
                    if (typeof object.sourceCodeInfo !== "object")
                        throw TypeError(".google.protobuf.FileDescriptorProto.sourceCodeInfo: object expected");
                    message.sourceCodeInfo = $root.google.protobuf.SourceCodeInfo.fromObject(object.sourceCodeInfo);
                }
                if (object.syntax != null)
                    message.syntax = String(object.syntax);
                return message;
            };

            /**
             * Creates a plain object from a FileDescriptorProto message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.FileDescriptorProto
             * @static
             * @param {google.protobuf.FileDescriptorProto} message FileDescriptorProto
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FileDescriptorProto.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.dependency = [];
                    object.messageType = [];
                    object.enumType = [];
                    object.service = [];
                    object.extension = [];
                    object.publicDependency = [];
                    object.weakDependency = [];
                }
                if (options.defaults) {
                    object.name = "";
                    object["package"] = "";
                    object.options = null;
                    object.sourceCodeInfo = null;
                    object.syntax = "";
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message["package"] != null && message.hasOwnProperty("package"))
                    object["package"] = message["package"];
                if (message.dependency && message.dependency.length) {
                    object.dependency = [];
                    for (var j = 0; j < message.dependency.length; ++j)
                        object.dependency[j] = message.dependency[j];
                }
                if (message.messageType && message.messageType.length) {
                    object.messageType = [];
                    for (var j = 0; j < message.messageType.length; ++j)
                        object.messageType[j] = $root.google.protobuf.DescriptorProto.toObject(message.messageType[j], options);
                }
                if (message.enumType && message.enumType.length) {
                    object.enumType = [];
                    for (var j = 0; j < message.enumType.length; ++j)
                        object.enumType[j] = $root.google.protobuf.EnumDescriptorProto.toObject(message.enumType[j], options);
                }
                if (message.service && message.service.length) {
                    object.service = [];
                    for (var j = 0; j < message.service.length; ++j)
                        object.service[j] = $root.google.protobuf.ServiceDescriptorProto.toObject(message.service[j], options);
                }
                if (message.extension && message.extension.length) {
                    object.extension = [];
                    for (var j = 0; j < message.extension.length; ++j)
                        object.extension[j] = $root.google.protobuf.FieldDescriptorProto.toObject(message.extension[j], options);
                }
                if (message.options != null && message.hasOwnProperty("options"))
                    object.options = $root.google.protobuf.FileOptions.toObject(message.options, options);
                if (message.sourceCodeInfo != null && message.hasOwnProperty("sourceCodeInfo"))
                    object.sourceCodeInfo = $root.google.protobuf.SourceCodeInfo.toObject(message.sourceCodeInfo, options);
                if (message.publicDependency && message.publicDependency.length) {
                    object.publicDependency = [];
                    for (var j = 0; j < message.publicDependency.length; ++j)
                        object.publicDependency[j] = message.publicDependency[j];
                }
                if (message.weakDependency && message.weakDependency.length) {
                    object.weakDependency = [];
                    for (var j = 0; j < message.weakDependency.length; ++j)
                        object.weakDependency[j] = message.weakDependency[j];
                }
                if (message.syntax != null && message.hasOwnProperty("syntax"))
                    object.syntax = message.syntax;
                return object;
            };

            /**
             * Converts this FileDescriptorProto to JSON.
             * @function toJSON
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FileDescriptorProto.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return FileDescriptorProto;
        })();

        protobuf.DescriptorProto = (function() {

            /**
             * Properties of a DescriptorProto.
             * @memberof google.protobuf
             * @interface IDescriptorProto
             * @property {string|null} [name] DescriptorProto name
             * @property {Array.<google.protobuf.IFieldDescriptorProto>|null} [field] DescriptorProto field
             * @property {Array.<google.protobuf.IFieldDescriptorProto>|null} [extension] DescriptorProto extension
             * @property {Array.<google.protobuf.IDescriptorProto>|null} [nestedType] DescriptorProto nestedType
             * @property {Array.<google.protobuf.IEnumDescriptorProto>|null} [enumType] DescriptorProto enumType
             * @property {Array.<google.protobuf.DescriptorProto.IExtensionRange>|null} [extensionRange] DescriptorProto extensionRange
             * @property {Array.<google.protobuf.IOneofDescriptorProto>|null} [oneofDecl] DescriptorProto oneofDecl
             * @property {google.protobuf.IMessageOptions|null} [options] DescriptorProto options
             * @property {Array.<google.protobuf.DescriptorProto.IReservedRange>|null} [reservedRange] DescriptorProto reservedRange
             * @property {Array.<string>|null} [reservedName] DescriptorProto reservedName
             */

            /**
             * Constructs a new DescriptorProto.
             * @memberof google.protobuf
             * @classdesc Represents a DescriptorProto.
             * @implements IDescriptorProto
             * @constructor
             * @param {google.protobuf.IDescriptorProto=} [properties] Properties to set
             */
            function DescriptorProto(properties) {
                this.field = [];
                this.extension = [];
                this.nestedType = [];
                this.enumType = [];
                this.extensionRange = [];
                this.oneofDecl = [];
                this.reservedRange = [];
                this.reservedName = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DescriptorProto name.
             * @member {string} name
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.name = "";

            /**
             * DescriptorProto field.
             * @member {Array.<google.protobuf.IFieldDescriptorProto>} field
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.field = $util.emptyArray;

            /**
             * DescriptorProto extension.
             * @member {Array.<google.protobuf.IFieldDescriptorProto>} extension
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.extension = $util.emptyArray;

            /**
             * DescriptorProto nestedType.
             * @member {Array.<google.protobuf.IDescriptorProto>} nestedType
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.nestedType = $util.emptyArray;

            /**
             * DescriptorProto enumType.
             * @member {Array.<google.protobuf.IEnumDescriptorProto>} enumType
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.enumType = $util.emptyArray;

            /**
             * DescriptorProto extensionRange.
             * @member {Array.<google.protobuf.DescriptorProto.IExtensionRange>} extensionRange
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.extensionRange = $util.emptyArray;

            /**
             * DescriptorProto oneofDecl.
             * @member {Array.<google.protobuf.IOneofDescriptorProto>} oneofDecl
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.oneofDecl = $util.emptyArray;

            /**
             * DescriptorProto options.
             * @member {google.protobuf.IMessageOptions|null|undefined} options
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.options = null;

            /**
             * DescriptorProto reservedRange.
             * @member {Array.<google.protobuf.DescriptorProto.IReservedRange>} reservedRange
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.reservedRange = $util.emptyArray;

            /**
             * DescriptorProto reservedName.
             * @member {Array.<string>} reservedName
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.reservedName = $util.emptyArray;

            /**
             * Creates a new DescriptorProto instance using the specified properties.
             * @function create
             * @memberof google.protobuf.DescriptorProto
             * @static
             * @param {google.protobuf.IDescriptorProto=} [properties] Properties to set
             * @returns {google.protobuf.DescriptorProto} DescriptorProto instance
             */
            DescriptorProto.create = function create(properties) {
                return new DescriptorProto(properties);
            };

            /**
             * Encodes the specified DescriptorProto message. Does not implicitly {@link google.protobuf.DescriptorProto.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.DescriptorProto
             * @static
             * @param {google.protobuf.IDescriptorProto} message DescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DescriptorProto.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.field != null && message.field.length)
                    for (var i = 0; i < message.field.length; ++i)
                        $root.google.protobuf.FieldDescriptorProto.encode(message.field[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.nestedType != null && message.nestedType.length)
                    for (var i = 0; i < message.nestedType.length; ++i)
                        $root.google.protobuf.DescriptorProto.encode(message.nestedType[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.enumType != null && message.enumType.length)
                    for (var i = 0; i < message.enumType.length; ++i)
                        $root.google.protobuf.EnumDescriptorProto.encode(message.enumType[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.extensionRange != null && message.extensionRange.length)
                    for (var i = 0; i < message.extensionRange.length; ++i)
                        $root.google.protobuf.DescriptorProto.ExtensionRange.encode(message.extensionRange[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.extension != null && message.extension.length)
                    for (var i = 0; i < message.extension.length; ++i)
                        $root.google.protobuf.FieldDescriptorProto.encode(message.extension[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                    $root.google.protobuf.MessageOptions.encode(message.options, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.oneofDecl != null && message.oneofDecl.length)
                    for (var i = 0; i < message.oneofDecl.length; ++i)
                        $root.google.protobuf.OneofDescriptorProto.encode(message.oneofDecl[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                if (message.reservedRange != null && message.reservedRange.length)
                    for (var i = 0; i < message.reservedRange.length; ++i)
                        $root.google.protobuf.DescriptorProto.ReservedRange.encode(message.reservedRange[i], writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                if (message.reservedName != null && message.reservedName.length)
                    for (var i = 0; i < message.reservedName.length; ++i)
                        writer.uint32(/* id 10, wireType 2 =*/82).string(message.reservedName[i]);
                return writer;
            };

            /**
             * Encodes the specified DescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.DescriptorProto.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.DescriptorProto
             * @static
             * @param {google.protobuf.IDescriptorProto} message DescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DescriptorProto message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.DescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.DescriptorProto} DescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DescriptorProto.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.DescriptorProto();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        if (!(message.field && message.field.length))
                            message.field = [];
                        message.field.push($root.google.protobuf.FieldDescriptorProto.decode(reader, reader.uint32()));
                        break;
                    case 6:
                        if (!(message.extension && message.extension.length))
                            message.extension = [];
                        message.extension.push($root.google.protobuf.FieldDescriptorProto.decode(reader, reader.uint32()));
                        break;
                    case 3:
                        if (!(message.nestedType && message.nestedType.length))
                            message.nestedType = [];
                        message.nestedType.push($root.google.protobuf.DescriptorProto.decode(reader, reader.uint32()));
                        break;
                    case 4:
                        if (!(message.enumType && message.enumType.length))
                            message.enumType = [];
                        message.enumType.push($root.google.protobuf.EnumDescriptorProto.decode(reader, reader.uint32()));
                        break;
                    case 5:
                        if (!(message.extensionRange && message.extensionRange.length))
                            message.extensionRange = [];
                        message.extensionRange.push($root.google.protobuf.DescriptorProto.ExtensionRange.decode(reader, reader.uint32()));
                        break;
                    case 8:
                        if (!(message.oneofDecl && message.oneofDecl.length))
                            message.oneofDecl = [];
                        message.oneofDecl.push($root.google.protobuf.OneofDescriptorProto.decode(reader, reader.uint32()));
                        break;
                    case 7:
                        message.options = $root.google.protobuf.MessageOptions.decode(reader, reader.uint32());
                        break;
                    case 9:
                        if (!(message.reservedRange && message.reservedRange.length))
                            message.reservedRange = [];
                        message.reservedRange.push($root.google.protobuf.DescriptorProto.ReservedRange.decode(reader, reader.uint32()));
                        break;
                    case 10:
                        if (!(message.reservedName && message.reservedName.length))
                            message.reservedName = [];
                        message.reservedName.push(reader.string());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DescriptorProto message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.DescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.DescriptorProto} DescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DescriptorProto message.
             * @function verify
             * @memberof google.protobuf.DescriptorProto
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DescriptorProto.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.field != null && message.hasOwnProperty("field")) {
                    if (!Array.isArray(message.field))
                        return "field: array expected";
                    for (var i = 0; i < message.field.length; ++i) {
                        var error = $root.google.protobuf.FieldDescriptorProto.verify(message.field[i]);
                        if (error)
                            return "field." + error;
                    }
                }
                if (message.extension != null && message.hasOwnProperty("extension")) {
                    if (!Array.isArray(message.extension))
                        return "extension: array expected";
                    for (var i = 0; i < message.extension.length; ++i) {
                        var error = $root.google.protobuf.FieldDescriptorProto.verify(message.extension[i]);
                        if (error)
                            return "extension." + error;
                    }
                }
                if (message.nestedType != null && message.hasOwnProperty("nestedType")) {
                    if (!Array.isArray(message.nestedType))
                        return "nestedType: array expected";
                    for (var i = 0; i < message.nestedType.length; ++i) {
                        var error = $root.google.protobuf.DescriptorProto.verify(message.nestedType[i]);
                        if (error)
                            return "nestedType." + error;
                    }
                }
                if (message.enumType != null && message.hasOwnProperty("enumType")) {
                    if (!Array.isArray(message.enumType))
                        return "enumType: array expected";
                    for (var i = 0; i < message.enumType.length; ++i) {
                        var error = $root.google.protobuf.EnumDescriptorProto.verify(message.enumType[i]);
                        if (error)
                            return "enumType." + error;
                    }
                }
                if (message.extensionRange != null && message.hasOwnProperty("extensionRange")) {
                    if (!Array.isArray(message.extensionRange))
                        return "extensionRange: array expected";
                    for (var i = 0; i < message.extensionRange.length; ++i) {
                        var error = $root.google.protobuf.DescriptorProto.ExtensionRange.verify(message.extensionRange[i]);
                        if (error)
                            return "extensionRange." + error;
                    }
                }
                if (message.oneofDecl != null && message.hasOwnProperty("oneofDecl")) {
                    if (!Array.isArray(message.oneofDecl))
                        return "oneofDecl: array expected";
                    for (var i = 0; i < message.oneofDecl.length; ++i) {
                        var error = $root.google.protobuf.OneofDescriptorProto.verify(message.oneofDecl[i]);
                        if (error)
                            return "oneofDecl." + error;
                    }
                }
                if (message.options != null && message.hasOwnProperty("options")) {
                    var error = $root.google.protobuf.MessageOptions.verify(message.options);
                    if (error)
                        return "options." + error;
                }
                if (message.reservedRange != null && message.hasOwnProperty("reservedRange")) {
                    if (!Array.isArray(message.reservedRange))
                        return "reservedRange: array expected";
                    for (var i = 0; i < message.reservedRange.length; ++i) {
                        var error = $root.google.protobuf.DescriptorProto.ReservedRange.verify(message.reservedRange[i]);
                        if (error)
                            return "reservedRange." + error;
                    }
                }
                if (message.reservedName != null && message.hasOwnProperty("reservedName")) {
                    if (!Array.isArray(message.reservedName))
                        return "reservedName: array expected";
                    for (var i = 0; i < message.reservedName.length; ++i)
                        if (!$util.isString(message.reservedName[i]))
                            return "reservedName: string[] expected";
                }
                return null;
            };

            /**
             * Creates a DescriptorProto message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.DescriptorProto
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.DescriptorProto} DescriptorProto
             */
            DescriptorProto.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.DescriptorProto)
                    return object;
                var message = new $root.google.protobuf.DescriptorProto();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.field) {
                    if (!Array.isArray(object.field))
                        throw TypeError(".google.protobuf.DescriptorProto.field: array expected");
                    message.field = [];
                    for (var i = 0; i < object.field.length; ++i) {
                        if (typeof object.field[i] !== "object")
                            throw TypeError(".google.protobuf.DescriptorProto.field: object expected");
                        message.field[i] = $root.google.protobuf.FieldDescriptorProto.fromObject(object.field[i]);
                    }
                }
                if (object.extension) {
                    if (!Array.isArray(object.extension))
                        throw TypeError(".google.protobuf.DescriptorProto.extension: array expected");
                    message.extension = [];
                    for (var i = 0; i < object.extension.length; ++i) {
                        if (typeof object.extension[i] !== "object")
                            throw TypeError(".google.protobuf.DescriptorProto.extension: object expected");
                        message.extension[i] = $root.google.protobuf.FieldDescriptorProto.fromObject(object.extension[i]);
                    }
                }
                if (object.nestedType) {
                    if (!Array.isArray(object.nestedType))
                        throw TypeError(".google.protobuf.DescriptorProto.nestedType: array expected");
                    message.nestedType = [];
                    for (var i = 0; i < object.nestedType.length; ++i) {
                        if (typeof object.nestedType[i] !== "object")
                            throw TypeError(".google.protobuf.DescriptorProto.nestedType: object expected");
                        message.nestedType[i] = $root.google.protobuf.DescriptorProto.fromObject(object.nestedType[i]);
                    }
                }
                if (object.enumType) {
                    if (!Array.isArray(object.enumType))
                        throw TypeError(".google.protobuf.DescriptorProto.enumType: array expected");
                    message.enumType = [];
                    for (var i = 0; i < object.enumType.length; ++i) {
                        if (typeof object.enumType[i] !== "object")
                            throw TypeError(".google.protobuf.DescriptorProto.enumType: object expected");
                        message.enumType[i] = $root.google.protobuf.EnumDescriptorProto.fromObject(object.enumType[i]);
                    }
                }
                if (object.extensionRange) {
                    if (!Array.isArray(object.extensionRange))
                        throw TypeError(".google.protobuf.DescriptorProto.extensionRange: array expected");
                    message.extensionRange = [];
                    for (var i = 0; i < object.extensionRange.length; ++i) {
                        if (typeof object.extensionRange[i] !== "object")
                            throw TypeError(".google.protobuf.DescriptorProto.extensionRange: object expected");
                        message.extensionRange[i] = $root.google.protobuf.DescriptorProto.ExtensionRange.fromObject(object.extensionRange[i]);
                    }
                }
                if (object.oneofDecl) {
                    if (!Array.isArray(object.oneofDecl))
                        throw TypeError(".google.protobuf.DescriptorProto.oneofDecl: array expected");
                    message.oneofDecl = [];
                    for (var i = 0; i < object.oneofDecl.length; ++i) {
                        if (typeof object.oneofDecl[i] !== "object")
                            throw TypeError(".google.protobuf.DescriptorProto.oneofDecl: object expected");
                        message.oneofDecl[i] = $root.google.protobuf.OneofDescriptorProto.fromObject(object.oneofDecl[i]);
                    }
                }
                if (object.options != null) {
                    if (typeof object.options !== "object")
                        throw TypeError(".google.protobuf.DescriptorProto.options: object expected");
                    message.options = $root.google.protobuf.MessageOptions.fromObject(object.options);
                }
                if (object.reservedRange) {
                    if (!Array.isArray(object.reservedRange))
                        throw TypeError(".google.protobuf.DescriptorProto.reservedRange: array expected");
                    message.reservedRange = [];
                    for (var i = 0; i < object.reservedRange.length; ++i) {
                        if (typeof object.reservedRange[i] !== "object")
                            throw TypeError(".google.protobuf.DescriptorProto.reservedRange: object expected");
                        message.reservedRange[i] = $root.google.protobuf.DescriptorProto.ReservedRange.fromObject(object.reservedRange[i]);
                    }
                }
                if (object.reservedName) {
                    if (!Array.isArray(object.reservedName))
                        throw TypeError(".google.protobuf.DescriptorProto.reservedName: array expected");
                    message.reservedName = [];
                    for (var i = 0; i < object.reservedName.length; ++i)
                        message.reservedName[i] = String(object.reservedName[i]);
                }
                return message;
            };

            /**
             * Creates a plain object from a DescriptorProto message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.DescriptorProto
             * @static
             * @param {google.protobuf.DescriptorProto} message DescriptorProto
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DescriptorProto.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.field = [];
                    object.nestedType = [];
                    object.enumType = [];
                    object.extensionRange = [];
                    object.extension = [];
                    object.oneofDecl = [];
                    object.reservedRange = [];
                    object.reservedName = [];
                }
                if (options.defaults) {
                    object.name = "";
                    object.options = null;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.field && message.field.length) {
                    object.field = [];
                    for (var j = 0; j < message.field.length; ++j)
                        object.field[j] = $root.google.protobuf.FieldDescriptorProto.toObject(message.field[j], options);
                }
                if (message.nestedType && message.nestedType.length) {
                    object.nestedType = [];
                    for (var j = 0; j < message.nestedType.length; ++j)
                        object.nestedType[j] = $root.google.protobuf.DescriptorProto.toObject(message.nestedType[j], options);
                }
                if (message.enumType && message.enumType.length) {
                    object.enumType = [];
                    for (var j = 0; j < message.enumType.length; ++j)
                        object.enumType[j] = $root.google.protobuf.EnumDescriptorProto.toObject(message.enumType[j], options);
                }
                if (message.extensionRange && message.extensionRange.length) {
                    object.extensionRange = [];
                    for (var j = 0; j < message.extensionRange.length; ++j)
                        object.extensionRange[j] = $root.google.protobuf.DescriptorProto.ExtensionRange.toObject(message.extensionRange[j], options);
                }
                if (message.extension && message.extension.length) {
                    object.extension = [];
                    for (var j = 0; j < message.extension.length; ++j)
                        object.extension[j] = $root.google.protobuf.FieldDescriptorProto.toObject(message.extension[j], options);
                }
                if (message.options != null && message.hasOwnProperty("options"))
                    object.options = $root.google.protobuf.MessageOptions.toObject(message.options, options);
                if (message.oneofDecl && message.oneofDecl.length) {
                    object.oneofDecl = [];
                    for (var j = 0; j < message.oneofDecl.length; ++j)
                        object.oneofDecl[j] = $root.google.protobuf.OneofDescriptorProto.toObject(message.oneofDecl[j], options);
                }
                if (message.reservedRange && message.reservedRange.length) {
                    object.reservedRange = [];
                    for (var j = 0; j < message.reservedRange.length; ++j)
                        object.reservedRange[j] = $root.google.protobuf.DescriptorProto.ReservedRange.toObject(message.reservedRange[j], options);
                }
                if (message.reservedName && message.reservedName.length) {
                    object.reservedName = [];
                    for (var j = 0; j < message.reservedName.length; ++j)
                        object.reservedName[j] = message.reservedName[j];
                }
                return object;
            };

            /**
             * Converts this DescriptorProto to JSON.
             * @function toJSON
             * @memberof google.protobuf.DescriptorProto
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DescriptorProto.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            DescriptorProto.ExtensionRange = (function() {

                /**
                 * Properties of an ExtensionRange.
                 * @memberof google.protobuf.DescriptorProto
                 * @interface IExtensionRange
                 * @property {number|null} [start] ExtensionRange start
                 * @property {number|null} [end] ExtensionRange end
                 */

                /**
                 * Constructs a new ExtensionRange.
                 * @memberof google.protobuf.DescriptorProto
                 * @classdesc Represents an ExtensionRange.
                 * @implements IExtensionRange
                 * @constructor
                 * @param {google.protobuf.DescriptorProto.IExtensionRange=} [properties] Properties to set
                 */
                function ExtensionRange(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ExtensionRange start.
                 * @member {number} start
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @instance
                 */
                ExtensionRange.prototype.start = 0;

                /**
                 * ExtensionRange end.
                 * @member {number} end
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @instance
                 */
                ExtensionRange.prototype.end = 0;

                /**
                 * Creates a new ExtensionRange instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @static
                 * @param {google.protobuf.DescriptorProto.IExtensionRange=} [properties] Properties to set
                 * @returns {google.protobuf.DescriptorProto.ExtensionRange} ExtensionRange instance
                 */
                ExtensionRange.create = function create(properties) {
                    return new ExtensionRange(properties);
                };

                /**
                 * Encodes the specified ExtensionRange message. Does not implicitly {@link google.protobuf.DescriptorProto.ExtensionRange.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @static
                 * @param {google.protobuf.DescriptorProto.IExtensionRange} message ExtensionRange message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ExtensionRange.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.start != null && Object.hasOwnProperty.call(message, "start"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.start);
                    if (message.end != null && Object.hasOwnProperty.call(message, "end"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.end);
                    return writer;
                };

                /**
                 * Encodes the specified ExtensionRange message, length delimited. Does not implicitly {@link google.protobuf.DescriptorProto.ExtensionRange.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @static
                 * @param {google.protobuf.DescriptorProto.IExtensionRange} message ExtensionRange message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ExtensionRange.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an ExtensionRange message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.DescriptorProto.ExtensionRange} ExtensionRange
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ExtensionRange.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.DescriptorProto.ExtensionRange();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.start = reader.int32();
                            break;
                        case 2:
                            message.end = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an ExtensionRange message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.DescriptorProto.ExtensionRange} ExtensionRange
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ExtensionRange.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an ExtensionRange message.
                 * @function verify
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ExtensionRange.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.start != null && message.hasOwnProperty("start"))
                        if (!$util.isInteger(message.start))
                            return "start: integer expected";
                    if (message.end != null && message.hasOwnProperty("end"))
                        if (!$util.isInteger(message.end))
                            return "end: integer expected";
                    return null;
                };

                /**
                 * Creates an ExtensionRange message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.DescriptorProto.ExtensionRange} ExtensionRange
                 */
                ExtensionRange.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.DescriptorProto.ExtensionRange)
                        return object;
                    var message = new $root.google.protobuf.DescriptorProto.ExtensionRange();
                    if (object.start != null)
                        message.start = object.start | 0;
                    if (object.end != null)
                        message.end = object.end | 0;
                    return message;
                };

                /**
                 * Creates a plain object from an ExtensionRange message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @static
                 * @param {google.protobuf.DescriptorProto.ExtensionRange} message ExtensionRange
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ExtensionRange.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.start = 0;
                        object.end = 0;
                    }
                    if (message.start != null && message.hasOwnProperty("start"))
                        object.start = message.start;
                    if (message.end != null && message.hasOwnProperty("end"))
                        object.end = message.end;
                    return object;
                };

                /**
                 * Converts this ExtensionRange to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ExtensionRange.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ExtensionRange;
            })();

            DescriptorProto.ReservedRange = (function() {

                /**
                 * Properties of a ReservedRange.
                 * @memberof google.protobuf.DescriptorProto
                 * @interface IReservedRange
                 * @property {number|null} [start] ReservedRange start
                 * @property {number|null} [end] ReservedRange end
                 */

                /**
                 * Constructs a new ReservedRange.
                 * @memberof google.protobuf.DescriptorProto
                 * @classdesc Represents a ReservedRange.
                 * @implements IReservedRange
                 * @constructor
                 * @param {google.protobuf.DescriptorProto.IReservedRange=} [properties] Properties to set
                 */
                function ReservedRange(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ReservedRange start.
                 * @member {number} start
                 * @memberof google.protobuf.DescriptorProto.ReservedRange
                 * @instance
                 */
                ReservedRange.prototype.start = 0;

                /**
                 * ReservedRange end.
                 * @member {number} end
                 * @memberof google.protobuf.DescriptorProto.ReservedRange
                 * @instance
                 */
                ReservedRange.prototype.end = 0;

                /**
                 * Creates a new ReservedRange instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.DescriptorProto.ReservedRange
                 * @static
                 * @param {google.protobuf.DescriptorProto.IReservedRange=} [properties] Properties to set
                 * @returns {google.protobuf.DescriptorProto.ReservedRange} ReservedRange instance
                 */
                ReservedRange.create = function create(properties) {
                    return new ReservedRange(properties);
                };

                /**
                 * Encodes the specified ReservedRange message. Does not implicitly {@link google.protobuf.DescriptorProto.ReservedRange.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.DescriptorProto.ReservedRange
                 * @static
                 * @param {google.protobuf.DescriptorProto.IReservedRange} message ReservedRange message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ReservedRange.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.start != null && Object.hasOwnProperty.call(message, "start"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.start);
                    if (message.end != null && Object.hasOwnProperty.call(message, "end"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.end);
                    return writer;
                };

                /**
                 * Encodes the specified ReservedRange message, length delimited. Does not implicitly {@link google.protobuf.DescriptorProto.ReservedRange.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.DescriptorProto.ReservedRange
                 * @static
                 * @param {google.protobuf.DescriptorProto.IReservedRange} message ReservedRange message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ReservedRange.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a ReservedRange message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.DescriptorProto.ReservedRange
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.DescriptorProto.ReservedRange} ReservedRange
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ReservedRange.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.DescriptorProto.ReservedRange();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.start = reader.int32();
                            break;
                        case 2:
                            message.end = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a ReservedRange message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.DescriptorProto.ReservedRange
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.DescriptorProto.ReservedRange} ReservedRange
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ReservedRange.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a ReservedRange message.
                 * @function verify
                 * @memberof google.protobuf.DescriptorProto.ReservedRange
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ReservedRange.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.start != null && message.hasOwnProperty("start"))
                        if (!$util.isInteger(message.start))
                            return "start: integer expected";
                    if (message.end != null && message.hasOwnProperty("end"))
                        if (!$util.isInteger(message.end))
                            return "end: integer expected";
                    return null;
                };

                /**
                 * Creates a ReservedRange message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.DescriptorProto.ReservedRange
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.DescriptorProto.ReservedRange} ReservedRange
                 */
                ReservedRange.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.DescriptorProto.ReservedRange)
                        return object;
                    var message = new $root.google.protobuf.DescriptorProto.ReservedRange();
                    if (object.start != null)
                        message.start = object.start | 0;
                    if (object.end != null)
                        message.end = object.end | 0;
                    return message;
                };

                /**
                 * Creates a plain object from a ReservedRange message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.DescriptorProto.ReservedRange
                 * @static
                 * @param {google.protobuf.DescriptorProto.ReservedRange} message ReservedRange
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ReservedRange.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.start = 0;
                        object.end = 0;
                    }
                    if (message.start != null && message.hasOwnProperty("start"))
                        object.start = message.start;
                    if (message.end != null && message.hasOwnProperty("end"))
                        object.end = message.end;
                    return object;
                };

                /**
                 * Converts this ReservedRange to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.DescriptorProto.ReservedRange
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ReservedRange.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ReservedRange;
            })();

            return DescriptorProto;
        })();

        protobuf.FieldDescriptorProto = (function() {

            /**
             * Properties of a FieldDescriptorProto.
             * @memberof google.protobuf
             * @interface IFieldDescriptorProto
             * @property {string|null} [name] FieldDescriptorProto name
             * @property {number|null} [number] FieldDescriptorProto number
             * @property {google.protobuf.FieldDescriptorProto.Label|null} [label] FieldDescriptorProto label
             * @property {google.protobuf.FieldDescriptorProto.Type|null} [type] FieldDescriptorProto type
             * @property {string|null} [typeName] FieldDescriptorProto typeName
             * @property {string|null} [extendee] FieldDescriptorProto extendee
             * @property {string|null} [defaultValue] FieldDescriptorProto defaultValue
             * @property {number|null} [oneofIndex] FieldDescriptorProto oneofIndex
             * @property {string|null} [jsonName] FieldDescriptorProto jsonName
             * @property {google.protobuf.IFieldOptions|null} [options] FieldDescriptorProto options
             */

            /**
             * Constructs a new FieldDescriptorProto.
             * @memberof google.protobuf
             * @classdesc Represents a FieldDescriptorProto.
             * @implements IFieldDescriptorProto
             * @constructor
             * @param {google.protobuf.IFieldDescriptorProto=} [properties] Properties to set
             */
            function FieldDescriptorProto(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FieldDescriptorProto name.
             * @member {string} name
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.name = "";

            /**
             * FieldDescriptorProto number.
             * @member {number} number
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.number = 0;

            /**
             * FieldDescriptorProto label.
             * @member {google.protobuf.FieldDescriptorProto.Label} label
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.label = 1;

            /**
             * FieldDescriptorProto type.
             * @member {google.protobuf.FieldDescriptorProto.Type} type
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.type = 1;

            /**
             * FieldDescriptorProto typeName.
             * @member {string} typeName
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.typeName = "";

            /**
             * FieldDescriptorProto extendee.
             * @member {string} extendee
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.extendee = "";

            /**
             * FieldDescriptorProto defaultValue.
             * @member {string} defaultValue
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.defaultValue = "";

            /**
             * FieldDescriptorProto oneofIndex.
             * @member {number} oneofIndex
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.oneofIndex = 0;

            /**
             * FieldDescriptorProto jsonName.
             * @member {string} jsonName
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.jsonName = "";

            /**
             * FieldDescriptorProto options.
             * @member {google.protobuf.IFieldOptions|null|undefined} options
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.options = null;

            /**
             * Creates a new FieldDescriptorProto instance using the specified properties.
             * @function create
             * @memberof google.protobuf.FieldDescriptorProto
             * @static
             * @param {google.protobuf.IFieldDescriptorProto=} [properties] Properties to set
             * @returns {google.protobuf.FieldDescriptorProto} FieldDescriptorProto instance
             */
            FieldDescriptorProto.create = function create(properties) {
                return new FieldDescriptorProto(properties);
            };

            /**
             * Encodes the specified FieldDescriptorProto message. Does not implicitly {@link google.protobuf.FieldDescriptorProto.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.FieldDescriptorProto
             * @static
             * @param {google.protobuf.IFieldDescriptorProto} message FieldDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FieldDescriptorProto.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.extendee != null && Object.hasOwnProperty.call(message, "extendee"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.extendee);
                if (message.number != null && Object.hasOwnProperty.call(message, "number"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.number);
                if (message.label != null && Object.hasOwnProperty.call(message, "label"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.label);
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.type);
                if (message.typeName != null && Object.hasOwnProperty.call(message, "typeName"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.typeName);
                if (message.defaultValue != null && Object.hasOwnProperty.call(message, "defaultValue"))
                    writer.uint32(/* id 7, wireType 2 =*/58).string(message.defaultValue);
                if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                    $root.google.protobuf.FieldOptions.encode(message.options, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                if (message.oneofIndex != null && Object.hasOwnProperty.call(message, "oneofIndex"))
                    writer.uint32(/* id 9, wireType 0 =*/72).int32(message.oneofIndex);
                if (message.jsonName != null && Object.hasOwnProperty.call(message, "jsonName"))
                    writer.uint32(/* id 10, wireType 2 =*/82).string(message.jsonName);
                return writer;
            };

            /**
             * Encodes the specified FieldDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.FieldDescriptorProto.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.FieldDescriptorProto
             * @static
             * @param {google.protobuf.IFieldDescriptorProto} message FieldDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FieldDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a FieldDescriptorProto message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.FieldDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.FieldDescriptorProto} FieldDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FieldDescriptorProto.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FieldDescriptorProto();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 3:
                        message.number = reader.int32();
                        break;
                    case 4:
                        message.label = reader.int32();
                        break;
                    case 5:
                        message.type = reader.int32();
                        break;
                    case 6:
                        message.typeName = reader.string();
                        break;
                    case 2:
                        message.extendee = reader.string();
                        break;
                    case 7:
                        message.defaultValue = reader.string();
                        break;
                    case 9:
                        message.oneofIndex = reader.int32();
                        break;
                    case 10:
                        message.jsonName = reader.string();
                        break;
                    case 8:
                        message.options = $root.google.protobuf.FieldOptions.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a FieldDescriptorProto message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.FieldDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.FieldDescriptorProto} FieldDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FieldDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a FieldDescriptorProto message.
             * @function verify
             * @memberof google.protobuf.FieldDescriptorProto
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FieldDescriptorProto.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.number != null && message.hasOwnProperty("number"))
                    if (!$util.isInteger(message.number))
                        return "number: integer expected";
                if (message.label != null && message.hasOwnProperty("label"))
                    switch (message.label) {
                    default:
                        return "label: enum value expected";
                    case 1:
                    case 2:
                    case 3:
                        break;
                    }
                if (message.type != null && message.hasOwnProperty("type"))
                    switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                    case 9:
                    case 10:
                    case 11:
                    case 12:
                    case 13:
                    case 14:
                    case 15:
                    case 16:
                    case 17:
                    case 18:
                        break;
                    }
                if (message.typeName != null && message.hasOwnProperty("typeName"))
                    if (!$util.isString(message.typeName))
                        return "typeName: string expected";
                if (message.extendee != null && message.hasOwnProperty("extendee"))
                    if (!$util.isString(message.extendee))
                        return "extendee: string expected";
                if (message.defaultValue != null && message.hasOwnProperty("defaultValue"))
                    if (!$util.isString(message.defaultValue))
                        return "defaultValue: string expected";
                if (message.oneofIndex != null && message.hasOwnProperty("oneofIndex"))
                    if (!$util.isInteger(message.oneofIndex))
                        return "oneofIndex: integer expected";
                if (message.jsonName != null && message.hasOwnProperty("jsonName"))
                    if (!$util.isString(message.jsonName))
                        return "jsonName: string expected";
                if (message.options != null && message.hasOwnProperty("options")) {
                    var error = $root.google.protobuf.FieldOptions.verify(message.options);
                    if (error)
                        return "options." + error;
                }
                return null;
            };

            /**
             * Creates a FieldDescriptorProto message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.FieldDescriptorProto
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.FieldDescriptorProto} FieldDescriptorProto
             */
            FieldDescriptorProto.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.FieldDescriptorProto)
                    return object;
                var message = new $root.google.protobuf.FieldDescriptorProto();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.number != null)
                    message.number = object.number | 0;
                switch (object.label) {
                case "LABEL_OPTIONAL":
                case 1:
                    message.label = 1;
                    break;
                case "LABEL_REQUIRED":
                case 2:
                    message.label = 2;
                    break;
                case "LABEL_REPEATED":
                case 3:
                    message.label = 3;
                    break;
                }
                switch (object.type) {
                case "TYPE_DOUBLE":
                case 1:
                    message.type = 1;
                    break;
                case "TYPE_FLOAT":
                case 2:
                    message.type = 2;
                    break;
                case "TYPE_INT64":
                case 3:
                    message.type = 3;
                    break;
                case "TYPE_UINT64":
                case 4:
                    message.type = 4;
                    break;
                case "TYPE_INT32":
                case 5:
                    message.type = 5;
                    break;
                case "TYPE_FIXED64":
                case 6:
                    message.type = 6;
                    break;
                case "TYPE_FIXED32":
                case 7:
                    message.type = 7;
                    break;
                case "TYPE_BOOL":
                case 8:
                    message.type = 8;
                    break;
                case "TYPE_STRING":
                case 9:
                    message.type = 9;
                    break;
                case "TYPE_GROUP":
                case 10:
                    message.type = 10;
                    break;
                case "TYPE_MESSAGE":
                case 11:
                    message.type = 11;
                    break;
                case "TYPE_BYTES":
                case 12:
                    message.type = 12;
                    break;
                case "TYPE_UINT32":
                case 13:
                    message.type = 13;
                    break;
                case "TYPE_ENUM":
                case 14:
                    message.type = 14;
                    break;
                case "TYPE_SFIXED32":
                case 15:
                    message.type = 15;
                    break;
                case "TYPE_SFIXED64":
                case 16:
                    message.type = 16;
                    break;
                case "TYPE_SINT32":
                case 17:
                    message.type = 17;
                    break;
                case "TYPE_SINT64":
                case 18:
                    message.type = 18;
                    break;
                }
                if (object.typeName != null)
                    message.typeName = String(object.typeName);
                if (object.extendee != null)
                    message.extendee = String(object.extendee);
                if (object.defaultValue != null)
                    message.defaultValue = String(object.defaultValue);
                if (object.oneofIndex != null)
                    message.oneofIndex = object.oneofIndex | 0;
                if (object.jsonName != null)
                    message.jsonName = String(object.jsonName);
                if (object.options != null) {
                    if (typeof object.options !== "object")
                        throw TypeError(".google.protobuf.FieldDescriptorProto.options: object expected");
                    message.options = $root.google.protobuf.FieldOptions.fromObject(object.options);
                }
                return message;
            };

            /**
             * Creates a plain object from a FieldDescriptorProto message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.FieldDescriptorProto
             * @static
             * @param {google.protobuf.FieldDescriptorProto} message FieldDescriptorProto
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FieldDescriptorProto.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.name = "";
                    object.extendee = "";
                    object.number = 0;
                    object.label = options.enums === String ? "LABEL_OPTIONAL" : 1;
                    object.type = options.enums === String ? "TYPE_DOUBLE" : 1;
                    object.typeName = "";
                    object.defaultValue = "";
                    object.options = null;
                    object.oneofIndex = 0;
                    object.jsonName = "";
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.extendee != null && message.hasOwnProperty("extendee"))
                    object.extendee = message.extendee;
                if (message.number != null && message.hasOwnProperty("number"))
                    object.number = message.number;
                if (message.label != null && message.hasOwnProperty("label"))
                    object.label = options.enums === String ? $root.google.protobuf.FieldDescriptorProto.Label[message.label] : message.label;
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.google.protobuf.FieldDescriptorProto.Type[message.type] : message.type;
                if (message.typeName != null && message.hasOwnProperty("typeName"))
                    object.typeName = message.typeName;
                if (message.defaultValue != null && message.hasOwnProperty("defaultValue"))
                    object.defaultValue = message.defaultValue;
                if (message.options != null && message.hasOwnProperty("options"))
                    object.options = $root.google.protobuf.FieldOptions.toObject(message.options, options);
                if (message.oneofIndex != null && message.hasOwnProperty("oneofIndex"))
                    object.oneofIndex = message.oneofIndex;
                if (message.jsonName != null && message.hasOwnProperty("jsonName"))
                    object.jsonName = message.jsonName;
                return object;
            };

            /**
             * Converts this FieldDescriptorProto to JSON.
             * @function toJSON
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FieldDescriptorProto.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Type enum.
             * @name google.protobuf.FieldDescriptorProto.Type
             * @enum {number}
             * @property {number} TYPE_DOUBLE=1 TYPE_DOUBLE value
             * @property {number} TYPE_FLOAT=2 TYPE_FLOAT value
             * @property {number} TYPE_INT64=3 TYPE_INT64 value
             * @property {number} TYPE_UINT64=4 TYPE_UINT64 value
             * @property {number} TYPE_INT32=5 TYPE_INT32 value
             * @property {number} TYPE_FIXED64=6 TYPE_FIXED64 value
             * @property {number} TYPE_FIXED32=7 TYPE_FIXED32 value
             * @property {number} TYPE_BOOL=8 TYPE_BOOL value
             * @property {number} TYPE_STRING=9 TYPE_STRING value
             * @property {number} TYPE_GROUP=10 TYPE_GROUP value
             * @property {number} TYPE_MESSAGE=11 TYPE_MESSAGE value
             * @property {number} TYPE_BYTES=12 TYPE_BYTES value
             * @property {number} TYPE_UINT32=13 TYPE_UINT32 value
             * @property {number} TYPE_ENUM=14 TYPE_ENUM value
             * @property {number} TYPE_SFIXED32=15 TYPE_SFIXED32 value
             * @property {number} TYPE_SFIXED64=16 TYPE_SFIXED64 value
             * @property {number} TYPE_SINT32=17 TYPE_SINT32 value
             * @property {number} TYPE_SINT64=18 TYPE_SINT64 value
             */
            FieldDescriptorProto.Type = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[1] = "TYPE_DOUBLE"] = 1;
                values[valuesById[2] = "TYPE_FLOAT"] = 2;
                values[valuesById[3] = "TYPE_INT64"] = 3;
                values[valuesById[4] = "TYPE_UINT64"] = 4;
                values[valuesById[5] = "TYPE_INT32"] = 5;
                values[valuesById[6] = "TYPE_FIXED64"] = 6;
                values[valuesById[7] = "TYPE_FIXED32"] = 7;
                values[valuesById[8] = "TYPE_BOOL"] = 8;
                values[valuesById[9] = "TYPE_STRING"] = 9;
                values[valuesById[10] = "TYPE_GROUP"] = 10;
                values[valuesById[11] = "TYPE_MESSAGE"] = 11;
                values[valuesById[12] = "TYPE_BYTES"] = 12;
                values[valuesById[13] = "TYPE_UINT32"] = 13;
                values[valuesById[14] = "TYPE_ENUM"] = 14;
                values[valuesById[15] = "TYPE_SFIXED32"] = 15;
                values[valuesById[16] = "TYPE_SFIXED64"] = 16;
                values[valuesById[17] = "TYPE_SINT32"] = 17;
                values[valuesById[18] = "TYPE_SINT64"] = 18;
                return values;
            })();

            /**
             * Label enum.
             * @name google.protobuf.FieldDescriptorProto.Label
             * @enum {number}
             * @property {number} LABEL_OPTIONAL=1 LABEL_OPTIONAL value
             * @property {number} LABEL_REQUIRED=2 LABEL_REQUIRED value
             * @property {number} LABEL_REPEATED=3 LABEL_REPEATED value
             */
            FieldDescriptorProto.Label = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[1] = "LABEL_OPTIONAL"] = 1;
                values[valuesById[2] = "LABEL_REQUIRED"] = 2;
                values[valuesById[3] = "LABEL_REPEATED"] = 3;
                return values;
            })();

            return FieldDescriptorProto;
        })();

        protobuf.OneofDescriptorProto = (function() {

            /**
             * Properties of an OneofDescriptorProto.
             * @memberof google.protobuf
             * @interface IOneofDescriptorProto
             * @property {string|null} [name] OneofDescriptorProto name
             * @property {google.protobuf.IOneofOptions|null} [options] OneofDescriptorProto options
             */

            /**
             * Constructs a new OneofDescriptorProto.
             * @memberof google.protobuf
             * @classdesc Represents an OneofDescriptorProto.
             * @implements IOneofDescriptorProto
             * @constructor
             * @param {google.protobuf.IOneofDescriptorProto=} [properties] Properties to set
             */
            function OneofDescriptorProto(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * OneofDescriptorProto name.
             * @member {string} name
             * @memberof google.protobuf.OneofDescriptorProto
             * @instance
             */
            OneofDescriptorProto.prototype.name = "";

            /**
             * OneofDescriptorProto options.
             * @member {google.protobuf.IOneofOptions|null|undefined} options
             * @memberof google.protobuf.OneofDescriptorProto
             * @instance
             */
            OneofDescriptorProto.prototype.options = null;

            /**
             * Creates a new OneofDescriptorProto instance using the specified properties.
             * @function create
             * @memberof google.protobuf.OneofDescriptorProto
             * @static
             * @param {google.protobuf.IOneofDescriptorProto=} [properties] Properties to set
             * @returns {google.protobuf.OneofDescriptorProto} OneofDescriptorProto instance
             */
            OneofDescriptorProto.create = function create(properties) {
                return new OneofDescriptorProto(properties);
            };

            /**
             * Encodes the specified OneofDescriptorProto message. Does not implicitly {@link google.protobuf.OneofDescriptorProto.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.OneofDescriptorProto
             * @static
             * @param {google.protobuf.IOneofDescriptorProto} message OneofDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OneofDescriptorProto.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                    $root.google.protobuf.OneofOptions.encode(message.options, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified OneofDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.OneofDescriptorProto.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.OneofDescriptorProto
             * @static
             * @param {google.protobuf.IOneofDescriptorProto} message OneofDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OneofDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an OneofDescriptorProto message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.OneofDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.OneofDescriptorProto} OneofDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OneofDescriptorProto.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.OneofDescriptorProto();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message.options = $root.google.protobuf.OneofOptions.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an OneofDescriptorProto message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.OneofDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.OneofDescriptorProto} OneofDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OneofDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an OneofDescriptorProto message.
             * @function verify
             * @memberof google.protobuf.OneofDescriptorProto
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            OneofDescriptorProto.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.options != null && message.hasOwnProperty("options")) {
                    var error = $root.google.protobuf.OneofOptions.verify(message.options);
                    if (error)
                        return "options." + error;
                }
                return null;
            };

            /**
             * Creates an OneofDescriptorProto message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.OneofDescriptorProto
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.OneofDescriptorProto} OneofDescriptorProto
             */
            OneofDescriptorProto.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.OneofDescriptorProto)
                    return object;
                var message = new $root.google.protobuf.OneofDescriptorProto();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.options != null) {
                    if (typeof object.options !== "object")
                        throw TypeError(".google.protobuf.OneofDescriptorProto.options: object expected");
                    message.options = $root.google.protobuf.OneofOptions.fromObject(object.options);
                }
                return message;
            };

            /**
             * Creates a plain object from an OneofDescriptorProto message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.OneofDescriptorProto
             * @static
             * @param {google.protobuf.OneofDescriptorProto} message OneofDescriptorProto
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            OneofDescriptorProto.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.name = "";
                    object.options = null;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.options != null && message.hasOwnProperty("options"))
                    object.options = $root.google.protobuf.OneofOptions.toObject(message.options, options);
                return object;
            };

            /**
             * Converts this OneofDescriptorProto to JSON.
             * @function toJSON
             * @memberof google.protobuf.OneofDescriptorProto
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            OneofDescriptorProto.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return OneofDescriptorProto;
        })();

        protobuf.EnumDescriptorProto = (function() {

            /**
             * Properties of an EnumDescriptorProto.
             * @memberof google.protobuf
             * @interface IEnumDescriptorProto
             * @property {string|null} [name] EnumDescriptorProto name
             * @property {Array.<google.protobuf.IEnumValueDescriptorProto>|null} [value] EnumDescriptorProto value
             * @property {google.protobuf.IEnumOptions|null} [options] EnumDescriptorProto options
             */

            /**
             * Constructs a new EnumDescriptorProto.
             * @memberof google.protobuf
             * @classdesc Represents an EnumDescriptorProto.
             * @implements IEnumDescriptorProto
             * @constructor
             * @param {google.protobuf.IEnumDescriptorProto=} [properties] Properties to set
             */
            function EnumDescriptorProto(properties) {
                this.value = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * EnumDescriptorProto name.
             * @member {string} name
             * @memberof google.protobuf.EnumDescriptorProto
             * @instance
             */
            EnumDescriptorProto.prototype.name = "";

            /**
             * EnumDescriptorProto value.
             * @member {Array.<google.protobuf.IEnumValueDescriptorProto>} value
             * @memberof google.protobuf.EnumDescriptorProto
             * @instance
             */
            EnumDescriptorProto.prototype.value = $util.emptyArray;

            /**
             * EnumDescriptorProto options.
             * @member {google.protobuf.IEnumOptions|null|undefined} options
             * @memberof google.protobuf.EnumDescriptorProto
             * @instance
             */
            EnumDescriptorProto.prototype.options = null;

            /**
             * Creates a new EnumDescriptorProto instance using the specified properties.
             * @function create
             * @memberof google.protobuf.EnumDescriptorProto
             * @static
             * @param {google.protobuf.IEnumDescriptorProto=} [properties] Properties to set
             * @returns {google.protobuf.EnumDescriptorProto} EnumDescriptorProto instance
             */
            EnumDescriptorProto.create = function create(properties) {
                return new EnumDescriptorProto(properties);
            };

            /**
             * Encodes the specified EnumDescriptorProto message. Does not implicitly {@link google.protobuf.EnumDescriptorProto.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.EnumDescriptorProto
             * @static
             * @param {google.protobuf.IEnumDescriptorProto} message EnumDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EnumDescriptorProto.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.value != null && message.value.length)
                    for (var i = 0; i < message.value.length; ++i)
                        $root.google.protobuf.EnumValueDescriptorProto.encode(message.value[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                    $root.google.protobuf.EnumOptions.encode(message.options, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified EnumDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.EnumDescriptorProto.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.EnumDescriptorProto
             * @static
             * @param {google.protobuf.IEnumDescriptorProto} message EnumDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EnumDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an EnumDescriptorProto message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.EnumDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.EnumDescriptorProto} EnumDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnumDescriptorProto.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.EnumDescriptorProto();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        if (!(message.value && message.value.length))
                            message.value = [];
                        message.value.push($root.google.protobuf.EnumValueDescriptorProto.decode(reader, reader.uint32()));
                        break;
                    case 3:
                        message.options = $root.google.protobuf.EnumOptions.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an EnumDescriptorProto message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.EnumDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.EnumDescriptorProto} EnumDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnumDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an EnumDescriptorProto message.
             * @function verify
             * @memberof google.protobuf.EnumDescriptorProto
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            EnumDescriptorProto.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.value != null && message.hasOwnProperty("value")) {
                    if (!Array.isArray(message.value))
                        return "value: array expected";
                    for (var i = 0; i < message.value.length; ++i) {
                        var error = $root.google.protobuf.EnumValueDescriptorProto.verify(message.value[i]);
                        if (error)
                            return "value." + error;
                    }
                }
                if (message.options != null && message.hasOwnProperty("options")) {
                    var error = $root.google.protobuf.EnumOptions.verify(message.options);
                    if (error)
                        return "options." + error;
                }
                return null;
            };

            /**
             * Creates an EnumDescriptorProto message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.EnumDescriptorProto
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.EnumDescriptorProto} EnumDescriptorProto
             */
            EnumDescriptorProto.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.EnumDescriptorProto)
                    return object;
                var message = new $root.google.protobuf.EnumDescriptorProto();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.value) {
                    if (!Array.isArray(object.value))
                        throw TypeError(".google.protobuf.EnumDescriptorProto.value: array expected");
                    message.value = [];
                    for (var i = 0; i < object.value.length; ++i) {
                        if (typeof object.value[i] !== "object")
                            throw TypeError(".google.protobuf.EnumDescriptorProto.value: object expected");
                        message.value[i] = $root.google.protobuf.EnumValueDescriptorProto.fromObject(object.value[i]);
                    }
                }
                if (object.options != null) {
                    if (typeof object.options !== "object")
                        throw TypeError(".google.protobuf.EnumDescriptorProto.options: object expected");
                    message.options = $root.google.protobuf.EnumOptions.fromObject(object.options);
                }
                return message;
            };

            /**
             * Creates a plain object from an EnumDescriptorProto message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.EnumDescriptorProto
             * @static
             * @param {google.protobuf.EnumDescriptorProto} message EnumDescriptorProto
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            EnumDescriptorProto.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.value = [];
                if (options.defaults) {
                    object.name = "";
                    object.options = null;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.value && message.value.length) {
                    object.value = [];
                    for (var j = 0; j < message.value.length; ++j)
                        object.value[j] = $root.google.protobuf.EnumValueDescriptorProto.toObject(message.value[j], options);
                }
                if (message.options != null && message.hasOwnProperty("options"))
                    object.options = $root.google.protobuf.EnumOptions.toObject(message.options, options);
                return object;
            };

            /**
             * Converts this EnumDescriptorProto to JSON.
             * @function toJSON
             * @memberof google.protobuf.EnumDescriptorProto
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            EnumDescriptorProto.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return EnumDescriptorProto;
        })();

        protobuf.EnumValueDescriptorProto = (function() {

            /**
             * Properties of an EnumValueDescriptorProto.
             * @memberof google.protobuf
             * @interface IEnumValueDescriptorProto
             * @property {string|null} [name] EnumValueDescriptorProto name
             * @property {number|null} [number] EnumValueDescriptorProto number
             * @property {google.protobuf.IEnumValueOptions|null} [options] EnumValueDescriptorProto options
             */

            /**
             * Constructs a new EnumValueDescriptorProto.
             * @memberof google.protobuf
             * @classdesc Represents an EnumValueDescriptorProto.
             * @implements IEnumValueDescriptorProto
             * @constructor
             * @param {google.protobuf.IEnumValueDescriptorProto=} [properties] Properties to set
             */
            function EnumValueDescriptorProto(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * EnumValueDescriptorProto name.
             * @member {string} name
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @instance
             */
            EnumValueDescriptorProto.prototype.name = "";

            /**
             * EnumValueDescriptorProto number.
             * @member {number} number
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @instance
             */
            EnumValueDescriptorProto.prototype.number = 0;

            /**
             * EnumValueDescriptorProto options.
             * @member {google.protobuf.IEnumValueOptions|null|undefined} options
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @instance
             */
            EnumValueDescriptorProto.prototype.options = null;

            /**
             * Creates a new EnumValueDescriptorProto instance using the specified properties.
             * @function create
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @static
             * @param {google.protobuf.IEnumValueDescriptorProto=} [properties] Properties to set
             * @returns {google.protobuf.EnumValueDescriptorProto} EnumValueDescriptorProto instance
             */
            EnumValueDescriptorProto.create = function create(properties) {
                return new EnumValueDescriptorProto(properties);
            };

            /**
             * Encodes the specified EnumValueDescriptorProto message. Does not implicitly {@link google.protobuf.EnumValueDescriptorProto.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @static
             * @param {google.protobuf.IEnumValueDescriptorProto} message EnumValueDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EnumValueDescriptorProto.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.number != null && Object.hasOwnProperty.call(message, "number"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.number);
                if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                    $root.google.protobuf.EnumValueOptions.encode(message.options, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified EnumValueDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.EnumValueDescriptorProto.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @static
             * @param {google.protobuf.IEnumValueDescriptorProto} message EnumValueDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EnumValueDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an EnumValueDescriptorProto message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.EnumValueDescriptorProto} EnumValueDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnumValueDescriptorProto.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.EnumValueDescriptorProto();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message.number = reader.int32();
                        break;
                    case 3:
                        message.options = $root.google.protobuf.EnumValueOptions.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an EnumValueDescriptorProto message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.EnumValueDescriptorProto} EnumValueDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnumValueDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an EnumValueDescriptorProto message.
             * @function verify
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            EnumValueDescriptorProto.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.number != null && message.hasOwnProperty("number"))
                    if (!$util.isInteger(message.number))
                        return "number: integer expected";
                if (message.options != null && message.hasOwnProperty("options")) {
                    var error = $root.google.protobuf.EnumValueOptions.verify(message.options);
                    if (error)
                        return "options." + error;
                }
                return null;
            };

            /**
             * Creates an EnumValueDescriptorProto message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.EnumValueDescriptorProto} EnumValueDescriptorProto
             */
            EnumValueDescriptorProto.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.EnumValueDescriptorProto)
                    return object;
                var message = new $root.google.protobuf.EnumValueDescriptorProto();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.number != null)
                    message.number = object.number | 0;
                if (object.options != null) {
                    if (typeof object.options !== "object")
                        throw TypeError(".google.protobuf.EnumValueDescriptorProto.options: object expected");
                    message.options = $root.google.protobuf.EnumValueOptions.fromObject(object.options);
                }
                return message;
            };

            /**
             * Creates a plain object from an EnumValueDescriptorProto message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @static
             * @param {google.protobuf.EnumValueDescriptorProto} message EnumValueDescriptorProto
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            EnumValueDescriptorProto.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.name = "";
                    object.number = 0;
                    object.options = null;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.number != null && message.hasOwnProperty("number"))
                    object.number = message.number;
                if (message.options != null && message.hasOwnProperty("options"))
                    object.options = $root.google.protobuf.EnumValueOptions.toObject(message.options, options);
                return object;
            };

            /**
             * Converts this EnumValueDescriptorProto to JSON.
             * @function toJSON
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            EnumValueDescriptorProto.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return EnumValueDescriptorProto;
        })();

        protobuf.ServiceDescriptorProto = (function() {

            /**
             * Properties of a ServiceDescriptorProto.
             * @memberof google.protobuf
             * @interface IServiceDescriptorProto
             * @property {string|null} [name] ServiceDescriptorProto name
             * @property {Array.<google.protobuf.IMethodDescriptorProto>|null} [method] ServiceDescriptorProto method
             * @property {google.protobuf.IServiceOptions|null} [options] ServiceDescriptorProto options
             */

            /**
             * Constructs a new ServiceDescriptorProto.
             * @memberof google.protobuf
             * @classdesc Represents a ServiceDescriptorProto.
             * @implements IServiceDescriptorProto
             * @constructor
             * @param {google.protobuf.IServiceDescriptorProto=} [properties] Properties to set
             */
            function ServiceDescriptorProto(properties) {
                this.method = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ServiceDescriptorProto name.
             * @member {string} name
             * @memberof google.protobuf.ServiceDescriptorProto
             * @instance
             */
            ServiceDescriptorProto.prototype.name = "";

            /**
             * ServiceDescriptorProto method.
             * @member {Array.<google.protobuf.IMethodDescriptorProto>} method
             * @memberof google.protobuf.ServiceDescriptorProto
             * @instance
             */
            ServiceDescriptorProto.prototype.method = $util.emptyArray;

            /**
             * ServiceDescriptorProto options.
             * @member {google.protobuf.IServiceOptions|null|undefined} options
             * @memberof google.protobuf.ServiceDescriptorProto
             * @instance
             */
            ServiceDescriptorProto.prototype.options = null;

            /**
             * Creates a new ServiceDescriptorProto instance using the specified properties.
             * @function create
             * @memberof google.protobuf.ServiceDescriptorProto
             * @static
             * @param {google.protobuf.IServiceDescriptorProto=} [properties] Properties to set
             * @returns {google.protobuf.ServiceDescriptorProto} ServiceDescriptorProto instance
             */
            ServiceDescriptorProto.create = function create(properties) {
                return new ServiceDescriptorProto(properties);
            };

            /**
             * Encodes the specified ServiceDescriptorProto message. Does not implicitly {@link google.protobuf.ServiceDescriptorProto.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.ServiceDescriptorProto
             * @static
             * @param {google.protobuf.IServiceDescriptorProto} message ServiceDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ServiceDescriptorProto.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.method != null && message.method.length)
                    for (var i = 0; i < message.method.length; ++i)
                        $root.google.protobuf.MethodDescriptorProto.encode(message.method[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                    $root.google.protobuf.ServiceOptions.encode(message.options, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ServiceDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.ServiceDescriptorProto.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.ServiceDescriptorProto
             * @static
             * @param {google.protobuf.IServiceDescriptorProto} message ServiceDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ServiceDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ServiceDescriptorProto message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.ServiceDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.ServiceDescriptorProto} ServiceDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ServiceDescriptorProto.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.ServiceDescriptorProto();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        if (!(message.method && message.method.length))
                            message.method = [];
                        message.method.push($root.google.protobuf.MethodDescriptorProto.decode(reader, reader.uint32()));
                        break;
                    case 3:
                        message.options = $root.google.protobuf.ServiceOptions.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ServiceDescriptorProto message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.ServiceDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.ServiceDescriptorProto} ServiceDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ServiceDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ServiceDescriptorProto message.
             * @function verify
             * @memberof google.protobuf.ServiceDescriptorProto
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ServiceDescriptorProto.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.method != null && message.hasOwnProperty("method")) {
                    if (!Array.isArray(message.method))
                        return "method: array expected";
                    for (var i = 0; i < message.method.length; ++i) {
                        var error = $root.google.protobuf.MethodDescriptorProto.verify(message.method[i]);
                        if (error)
                            return "method." + error;
                    }
                }
                if (message.options != null && message.hasOwnProperty("options")) {
                    var error = $root.google.protobuf.ServiceOptions.verify(message.options);
                    if (error)
                        return "options." + error;
                }
                return null;
            };

            /**
             * Creates a ServiceDescriptorProto message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.ServiceDescriptorProto
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.ServiceDescriptorProto} ServiceDescriptorProto
             */
            ServiceDescriptorProto.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.ServiceDescriptorProto)
                    return object;
                var message = new $root.google.protobuf.ServiceDescriptorProto();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.method) {
                    if (!Array.isArray(object.method))
                        throw TypeError(".google.protobuf.ServiceDescriptorProto.method: array expected");
                    message.method = [];
                    for (var i = 0; i < object.method.length; ++i) {
                        if (typeof object.method[i] !== "object")
                            throw TypeError(".google.protobuf.ServiceDescriptorProto.method: object expected");
                        message.method[i] = $root.google.protobuf.MethodDescriptorProto.fromObject(object.method[i]);
                    }
                }
                if (object.options != null) {
                    if (typeof object.options !== "object")
                        throw TypeError(".google.protobuf.ServiceDescriptorProto.options: object expected");
                    message.options = $root.google.protobuf.ServiceOptions.fromObject(object.options);
                }
                return message;
            };

            /**
             * Creates a plain object from a ServiceDescriptorProto message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.ServiceDescriptorProto
             * @static
             * @param {google.protobuf.ServiceDescriptorProto} message ServiceDescriptorProto
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ServiceDescriptorProto.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.method = [];
                if (options.defaults) {
                    object.name = "";
                    object.options = null;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.method && message.method.length) {
                    object.method = [];
                    for (var j = 0; j < message.method.length; ++j)
                        object.method[j] = $root.google.protobuf.MethodDescriptorProto.toObject(message.method[j], options);
                }
                if (message.options != null && message.hasOwnProperty("options"))
                    object.options = $root.google.protobuf.ServiceOptions.toObject(message.options, options);
                return object;
            };

            /**
             * Converts this ServiceDescriptorProto to JSON.
             * @function toJSON
             * @memberof google.protobuf.ServiceDescriptorProto
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ServiceDescriptorProto.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ServiceDescriptorProto;
        })();

        protobuf.MethodDescriptorProto = (function() {

            /**
             * Properties of a MethodDescriptorProto.
             * @memberof google.protobuf
             * @interface IMethodDescriptorProto
             * @property {string|null} [name] MethodDescriptorProto name
             * @property {string|null} [inputType] MethodDescriptorProto inputType
             * @property {string|null} [outputType] MethodDescriptorProto outputType
             * @property {google.protobuf.IMethodOptions|null} [options] MethodDescriptorProto options
             * @property {boolean|null} [clientStreaming] MethodDescriptorProto clientStreaming
             * @property {boolean|null} [serverStreaming] MethodDescriptorProto serverStreaming
             */

            /**
             * Constructs a new MethodDescriptorProto.
             * @memberof google.protobuf
             * @classdesc Represents a MethodDescriptorProto.
             * @implements IMethodDescriptorProto
             * @constructor
             * @param {google.protobuf.IMethodDescriptorProto=} [properties] Properties to set
             */
            function MethodDescriptorProto(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MethodDescriptorProto name.
             * @member {string} name
             * @memberof google.protobuf.MethodDescriptorProto
             * @instance
             */
            MethodDescriptorProto.prototype.name = "";

            /**
             * MethodDescriptorProto inputType.
             * @member {string} inputType
             * @memberof google.protobuf.MethodDescriptorProto
             * @instance
             */
            MethodDescriptorProto.prototype.inputType = "";

            /**
             * MethodDescriptorProto outputType.
             * @member {string} outputType
             * @memberof google.protobuf.MethodDescriptorProto
             * @instance
             */
            MethodDescriptorProto.prototype.outputType = "";

            /**
             * MethodDescriptorProto options.
             * @member {google.protobuf.IMethodOptions|null|undefined} options
             * @memberof google.protobuf.MethodDescriptorProto
             * @instance
             */
            MethodDescriptorProto.prototype.options = null;

            /**
             * MethodDescriptorProto clientStreaming.
             * @member {boolean} clientStreaming
             * @memberof google.protobuf.MethodDescriptorProto
             * @instance
             */
            MethodDescriptorProto.prototype.clientStreaming = false;

            /**
             * MethodDescriptorProto serverStreaming.
             * @member {boolean} serverStreaming
             * @memberof google.protobuf.MethodDescriptorProto
             * @instance
             */
            MethodDescriptorProto.prototype.serverStreaming = false;

            /**
             * Creates a new MethodDescriptorProto instance using the specified properties.
             * @function create
             * @memberof google.protobuf.MethodDescriptorProto
             * @static
             * @param {google.protobuf.IMethodDescriptorProto=} [properties] Properties to set
             * @returns {google.protobuf.MethodDescriptorProto} MethodDescriptorProto instance
             */
            MethodDescriptorProto.create = function create(properties) {
                return new MethodDescriptorProto(properties);
            };

            /**
             * Encodes the specified MethodDescriptorProto message. Does not implicitly {@link google.protobuf.MethodDescriptorProto.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.MethodDescriptorProto
             * @static
             * @param {google.protobuf.IMethodDescriptorProto} message MethodDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MethodDescriptorProto.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.inputType != null && Object.hasOwnProperty.call(message, "inputType"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.inputType);
                if (message.outputType != null && Object.hasOwnProperty.call(message, "outputType"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.outputType);
                if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                    $root.google.protobuf.MethodOptions.encode(message.options, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.clientStreaming != null && Object.hasOwnProperty.call(message, "clientStreaming"))
                    writer.uint32(/* id 5, wireType 0 =*/40).bool(message.clientStreaming);
                if (message.serverStreaming != null && Object.hasOwnProperty.call(message, "serverStreaming"))
                    writer.uint32(/* id 6, wireType 0 =*/48).bool(message.serverStreaming);
                return writer;
            };

            /**
             * Encodes the specified MethodDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.MethodDescriptorProto.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.MethodDescriptorProto
             * @static
             * @param {google.protobuf.IMethodDescriptorProto} message MethodDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MethodDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MethodDescriptorProto message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.MethodDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.MethodDescriptorProto} MethodDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MethodDescriptorProto.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.MethodDescriptorProto();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message.inputType = reader.string();
                        break;
                    case 3:
                        message.outputType = reader.string();
                        break;
                    case 4:
                        message.options = $root.google.protobuf.MethodOptions.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.clientStreaming = reader.bool();
                        break;
                    case 6:
                        message.serverStreaming = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MethodDescriptorProto message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.MethodDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.MethodDescriptorProto} MethodDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MethodDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MethodDescriptorProto message.
             * @function verify
             * @memberof google.protobuf.MethodDescriptorProto
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MethodDescriptorProto.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.inputType != null && message.hasOwnProperty("inputType"))
                    if (!$util.isString(message.inputType))
                        return "inputType: string expected";
                if (message.outputType != null && message.hasOwnProperty("outputType"))
                    if (!$util.isString(message.outputType))
                        return "outputType: string expected";
                if (message.options != null && message.hasOwnProperty("options")) {
                    var error = $root.google.protobuf.MethodOptions.verify(message.options);
                    if (error)
                        return "options." + error;
                }
                if (message.clientStreaming != null && message.hasOwnProperty("clientStreaming"))
                    if (typeof message.clientStreaming !== "boolean")
                        return "clientStreaming: boolean expected";
                if (message.serverStreaming != null && message.hasOwnProperty("serverStreaming"))
                    if (typeof message.serverStreaming !== "boolean")
                        return "serverStreaming: boolean expected";
                return null;
            };

            /**
             * Creates a MethodDescriptorProto message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.MethodDescriptorProto
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.MethodDescriptorProto} MethodDescriptorProto
             */
            MethodDescriptorProto.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.MethodDescriptorProto)
                    return object;
                var message = new $root.google.protobuf.MethodDescriptorProto();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.inputType != null)
                    message.inputType = String(object.inputType);
                if (object.outputType != null)
                    message.outputType = String(object.outputType);
                if (object.options != null) {
                    if (typeof object.options !== "object")
                        throw TypeError(".google.protobuf.MethodDescriptorProto.options: object expected");
                    message.options = $root.google.protobuf.MethodOptions.fromObject(object.options);
                }
                if (object.clientStreaming != null)
                    message.clientStreaming = Boolean(object.clientStreaming);
                if (object.serverStreaming != null)
                    message.serverStreaming = Boolean(object.serverStreaming);
                return message;
            };

            /**
             * Creates a plain object from a MethodDescriptorProto message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.MethodDescriptorProto
             * @static
             * @param {google.protobuf.MethodDescriptorProto} message MethodDescriptorProto
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MethodDescriptorProto.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.name = "";
                    object.inputType = "";
                    object.outputType = "";
                    object.options = null;
                    object.clientStreaming = false;
                    object.serverStreaming = false;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.inputType != null && message.hasOwnProperty("inputType"))
                    object.inputType = message.inputType;
                if (message.outputType != null && message.hasOwnProperty("outputType"))
                    object.outputType = message.outputType;
                if (message.options != null && message.hasOwnProperty("options"))
                    object.options = $root.google.protobuf.MethodOptions.toObject(message.options, options);
                if (message.clientStreaming != null && message.hasOwnProperty("clientStreaming"))
                    object.clientStreaming = message.clientStreaming;
                if (message.serverStreaming != null && message.hasOwnProperty("serverStreaming"))
                    object.serverStreaming = message.serverStreaming;
                return object;
            };

            /**
             * Converts this MethodDescriptorProto to JSON.
             * @function toJSON
             * @memberof google.protobuf.MethodDescriptorProto
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MethodDescriptorProto.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return MethodDescriptorProto;
        })();

        protobuf.FileOptions = (function() {

            /**
             * Properties of a FileOptions.
             * @memberof google.protobuf
             * @interface IFileOptions
             * @property {string|null} [javaPackage] FileOptions javaPackage
             * @property {string|null} [javaOuterClassname] FileOptions javaOuterClassname
             * @property {boolean|null} [javaMultipleFiles] FileOptions javaMultipleFiles
             * @property {boolean|null} [javaGenerateEqualsAndHash] FileOptions javaGenerateEqualsAndHash
             * @property {boolean|null} [javaStringCheckUtf8] FileOptions javaStringCheckUtf8
             * @property {google.protobuf.FileOptions.OptimizeMode|null} [optimizeFor] FileOptions optimizeFor
             * @property {string|null} [goPackage] FileOptions goPackage
             * @property {boolean|null} [ccGenericServices] FileOptions ccGenericServices
             * @property {boolean|null} [javaGenericServices] FileOptions javaGenericServices
             * @property {boolean|null} [pyGenericServices] FileOptions pyGenericServices
             * @property {boolean|null} [deprecated] FileOptions deprecated
             * @property {boolean|null} [ccEnableArenas] FileOptions ccEnableArenas
             * @property {string|null} [objcClassPrefix] FileOptions objcClassPrefix
             * @property {string|null} [csharpNamespace] FileOptions csharpNamespace
             * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] FileOptions uninterpretedOption
             */

            /**
             * Constructs a new FileOptions.
             * @memberof google.protobuf
             * @classdesc Represents a FileOptions.
             * @implements IFileOptions
             * @constructor
             * @param {google.protobuf.IFileOptions=} [properties] Properties to set
             */
            function FileOptions(properties) {
                this.uninterpretedOption = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FileOptions javaPackage.
             * @member {string} javaPackage
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.javaPackage = "";

            /**
             * FileOptions javaOuterClassname.
             * @member {string} javaOuterClassname
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.javaOuterClassname = "";

            /**
             * FileOptions javaMultipleFiles.
             * @member {boolean} javaMultipleFiles
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.javaMultipleFiles = false;

            /**
             * FileOptions javaGenerateEqualsAndHash.
             * @member {boolean} javaGenerateEqualsAndHash
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.javaGenerateEqualsAndHash = false;

            /**
             * FileOptions javaStringCheckUtf8.
             * @member {boolean} javaStringCheckUtf8
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.javaStringCheckUtf8 = false;

            /**
             * FileOptions optimizeFor.
             * @member {google.protobuf.FileOptions.OptimizeMode} optimizeFor
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.optimizeFor = 1;

            /**
             * FileOptions goPackage.
             * @member {string} goPackage
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.goPackage = "";

            /**
             * FileOptions ccGenericServices.
             * @member {boolean} ccGenericServices
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.ccGenericServices = false;

            /**
             * FileOptions javaGenericServices.
             * @member {boolean} javaGenericServices
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.javaGenericServices = false;

            /**
             * FileOptions pyGenericServices.
             * @member {boolean} pyGenericServices
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.pyGenericServices = false;

            /**
             * FileOptions deprecated.
             * @member {boolean} deprecated
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.deprecated = false;

            /**
             * FileOptions ccEnableArenas.
             * @member {boolean} ccEnableArenas
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.ccEnableArenas = false;

            /**
             * FileOptions objcClassPrefix.
             * @member {string} objcClassPrefix
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.objcClassPrefix = "";

            /**
             * FileOptions csharpNamespace.
             * @member {string} csharpNamespace
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.csharpNamespace = "";

            /**
             * FileOptions uninterpretedOption.
             * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.uninterpretedOption = $util.emptyArray;

            /**
             * Creates a new FileOptions instance using the specified properties.
             * @function create
             * @memberof google.protobuf.FileOptions
             * @static
             * @param {google.protobuf.IFileOptions=} [properties] Properties to set
             * @returns {google.protobuf.FileOptions} FileOptions instance
             */
            FileOptions.create = function create(properties) {
                return new FileOptions(properties);
            };

            /**
             * Encodes the specified FileOptions message. Does not implicitly {@link google.protobuf.FileOptions.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.FileOptions
             * @static
             * @param {google.protobuf.IFileOptions} message FileOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FileOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.javaPackage != null && Object.hasOwnProperty.call(message, "javaPackage"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.javaPackage);
                if (message.javaOuterClassname != null && Object.hasOwnProperty.call(message, "javaOuterClassname"))
                    writer.uint32(/* id 8, wireType 2 =*/66).string(message.javaOuterClassname);
                if (message.optimizeFor != null && Object.hasOwnProperty.call(message, "optimizeFor"))
                    writer.uint32(/* id 9, wireType 0 =*/72).int32(message.optimizeFor);
                if (message.javaMultipleFiles != null && Object.hasOwnProperty.call(message, "javaMultipleFiles"))
                    writer.uint32(/* id 10, wireType 0 =*/80).bool(message.javaMultipleFiles);
                if (message.goPackage != null && Object.hasOwnProperty.call(message, "goPackage"))
                    writer.uint32(/* id 11, wireType 2 =*/90).string(message.goPackage);
                if (message.ccGenericServices != null && Object.hasOwnProperty.call(message, "ccGenericServices"))
                    writer.uint32(/* id 16, wireType 0 =*/128).bool(message.ccGenericServices);
                if (message.javaGenericServices != null && Object.hasOwnProperty.call(message, "javaGenericServices"))
                    writer.uint32(/* id 17, wireType 0 =*/136).bool(message.javaGenericServices);
                if (message.pyGenericServices != null && Object.hasOwnProperty.call(message, "pyGenericServices"))
                    writer.uint32(/* id 18, wireType 0 =*/144).bool(message.pyGenericServices);
                if (message.javaGenerateEqualsAndHash != null && Object.hasOwnProperty.call(message, "javaGenerateEqualsAndHash"))
                    writer.uint32(/* id 20, wireType 0 =*/160).bool(message.javaGenerateEqualsAndHash);
                if (message.deprecated != null && Object.hasOwnProperty.call(message, "deprecated"))
                    writer.uint32(/* id 23, wireType 0 =*/184).bool(message.deprecated);
                if (message.javaStringCheckUtf8 != null && Object.hasOwnProperty.call(message, "javaStringCheckUtf8"))
                    writer.uint32(/* id 27, wireType 0 =*/216).bool(message.javaStringCheckUtf8);
                if (message.ccEnableArenas != null && Object.hasOwnProperty.call(message, "ccEnableArenas"))
                    writer.uint32(/* id 31, wireType 0 =*/248).bool(message.ccEnableArenas);
                if (message.objcClassPrefix != null && Object.hasOwnProperty.call(message, "objcClassPrefix"))
                    writer.uint32(/* id 36, wireType 2 =*/290).string(message.objcClassPrefix);
                if (message.csharpNamespace != null && Object.hasOwnProperty.call(message, "csharpNamespace"))
                    writer.uint32(/* id 37, wireType 2 =*/298).string(message.csharpNamespace);
                if (message.uninterpretedOption != null && message.uninterpretedOption.length)
                    for (var i = 0; i < message.uninterpretedOption.length; ++i)
                        $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified FileOptions message, length delimited. Does not implicitly {@link google.protobuf.FileOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.FileOptions
             * @static
             * @param {google.protobuf.IFileOptions} message FileOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FileOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a FileOptions message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.FileOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.FileOptions} FileOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FileOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FileOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.javaPackage = reader.string();
                        break;
                    case 8:
                        message.javaOuterClassname = reader.string();
                        break;
                    case 10:
                        message.javaMultipleFiles = reader.bool();
                        break;
                    case 20:
                        message.javaGenerateEqualsAndHash = reader.bool();
                        break;
                    case 27:
                        message.javaStringCheckUtf8 = reader.bool();
                        break;
                    case 9:
                        message.optimizeFor = reader.int32();
                        break;
                    case 11:
                        message.goPackage = reader.string();
                        break;
                    case 16:
                        message.ccGenericServices = reader.bool();
                        break;
                    case 17:
                        message.javaGenericServices = reader.bool();
                        break;
                    case 18:
                        message.pyGenericServices = reader.bool();
                        break;
                    case 23:
                        message.deprecated = reader.bool();
                        break;
                    case 31:
                        message.ccEnableArenas = reader.bool();
                        break;
                    case 36:
                        message.objcClassPrefix = reader.string();
                        break;
                    case 37:
                        message.csharpNamespace = reader.string();
                        break;
                    case 999:
                        if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                            message.uninterpretedOption = [];
                        message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a FileOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.FileOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.FileOptions} FileOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FileOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a FileOptions message.
             * @function verify
             * @memberof google.protobuf.FileOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FileOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.javaPackage != null && message.hasOwnProperty("javaPackage"))
                    if (!$util.isString(message.javaPackage))
                        return "javaPackage: string expected";
                if (message.javaOuterClassname != null && message.hasOwnProperty("javaOuterClassname"))
                    if (!$util.isString(message.javaOuterClassname))
                        return "javaOuterClassname: string expected";
                if (message.javaMultipleFiles != null && message.hasOwnProperty("javaMultipleFiles"))
                    if (typeof message.javaMultipleFiles !== "boolean")
                        return "javaMultipleFiles: boolean expected";
                if (message.javaGenerateEqualsAndHash != null && message.hasOwnProperty("javaGenerateEqualsAndHash"))
                    if (typeof message.javaGenerateEqualsAndHash !== "boolean")
                        return "javaGenerateEqualsAndHash: boolean expected";
                if (message.javaStringCheckUtf8 != null && message.hasOwnProperty("javaStringCheckUtf8"))
                    if (typeof message.javaStringCheckUtf8 !== "boolean")
                        return "javaStringCheckUtf8: boolean expected";
                if (message.optimizeFor != null && message.hasOwnProperty("optimizeFor"))
                    switch (message.optimizeFor) {
                    default:
                        return "optimizeFor: enum value expected";
                    case 1:
                    case 2:
                    case 3:
                        break;
                    }
                if (message.goPackage != null && message.hasOwnProperty("goPackage"))
                    if (!$util.isString(message.goPackage))
                        return "goPackage: string expected";
                if (message.ccGenericServices != null && message.hasOwnProperty("ccGenericServices"))
                    if (typeof message.ccGenericServices !== "boolean")
                        return "ccGenericServices: boolean expected";
                if (message.javaGenericServices != null && message.hasOwnProperty("javaGenericServices"))
                    if (typeof message.javaGenericServices !== "boolean")
                        return "javaGenericServices: boolean expected";
                if (message.pyGenericServices != null && message.hasOwnProperty("pyGenericServices"))
                    if (typeof message.pyGenericServices !== "boolean")
                        return "pyGenericServices: boolean expected";
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    if (typeof message.deprecated !== "boolean")
                        return "deprecated: boolean expected";
                if (message.ccEnableArenas != null && message.hasOwnProperty("ccEnableArenas"))
                    if (typeof message.ccEnableArenas !== "boolean")
                        return "ccEnableArenas: boolean expected";
                if (message.objcClassPrefix != null && message.hasOwnProperty("objcClassPrefix"))
                    if (!$util.isString(message.objcClassPrefix))
                        return "objcClassPrefix: string expected";
                if (message.csharpNamespace != null && message.hasOwnProperty("csharpNamespace"))
                    if (!$util.isString(message.csharpNamespace))
                        return "csharpNamespace: string expected";
                if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
                    if (!Array.isArray(message.uninterpretedOption))
                        return "uninterpretedOption: array expected";
                    for (var i = 0; i < message.uninterpretedOption.length; ++i) {
                        var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
                        if (error)
                            return "uninterpretedOption." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a FileOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.FileOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.FileOptions} FileOptions
             */
            FileOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.FileOptions)
                    return object;
                var message = new $root.google.protobuf.FileOptions();
                if (object.javaPackage != null)
                    message.javaPackage = String(object.javaPackage);
                if (object.javaOuterClassname != null)
                    message.javaOuterClassname = String(object.javaOuterClassname);
                if (object.javaMultipleFiles != null)
                    message.javaMultipleFiles = Boolean(object.javaMultipleFiles);
                if (object.javaGenerateEqualsAndHash != null)
                    message.javaGenerateEqualsAndHash = Boolean(object.javaGenerateEqualsAndHash);
                if (object.javaStringCheckUtf8 != null)
                    message.javaStringCheckUtf8 = Boolean(object.javaStringCheckUtf8);
                switch (object.optimizeFor) {
                case "SPEED":
                case 1:
                    message.optimizeFor = 1;
                    break;
                case "CODE_SIZE":
                case 2:
                    message.optimizeFor = 2;
                    break;
                case "LITE_RUNTIME":
                case 3:
                    message.optimizeFor = 3;
                    break;
                }
                if (object.goPackage != null)
                    message.goPackage = String(object.goPackage);
                if (object.ccGenericServices != null)
                    message.ccGenericServices = Boolean(object.ccGenericServices);
                if (object.javaGenericServices != null)
                    message.javaGenericServices = Boolean(object.javaGenericServices);
                if (object.pyGenericServices != null)
                    message.pyGenericServices = Boolean(object.pyGenericServices);
                if (object.deprecated != null)
                    message.deprecated = Boolean(object.deprecated);
                if (object.ccEnableArenas != null)
                    message.ccEnableArenas = Boolean(object.ccEnableArenas);
                if (object.objcClassPrefix != null)
                    message.objcClassPrefix = String(object.objcClassPrefix);
                if (object.csharpNamespace != null)
                    message.csharpNamespace = String(object.csharpNamespace);
                if (object.uninterpretedOption) {
                    if (!Array.isArray(object.uninterpretedOption))
                        throw TypeError(".google.protobuf.FileOptions.uninterpretedOption: array expected");
                    message.uninterpretedOption = [];
                    for (var i = 0; i < object.uninterpretedOption.length; ++i) {
                        if (typeof object.uninterpretedOption[i] !== "object")
                            throw TypeError(".google.protobuf.FileOptions.uninterpretedOption: object expected");
                        message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpretedOption[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a FileOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.FileOptions
             * @static
             * @param {google.protobuf.FileOptions} message FileOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FileOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.uninterpretedOption = [];
                if (options.defaults) {
                    object.javaPackage = "";
                    object.javaOuterClassname = "";
                    object.optimizeFor = options.enums === String ? "SPEED" : 1;
                    object.javaMultipleFiles = false;
                    object.goPackage = "";
                    object.ccGenericServices = false;
                    object.javaGenericServices = false;
                    object.pyGenericServices = false;
                    object.javaGenerateEqualsAndHash = false;
                    object.deprecated = false;
                    object.javaStringCheckUtf8 = false;
                    object.ccEnableArenas = false;
                    object.objcClassPrefix = "";
                    object.csharpNamespace = "";
                }
                if (message.javaPackage != null && message.hasOwnProperty("javaPackage"))
                    object.javaPackage = message.javaPackage;
                if (message.javaOuterClassname != null && message.hasOwnProperty("javaOuterClassname"))
                    object.javaOuterClassname = message.javaOuterClassname;
                if (message.optimizeFor != null && message.hasOwnProperty("optimizeFor"))
                    object.optimizeFor = options.enums === String ? $root.google.protobuf.FileOptions.OptimizeMode[message.optimizeFor] : message.optimizeFor;
                if (message.javaMultipleFiles != null && message.hasOwnProperty("javaMultipleFiles"))
                    object.javaMultipleFiles = message.javaMultipleFiles;
                if (message.goPackage != null && message.hasOwnProperty("goPackage"))
                    object.goPackage = message.goPackage;
                if (message.ccGenericServices != null && message.hasOwnProperty("ccGenericServices"))
                    object.ccGenericServices = message.ccGenericServices;
                if (message.javaGenericServices != null && message.hasOwnProperty("javaGenericServices"))
                    object.javaGenericServices = message.javaGenericServices;
                if (message.pyGenericServices != null && message.hasOwnProperty("pyGenericServices"))
                    object.pyGenericServices = message.pyGenericServices;
                if (message.javaGenerateEqualsAndHash != null && message.hasOwnProperty("javaGenerateEqualsAndHash"))
                    object.javaGenerateEqualsAndHash = message.javaGenerateEqualsAndHash;
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    object.deprecated = message.deprecated;
                if (message.javaStringCheckUtf8 != null && message.hasOwnProperty("javaStringCheckUtf8"))
                    object.javaStringCheckUtf8 = message.javaStringCheckUtf8;
                if (message.ccEnableArenas != null && message.hasOwnProperty("ccEnableArenas"))
                    object.ccEnableArenas = message.ccEnableArenas;
                if (message.objcClassPrefix != null && message.hasOwnProperty("objcClassPrefix"))
                    object.objcClassPrefix = message.objcClassPrefix;
                if (message.csharpNamespace != null && message.hasOwnProperty("csharpNamespace"))
                    object.csharpNamespace = message.csharpNamespace;
                if (message.uninterpretedOption && message.uninterpretedOption.length) {
                    object.uninterpretedOption = [];
                    for (var j = 0; j < message.uninterpretedOption.length; ++j)
                        object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpretedOption[j], options);
                }
                return object;
            };

            /**
             * Converts this FileOptions to JSON.
             * @function toJSON
             * @memberof google.protobuf.FileOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FileOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * OptimizeMode enum.
             * @name google.protobuf.FileOptions.OptimizeMode
             * @enum {number}
             * @property {number} SPEED=1 SPEED value
             * @property {number} CODE_SIZE=2 CODE_SIZE value
             * @property {number} LITE_RUNTIME=3 LITE_RUNTIME value
             */
            FileOptions.OptimizeMode = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[1] = "SPEED"] = 1;
                values[valuesById[2] = "CODE_SIZE"] = 2;
                values[valuesById[3] = "LITE_RUNTIME"] = 3;
                return values;
            })();

            return FileOptions;
        })();

        protobuf.MessageOptions = (function() {

            /**
             * Properties of a MessageOptions.
             * @memberof google.protobuf
             * @interface IMessageOptions
             * @property {boolean|null} [messageSetWireFormat] MessageOptions messageSetWireFormat
             * @property {boolean|null} [noStandardDescriptorAccessor] MessageOptions noStandardDescriptorAccessor
             * @property {boolean|null} [deprecated] MessageOptions deprecated
             * @property {boolean|null} [mapEntry] MessageOptions mapEntry
             * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] MessageOptions uninterpretedOption
             */

            /**
             * Constructs a new MessageOptions.
             * @memberof google.protobuf
             * @classdesc Represents a MessageOptions.
             * @implements IMessageOptions
             * @constructor
             * @param {google.protobuf.IMessageOptions=} [properties] Properties to set
             */
            function MessageOptions(properties) {
                this.uninterpretedOption = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MessageOptions messageSetWireFormat.
             * @member {boolean} messageSetWireFormat
             * @memberof google.protobuf.MessageOptions
             * @instance
             */
            MessageOptions.prototype.messageSetWireFormat = false;

            /**
             * MessageOptions noStandardDescriptorAccessor.
             * @member {boolean} noStandardDescriptorAccessor
             * @memberof google.protobuf.MessageOptions
             * @instance
             */
            MessageOptions.prototype.noStandardDescriptorAccessor = false;

            /**
             * MessageOptions deprecated.
             * @member {boolean} deprecated
             * @memberof google.protobuf.MessageOptions
             * @instance
             */
            MessageOptions.prototype.deprecated = false;

            /**
             * MessageOptions mapEntry.
             * @member {boolean} mapEntry
             * @memberof google.protobuf.MessageOptions
             * @instance
             */
            MessageOptions.prototype.mapEntry = false;

            /**
             * MessageOptions uninterpretedOption.
             * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
             * @memberof google.protobuf.MessageOptions
             * @instance
             */
            MessageOptions.prototype.uninterpretedOption = $util.emptyArray;

            /**
             * Creates a new MessageOptions instance using the specified properties.
             * @function create
             * @memberof google.protobuf.MessageOptions
             * @static
             * @param {google.protobuf.IMessageOptions=} [properties] Properties to set
             * @returns {google.protobuf.MessageOptions} MessageOptions instance
             */
            MessageOptions.create = function create(properties) {
                return new MessageOptions(properties);
            };

            /**
             * Encodes the specified MessageOptions message. Does not implicitly {@link google.protobuf.MessageOptions.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.MessageOptions
             * @static
             * @param {google.protobuf.IMessageOptions} message MessageOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MessageOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.messageSetWireFormat != null && Object.hasOwnProperty.call(message, "messageSetWireFormat"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.messageSetWireFormat);
                if (message.noStandardDescriptorAccessor != null && Object.hasOwnProperty.call(message, "noStandardDescriptorAccessor"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.noStandardDescriptorAccessor);
                if (message.deprecated != null && Object.hasOwnProperty.call(message, "deprecated"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.deprecated);
                if (message.mapEntry != null && Object.hasOwnProperty.call(message, "mapEntry"))
                    writer.uint32(/* id 7, wireType 0 =*/56).bool(message.mapEntry);
                if (message.uninterpretedOption != null && message.uninterpretedOption.length)
                    for (var i = 0; i < message.uninterpretedOption.length; ++i)
                        $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified MessageOptions message, length delimited. Does not implicitly {@link google.protobuf.MessageOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.MessageOptions
             * @static
             * @param {google.protobuf.IMessageOptions} message MessageOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MessageOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MessageOptions message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.MessageOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.MessageOptions} MessageOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MessageOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.MessageOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.messageSetWireFormat = reader.bool();
                        break;
                    case 2:
                        message.noStandardDescriptorAccessor = reader.bool();
                        break;
                    case 3:
                        message.deprecated = reader.bool();
                        break;
                    case 7:
                        message.mapEntry = reader.bool();
                        break;
                    case 999:
                        if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                            message.uninterpretedOption = [];
                        message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MessageOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.MessageOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.MessageOptions} MessageOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MessageOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MessageOptions message.
             * @function verify
             * @memberof google.protobuf.MessageOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MessageOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.messageSetWireFormat != null && message.hasOwnProperty("messageSetWireFormat"))
                    if (typeof message.messageSetWireFormat !== "boolean")
                        return "messageSetWireFormat: boolean expected";
                if (message.noStandardDescriptorAccessor != null && message.hasOwnProperty("noStandardDescriptorAccessor"))
                    if (typeof message.noStandardDescriptorAccessor !== "boolean")
                        return "noStandardDescriptorAccessor: boolean expected";
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    if (typeof message.deprecated !== "boolean")
                        return "deprecated: boolean expected";
                if (message.mapEntry != null && message.hasOwnProperty("mapEntry"))
                    if (typeof message.mapEntry !== "boolean")
                        return "mapEntry: boolean expected";
                if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
                    if (!Array.isArray(message.uninterpretedOption))
                        return "uninterpretedOption: array expected";
                    for (var i = 0; i < message.uninterpretedOption.length; ++i) {
                        var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
                        if (error)
                            return "uninterpretedOption." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a MessageOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.MessageOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.MessageOptions} MessageOptions
             */
            MessageOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.MessageOptions)
                    return object;
                var message = new $root.google.protobuf.MessageOptions();
                if (object.messageSetWireFormat != null)
                    message.messageSetWireFormat = Boolean(object.messageSetWireFormat);
                if (object.noStandardDescriptorAccessor != null)
                    message.noStandardDescriptorAccessor = Boolean(object.noStandardDescriptorAccessor);
                if (object.deprecated != null)
                    message.deprecated = Boolean(object.deprecated);
                if (object.mapEntry != null)
                    message.mapEntry = Boolean(object.mapEntry);
                if (object.uninterpretedOption) {
                    if (!Array.isArray(object.uninterpretedOption))
                        throw TypeError(".google.protobuf.MessageOptions.uninterpretedOption: array expected");
                    message.uninterpretedOption = [];
                    for (var i = 0; i < object.uninterpretedOption.length; ++i) {
                        if (typeof object.uninterpretedOption[i] !== "object")
                            throw TypeError(".google.protobuf.MessageOptions.uninterpretedOption: object expected");
                        message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpretedOption[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a MessageOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.MessageOptions
             * @static
             * @param {google.protobuf.MessageOptions} message MessageOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MessageOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.uninterpretedOption = [];
                if (options.defaults) {
                    object.messageSetWireFormat = false;
                    object.noStandardDescriptorAccessor = false;
                    object.deprecated = false;
                    object.mapEntry = false;
                }
                if (message.messageSetWireFormat != null && message.hasOwnProperty("messageSetWireFormat"))
                    object.messageSetWireFormat = message.messageSetWireFormat;
                if (message.noStandardDescriptorAccessor != null && message.hasOwnProperty("noStandardDescriptorAccessor"))
                    object.noStandardDescriptorAccessor = message.noStandardDescriptorAccessor;
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    object.deprecated = message.deprecated;
                if (message.mapEntry != null && message.hasOwnProperty("mapEntry"))
                    object.mapEntry = message.mapEntry;
                if (message.uninterpretedOption && message.uninterpretedOption.length) {
                    object.uninterpretedOption = [];
                    for (var j = 0; j < message.uninterpretedOption.length; ++j)
                        object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpretedOption[j], options);
                }
                return object;
            };

            /**
             * Converts this MessageOptions to JSON.
             * @function toJSON
             * @memberof google.protobuf.MessageOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MessageOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return MessageOptions;
        })();

        protobuf.FieldOptions = (function() {

            /**
             * Properties of a FieldOptions.
             * @memberof google.protobuf
             * @interface IFieldOptions
             * @property {google.protobuf.FieldOptions.CType|null} [ctype] FieldOptions ctype
             * @property {boolean|null} [packed] FieldOptions packed
             * @property {google.protobuf.FieldOptions.JSType|null} [jstype] FieldOptions jstype
             * @property {boolean|null} [lazy] FieldOptions lazy
             * @property {boolean|null} [deprecated] FieldOptions deprecated
             * @property {boolean|null} [weak] FieldOptions weak
             * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] FieldOptions uninterpretedOption
             * @property {boolean|null} [".Ydb.required"] FieldOptions .Ydb.required
             * @property {Ydb.ILimit|null} [".Ydb.size"] FieldOptions .Ydb.size
             * @property {Ydb.ILimit|null} [".Ydb.length"] FieldOptions .Ydb.length
             * @property {Ydb.IMapKey|null} [".Ydb.mapKey"] FieldOptions .Ydb.mapKey
             * @property {string|null} [".Ydb.value"] FieldOptions .Ydb.value
             */

            /**
             * Constructs a new FieldOptions.
             * @memberof google.protobuf
             * @classdesc Represents a FieldOptions.
             * @implements IFieldOptions
             * @constructor
             * @param {google.protobuf.IFieldOptions=} [properties] Properties to set
             */
            function FieldOptions(properties) {
                this.uninterpretedOption = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FieldOptions ctype.
             * @member {google.protobuf.FieldOptions.CType} ctype
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype.ctype = 0;

            /**
             * FieldOptions packed.
             * @member {boolean} packed
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype.packed = false;

            /**
             * FieldOptions jstype.
             * @member {google.protobuf.FieldOptions.JSType} jstype
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype.jstype = 0;

            /**
             * FieldOptions lazy.
             * @member {boolean} lazy
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype.lazy = false;

            /**
             * FieldOptions deprecated.
             * @member {boolean} deprecated
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype.deprecated = false;

            /**
             * FieldOptions weak.
             * @member {boolean} weak
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype.weak = false;

            /**
             * FieldOptions uninterpretedOption.
             * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype.uninterpretedOption = $util.emptyArray;

            /**
             * FieldOptions .Ydb.required.
             * @member {boolean} .Ydb.required
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype[".Ydb.required"] = false;

            /**
             * FieldOptions .Ydb.size.
             * @member {Ydb.ILimit|null|undefined} .Ydb.size
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype[".Ydb.size"] = null;

            /**
             * FieldOptions .Ydb.length.
             * @member {Ydb.ILimit|null|undefined} .Ydb.length
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype[".Ydb.length"] = null;

            /**
             * FieldOptions .Ydb.mapKey.
             * @member {Ydb.IMapKey|null|undefined} .Ydb.mapKey
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype[".Ydb.mapKey"] = null;

            /**
             * FieldOptions .Ydb.value.
             * @member {string} .Ydb.value
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype[".Ydb.value"] = "";

            /**
             * Creates a new FieldOptions instance using the specified properties.
             * @function create
             * @memberof google.protobuf.FieldOptions
             * @static
             * @param {google.protobuf.IFieldOptions=} [properties] Properties to set
             * @returns {google.protobuf.FieldOptions} FieldOptions instance
             */
            FieldOptions.create = function create(properties) {
                return new FieldOptions(properties);
            };

            /**
             * Encodes the specified FieldOptions message. Does not implicitly {@link google.protobuf.FieldOptions.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.FieldOptions
             * @static
             * @param {google.protobuf.IFieldOptions} message FieldOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FieldOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.ctype != null && Object.hasOwnProperty.call(message, "ctype"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.ctype);
                if (message.packed != null && Object.hasOwnProperty.call(message, "packed"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.packed);
                if (message.deprecated != null && Object.hasOwnProperty.call(message, "deprecated"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.deprecated);
                if (message.lazy != null && Object.hasOwnProperty.call(message, "lazy"))
                    writer.uint32(/* id 5, wireType 0 =*/40).bool(message.lazy);
                if (message.jstype != null && Object.hasOwnProperty.call(message, "jstype"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int32(message.jstype);
                if (message.weak != null && Object.hasOwnProperty.call(message, "weak"))
                    writer.uint32(/* id 10, wireType 0 =*/80).bool(message.weak);
                if (message.uninterpretedOption != null && message.uninterpretedOption.length)
                    for (var i = 0; i < message.uninterpretedOption.length; ++i)
                        $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                if (message[".Ydb.required"] != null && Object.hasOwnProperty.call(message, ".Ydb.required"))
                    writer.uint32(/* id 87650, wireType 0 =*/701200).bool(message[".Ydb.required"]);
                if (message[".Ydb.size"] != null && Object.hasOwnProperty.call(message, ".Ydb.size"))
                    $root.Ydb.Limit.encode(message[".Ydb.size"], writer.uint32(/* id 87651, wireType 2 =*/701210).fork()).ldelim();
                if (message[".Ydb.length"] != null && Object.hasOwnProperty.call(message, ".Ydb.length"))
                    $root.Ydb.Limit.encode(message[".Ydb.length"], writer.uint32(/* id 87652, wireType 2 =*/701218).fork()).ldelim();
                if (message[".Ydb.mapKey"] != null && Object.hasOwnProperty.call(message, ".Ydb.mapKey"))
                    $root.Ydb.MapKey.encode(message[".Ydb.mapKey"], writer.uint32(/* id 87653, wireType 2 =*/701226).fork()).ldelim();
                if (message[".Ydb.value"] != null && Object.hasOwnProperty.call(message, ".Ydb.value"))
                    writer.uint32(/* id 87654, wireType 2 =*/701234).string(message[".Ydb.value"]);
                return writer;
            };

            /**
             * Encodes the specified FieldOptions message, length delimited. Does not implicitly {@link google.protobuf.FieldOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.FieldOptions
             * @static
             * @param {google.protobuf.IFieldOptions} message FieldOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FieldOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a FieldOptions message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.FieldOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.FieldOptions} FieldOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FieldOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FieldOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.ctype = reader.int32();
                        break;
                    case 2:
                        message.packed = reader.bool();
                        break;
                    case 6:
                        message.jstype = reader.int32();
                        break;
                    case 5:
                        message.lazy = reader.bool();
                        break;
                    case 3:
                        message.deprecated = reader.bool();
                        break;
                    case 10:
                        message.weak = reader.bool();
                        break;
                    case 999:
                        if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                            message.uninterpretedOption = [];
                        message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                        break;
                    case 87650:
                        message[".Ydb.required"] = reader.bool();
                        break;
                    case 87651:
                        message[".Ydb.size"] = $root.Ydb.Limit.decode(reader, reader.uint32());
                        break;
                    case 87652:
                        message[".Ydb.length"] = $root.Ydb.Limit.decode(reader, reader.uint32());
                        break;
                    case 87653:
                        message[".Ydb.mapKey"] = $root.Ydb.MapKey.decode(reader, reader.uint32());
                        break;
                    case 87654:
                        message[".Ydb.value"] = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a FieldOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.FieldOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.FieldOptions} FieldOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FieldOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a FieldOptions message.
             * @function verify
             * @memberof google.protobuf.FieldOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FieldOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.ctype != null && message.hasOwnProperty("ctype"))
                    switch (message.ctype) {
                    default:
                        return "ctype: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                if (message.packed != null && message.hasOwnProperty("packed"))
                    if (typeof message.packed !== "boolean")
                        return "packed: boolean expected";
                if (message.jstype != null && message.hasOwnProperty("jstype"))
                    switch (message.jstype) {
                    default:
                        return "jstype: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                if (message.lazy != null && message.hasOwnProperty("lazy"))
                    if (typeof message.lazy !== "boolean")
                        return "lazy: boolean expected";
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    if (typeof message.deprecated !== "boolean")
                        return "deprecated: boolean expected";
                if (message.weak != null && message.hasOwnProperty("weak"))
                    if (typeof message.weak !== "boolean")
                        return "weak: boolean expected";
                if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
                    if (!Array.isArray(message.uninterpretedOption))
                        return "uninterpretedOption: array expected";
                    for (var i = 0; i < message.uninterpretedOption.length; ++i) {
                        var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
                        if (error)
                            return "uninterpretedOption." + error;
                    }
                }
                if (message[".Ydb.required"] != null && message.hasOwnProperty(".Ydb.required"))
                    if (typeof message[".Ydb.required"] !== "boolean")
                        return ".Ydb.required: boolean expected";
                if (message[".Ydb.size"] != null && message.hasOwnProperty(".Ydb.size")) {
                    var error = $root.Ydb.Limit.verify(message[".Ydb.size"]);
                    if (error)
                        return ".Ydb.size." + error;
                }
                if (message[".Ydb.length"] != null && message.hasOwnProperty(".Ydb.length")) {
                    var error = $root.Ydb.Limit.verify(message[".Ydb.length"]);
                    if (error)
                        return ".Ydb.length." + error;
                }
                if (message[".Ydb.mapKey"] != null && message.hasOwnProperty(".Ydb.mapKey")) {
                    var error = $root.Ydb.MapKey.verify(message[".Ydb.mapKey"]);
                    if (error)
                        return ".Ydb.mapKey." + error;
                }
                if (message[".Ydb.value"] != null && message.hasOwnProperty(".Ydb.value"))
                    if (!$util.isString(message[".Ydb.value"]))
                        return ".Ydb.value: string expected";
                return null;
            };

            /**
             * Creates a FieldOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.FieldOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.FieldOptions} FieldOptions
             */
            FieldOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.FieldOptions)
                    return object;
                var message = new $root.google.protobuf.FieldOptions();
                switch (object.ctype) {
                case "STRING":
                case 0:
                    message.ctype = 0;
                    break;
                case "CORD":
                case 1:
                    message.ctype = 1;
                    break;
                case "STRING_PIECE":
                case 2:
                    message.ctype = 2;
                    break;
                }
                if (object.packed != null)
                    message.packed = Boolean(object.packed);
                switch (object.jstype) {
                case "JS_NORMAL":
                case 0:
                    message.jstype = 0;
                    break;
                case "JS_STRING":
                case 1:
                    message.jstype = 1;
                    break;
                case "JS_NUMBER":
                case 2:
                    message.jstype = 2;
                    break;
                }
                if (object.lazy != null)
                    message.lazy = Boolean(object.lazy);
                if (object.deprecated != null)
                    message.deprecated = Boolean(object.deprecated);
                if (object.weak != null)
                    message.weak = Boolean(object.weak);
                if (object.uninterpretedOption) {
                    if (!Array.isArray(object.uninterpretedOption))
                        throw TypeError(".google.protobuf.FieldOptions.uninterpretedOption: array expected");
                    message.uninterpretedOption = [];
                    for (var i = 0; i < object.uninterpretedOption.length; ++i) {
                        if (typeof object.uninterpretedOption[i] !== "object")
                            throw TypeError(".google.protobuf.FieldOptions.uninterpretedOption: object expected");
                        message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpretedOption[i]);
                    }
                }
                if (object[".Ydb.required"] != null)
                    message[".Ydb.required"] = Boolean(object[".Ydb.required"]);
                if (object[".Ydb.size"] != null) {
                    if (typeof object[".Ydb.size"] !== "object")
                        throw TypeError(".google.protobuf.FieldOptions..Ydb.size: object expected");
                    message[".Ydb.size"] = $root.Ydb.Limit.fromObject(object[".Ydb.size"]);
                }
                if (object[".Ydb.length"] != null) {
                    if (typeof object[".Ydb.length"] !== "object")
                        throw TypeError(".google.protobuf.FieldOptions..Ydb.length: object expected");
                    message[".Ydb.length"] = $root.Ydb.Limit.fromObject(object[".Ydb.length"]);
                }
                if (object[".Ydb.mapKey"] != null) {
                    if (typeof object[".Ydb.mapKey"] !== "object")
                        throw TypeError(".google.protobuf.FieldOptions..Ydb.mapKey: object expected");
                    message[".Ydb.mapKey"] = $root.Ydb.MapKey.fromObject(object[".Ydb.mapKey"]);
                }
                if (object[".Ydb.value"] != null)
                    message[".Ydb.value"] = String(object[".Ydb.value"]);
                return message;
            };

            /**
             * Creates a plain object from a FieldOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.FieldOptions
             * @static
             * @param {google.protobuf.FieldOptions} message FieldOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FieldOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.uninterpretedOption = [];
                if (options.defaults) {
                    object.ctype = options.enums === String ? "STRING" : 0;
                    object.packed = false;
                    object.deprecated = false;
                    object.lazy = false;
                    object.jstype = options.enums === String ? "JS_NORMAL" : 0;
                    object.weak = false;
                    object[".Ydb.required"] = false;
                    object[".Ydb.size"] = null;
                    object[".Ydb.length"] = null;
                    object[".Ydb.mapKey"] = null;
                    object[".Ydb.value"] = "";
                }
                if (message.ctype != null && message.hasOwnProperty("ctype"))
                    object.ctype = options.enums === String ? $root.google.protobuf.FieldOptions.CType[message.ctype] : message.ctype;
                if (message.packed != null && message.hasOwnProperty("packed"))
                    object.packed = message.packed;
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    object.deprecated = message.deprecated;
                if (message.lazy != null && message.hasOwnProperty("lazy"))
                    object.lazy = message.lazy;
                if (message.jstype != null && message.hasOwnProperty("jstype"))
                    object.jstype = options.enums === String ? $root.google.protobuf.FieldOptions.JSType[message.jstype] : message.jstype;
                if (message.weak != null && message.hasOwnProperty("weak"))
                    object.weak = message.weak;
                if (message.uninterpretedOption && message.uninterpretedOption.length) {
                    object.uninterpretedOption = [];
                    for (var j = 0; j < message.uninterpretedOption.length; ++j)
                        object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpretedOption[j], options);
                }
                if (message[".Ydb.required"] != null && message.hasOwnProperty(".Ydb.required"))
                    object[".Ydb.required"] = message[".Ydb.required"];
                if (message[".Ydb.size"] != null && message.hasOwnProperty(".Ydb.size"))
                    object[".Ydb.size"] = $root.Ydb.Limit.toObject(message[".Ydb.size"], options);
                if (message[".Ydb.length"] != null && message.hasOwnProperty(".Ydb.length"))
                    object[".Ydb.length"] = $root.Ydb.Limit.toObject(message[".Ydb.length"], options);
                if (message[".Ydb.mapKey"] != null && message.hasOwnProperty(".Ydb.mapKey"))
                    object[".Ydb.mapKey"] = $root.Ydb.MapKey.toObject(message[".Ydb.mapKey"], options);
                if (message[".Ydb.value"] != null && message.hasOwnProperty(".Ydb.value"))
                    object[".Ydb.value"] = message[".Ydb.value"];
                return object;
            };

            /**
             * Converts this FieldOptions to JSON.
             * @function toJSON
             * @memberof google.protobuf.FieldOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FieldOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * CType enum.
             * @name google.protobuf.FieldOptions.CType
             * @enum {number}
             * @property {number} STRING=0 STRING value
             * @property {number} CORD=1 CORD value
             * @property {number} STRING_PIECE=2 STRING_PIECE value
             */
            FieldOptions.CType = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "STRING"] = 0;
                values[valuesById[1] = "CORD"] = 1;
                values[valuesById[2] = "STRING_PIECE"] = 2;
                return values;
            })();

            /**
             * JSType enum.
             * @name google.protobuf.FieldOptions.JSType
             * @enum {number}
             * @property {number} JS_NORMAL=0 JS_NORMAL value
             * @property {number} JS_STRING=1 JS_STRING value
             * @property {number} JS_NUMBER=2 JS_NUMBER value
             */
            FieldOptions.JSType = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "JS_NORMAL"] = 0;
                values[valuesById[1] = "JS_STRING"] = 1;
                values[valuesById[2] = "JS_NUMBER"] = 2;
                return values;
            })();

            return FieldOptions;
        })();

        protobuf.OneofOptions = (function() {

            /**
             * Properties of an OneofOptions.
             * @memberof google.protobuf
             * @interface IOneofOptions
             * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] OneofOptions uninterpretedOption
             */

            /**
             * Constructs a new OneofOptions.
             * @memberof google.protobuf
             * @classdesc Represents an OneofOptions.
             * @implements IOneofOptions
             * @constructor
             * @param {google.protobuf.IOneofOptions=} [properties] Properties to set
             */
            function OneofOptions(properties) {
                this.uninterpretedOption = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * OneofOptions uninterpretedOption.
             * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
             * @memberof google.protobuf.OneofOptions
             * @instance
             */
            OneofOptions.prototype.uninterpretedOption = $util.emptyArray;

            /**
             * Creates a new OneofOptions instance using the specified properties.
             * @function create
             * @memberof google.protobuf.OneofOptions
             * @static
             * @param {google.protobuf.IOneofOptions=} [properties] Properties to set
             * @returns {google.protobuf.OneofOptions} OneofOptions instance
             */
            OneofOptions.create = function create(properties) {
                return new OneofOptions(properties);
            };

            /**
             * Encodes the specified OneofOptions message. Does not implicitly {@link google.protobuf.OneofOptions.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.OneofOptions
             * @static
             * @param {google.protobuf.IOneofOptions} message OneofOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OneofOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.uninterpretedOption != null && message.uninterpretedOption.length)
                    for (var i = 0; i < message.uninterpretedOption.length; ++i)
                        $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified OneofOptions message, length delimited. Does not implicitly {@link google.protobuf.OneofOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.OneofOptions
             * @static
             * @param {google.protobuf.IOneofOptions} message OneofOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OneofOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an OneofOptions message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.OneofOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.OneofOptions} OneofOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OneofOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.OneofOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 999:
                        if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                            message.uninterpretedOption = [];
                        message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an OneofOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.OneofOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.OneofOptions} OneofOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OneofOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an OneofOptions message.
             * @function verify
             * @memberof google.protobuf.OneofOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            OneofOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
                    if (!Array.isArray(message.uninterpretedOption))
                        return "uninterpretedOption: array expected";
                    for (var i = 0; i < message.uninterpretedOption.length; ++i) {
                        var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
                        if (error)
                            return "uninterpretedOption." + error;
                    }
                }
                return null;
            };

            /**
             * Creates an OneofOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.OneofOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.OneofOptions} OneofOptions
             */
            OneofOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.OneofOptions)
                    return object;
                var message = new $root.google.protobuf.OneofOptions();
                if (object.uninterpretedOption) {
                    if (!Array.isArray(object.uninterpretedOption))
                        throw TypeError(".google.protobuf.OneofOptions.uninterpretedOption: array expected");
                    message.uninterpretedOption = [];
                    for (var i = 0; i < object.uninterpretedOption.length; ++i) {
                        if (typeof object.uninterpretedOption[i] !== "object")
                            throw TypeError(".google.protobuf.OneofOptions.uninterpretedOption: object expected");
                        message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpretedOption[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from an OneofOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.OneofOptions
             * @static
             * @param {google.protobuf.OneofOptions} message OneofOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            OneofOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.uninterpretedOption = [];
                if (message.uninterpretedOption && message.uninterpretedOption.length) {
                    object.uninterpretedOption = [];
                    for (var j = 0; j < message.uninterpretedOption.length; ++j)
                        object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpretedOption[j], options);
                }
                return object;
            };

            /**
             * Converts this OneofOptions to JSON.
             * @function toJSON
             * @memberof google.protobuf.OneofOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            OneofOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return OneofOptions;
        })();

        protobuf.EnumOptions = (function() {

            /**
             * Properties of an EnumOptions.
             * @memberof google.protobuf
             * @interface IEnumOptions
             * @property {boolean|null} [allowAlias] EnumOptions allowAlias
             * @property {boolean|null} [deprecated] EnumOptions deprecated
             * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] EnumOptions uninterpretedOption
             */

            /**
             * Constructs a new EnumOptions.
             * @memberof google.protobuf
             * @classdesc Represents an EnumOptions.
             * @implements IEnumOptions
             * @constructor
             * @param {google.protobuf.IEnumOptions=} [properties] Properties to set
             */
            function EnumOptions(properties) {
                this.uninterpretedOption = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * EnumOptions allowAlias.
             * @member {boolean} allowAlias
             * @memberof google.protobuf.EnumOptions
             * @instance
             */
            EnumOptions.prototype.allowAlias = false;

            /**
             * EnumOptions deprecated.
             * @member {boolean} deprecated
             * @memberof google.protobuf.EnumOptions
             * @instance
             */
            EnumOptions.prototype.deprecated = false;

            /**
             * EnumOptions uninterpretedOption.
             * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
             * @memberof google.protobuf.EnumOptions
             * @instance
             */
            EnumOptions.prototype.uninterpretedOption = $util.emptyArray;

            /**
             * Creates a new EnumOptions instance using the specified properties.
             * @function create
             * @memberof google.protobuf.EnumOptions
             * @static
             * @param {google.protobuf.IEnumOptions=} [properties] Properties to set
             * @returns {google.protobuf.EnumOptions} EnumOptions instance
             */
            EnumOptions.create = function create(properties) {
                return new EnumOptions(properties);
            };

            /**
             * Encodes the specified EnumOptions message. Does not implicitly {@link google.protobuf.EnumOptions.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.EnumOptions
             * @static
             * @param {google.protobuf.IEnumOptions} message EnumOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EnumOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.allowAlias != null && Object.hasOwnProperty.call(message, "allowAlias"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.allowAlias);
                if (message.deprecated != null && Object.hasOwnProperty.call(message, "deprecated"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.deprecated);
                if (message.uninterpretedOption != null && message.uninterpretedOption.length)
                    for (var i = 0; i < message.uninterpretedOption.length; ++i)
                        $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified EnumOptions message, length delimited. Does not implicitly {@link google.protobuf.EnumOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.EnumOptions
             * @static
             * @param {google.protobuf.IEnumOptions} message EnumOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EnumOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an EnumOptions message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.EnumOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.EnumOptions} EnumOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnumOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.EnumOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 2:
                        message.allowAlias = reader.bool();
                        break;
                    case 3:
                        message.deprecated = reader.bool();
                        break;
                    case 999:
                        if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                            message.uninterpretedOption = [];
                        message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an EnumOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.EnumOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.EnumOptions} EnumOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnumOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an EnumOptions message.
             * @function verify
             * @memberof google.protobuf.EnumOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            EnumOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.allowAlias != null && message.hasOwnProperty("allowAlias"))
                    if (typeof message.allowAlias !== "boolean")
                        return "allowAlias: boolean expected";
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    if (typeof message.deprecated !== "boolean")
                        return "deprecated: boolean expected";
                if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
                    if (!Array.isArray(message.uninterpretedOption))
                        return "uninterpretedOption: array expected";
                    for (var i = 0; i < message.uninterpretedOption.length; ++i) {
                        var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
                        if (error)
                            return "uninterpretedOption." + error;
                    }
                }
                return null;
            };

            /**
             * Creates an EnumOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.EnumOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.EnumOptions} EnumOptions
             */
            EnumOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.EnumOptions)
                    return object;
                var message = new $root.google.protobuf.EnumOptions();
                if (object.allowAlias != null)
                    message.allowAlias = Boolean(object.allowAlias);
                if (object.deprecated != null)
                    message.deprecated = Boolean(object.deprecated);
                if (object.uninterpretedOption) {
                    if (!Array.isArray(object.uninterpretedOption))
                        throw TypeError(".google.protobuf.EnumOptions.uninterpretedOption: array expected");
                    message.uninterpretedOption = [];
                    for (var i = 0; i < object.uninterpretedOption.length; ++i) {
                        if (typeof object.uninterpretedOption[i] !== "object")
                            throw TypeError(".google.protobuf.EnumOptions.uninterpretedOption: object expected");
                        message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpretedOption[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from an EnumOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.EnumOptions
             * @static
             * @param {google.protobuf.EnumOptions} message EnumOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            EnumOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.uninterpretedOption = [];
                if (options.defaults) {
                    object.allowAlias = false;
                    object.deprecated = false;
                }
                if (message.allowAlias != null && message.hasOwnProperty("allowAlias"))
                    object.allowAlias = message.allowAlias;
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    object.deprecated = message.deprecated;
                if (message.uninterpretedOption && message.uninterpretedOption.length) {
                    object.uninterpretedOption = [];
                    for (var j = 0; j < message.uninterpretedOption.length; ++j)
                        object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpretedOption[j], options);
                }
                return object;
            };

            /**
             * Converts this EnumOptions to JSON.
             * @function toJSON
             * @memberof google.protobuf.EnumOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            EnumOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return EnumOptions;
        })();

        protobuf.EnumValueOptions = (function() {

            /**
             * Properties of an EnumValueOptions.
             * @memberof google.protobuf
             * @interface IEnumValueOptions
             * @property {boolean|null} [deprecated] EnumValueOptions deprecated
             * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] EnumValueOptions uninterpretedOption
             */

            /**
             * Constructs a new EnumValueOptions.
             * @memberof google.protobuf
             * @classdesc Represents an EnumValueOptions.
             * @implements IEnumValueOptions
             * @constructor
             * @param {google.protobuf.IEnumValueOptions=} [properties] Properties to set
             */
            function EnumValueOptions(properties) {
                this.uninterpretedOption = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * EnumValueOptions deprecated.
             * @member {boolean} deprecated
             * @memberof google.protobuf.EnumValueOptions
             * @instance
             */
            EnumValueOptions.prototype.deprecated = false;

            /**
             * EnumValueOptions uninterpretedOption.
             * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
             * @memberof google.protobuf.EnumValueOptions
             * @instance
             */
            EnumValueOptions.prototype.uninterpretedOption = $util.emptyArray;

            /**
             * Creates a new EnumValueOptions instance using the specified properties.
             * @function create
             * @memberof google.protobuf.EnumValueOptions
             * @static
             * @param {google.protobuf.IEnumValueOptions=} [properties] Properties to set
             * @returns {google.protobuf.EnumValueOptions} EnumValueOptions instance
             */
            EnumValueOptions.create = function create(properties) {
                return new EnumValueOptions(properties);
            };

            /**
             * Encodes the specified EnumValueOptions message. Does not implicitly {@link google.protobuf.EnumValueOptions.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.EnumValueOptions
             * @static
             * @param {google.protobuf.IEnumValueOptions} message EnumValueOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EnumValueOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.deprecated != null && Object.hasOwnProperty.call(message, "deprecated"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.deprecated);
                if (message.uninterpretedOption != null && message.uninterpretedOption.length)
                    for (var i = 0; i < message.uninterpretedOption.length; ++i)
                        $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified EnumValueOptions message, length delimited. Does not implicitly {@link google.protobuf.EnumValueOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.EnumValueOptions
             * @static
             * @param {google.protobuf.IEnumValueOptions} message EnumValueOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EnumValueOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an EnumValueOptions message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.EnumValueOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.EnumValueOptions} EnumValueOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnumValueOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.EnumValueOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.deprecated = reader.bool();
                        break;
                    case 999:
                        if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                            message.uninterpretedOption = [];
                        message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an EnumValueOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.EnumValueOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.EnumValueOptions} EnumValueOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnumValueOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an EnumValueOptions message.
             * @function verify
             * @memberof google.protobuf.EnumValueOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            EnumValueOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    if (typeof message.deprecated !== "boolean")
                        return "deprecated: boolean expected";
                if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
                    if (!Array.isArray(message.uninterpretedOption))
                        return "uninterpretedOption: array expected";
                    for (var i = 0; i < message.uninterpretedOption.length; ++i) {
                        var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
                        if (error)
                            return "uninterpretedOption." + error;
                    }
                }
                return null;
            };

            /**
             * Creates an EnumValueOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.EnumValueOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.EnumValueOptions} EnumValueOptions
             */
            EnumValueOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.EnumValueOptions)
                    return object;
                var message = new $root.google.protobuf.EnumValueOptions();
                if (object.deprecated != null)
                    message.deprecated = Boolean(object.deprecated);
                if (object.uninterpretedOption) {
                    if (!Array.isArray(object.uninterpretedOption))
                        throw TypeError(".google.protobuf.EnumValueOptions.uninterpretedOption: array expected");
                    message.uninterpretedOption = [];
                    for (var i = 0; i < object.uninterpretedOption.length; ++i) {
                        if (typeof object.uninterpretedOption[i] !== "object")
                            throw TypeError(".google.protobuf.EnumValueOptions.uninterpretedOption: object expected");
                        message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpretedOption[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from an EnumValueOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.EnumValueOptions
             * @static
             * @param {google.protobuf.EnumValueOptions} message EnumValueOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            EnumValueOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.uninterpretedOption = [];
                if (options.defaults)
                    object.deprecated = false;
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    object.deprecated = message.deprecated;
                if (message.uninterpretedOption && message.uninterpretedOption.length) {
                    object.uninterpretedOption = [];
                    for (var j = 0; j < message.uninterpretedOption.length; ++j)
                        object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpretedOption[j], options);
                }
                return object;
            };

            /**
             * Converts this EnumValueOptions to JSON.
             * @function toJSON
             * @memberof google.protobuf.EnumValueOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            EnumValueOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return EnumValueOptions;
        })();

        protobuf.ServiceOptions = (function() {

            /**
             * Properties of a ServiceOptions.
             * @memberof google.protobuf
             * @interface IServiceOptions
             * @property {boolean|null} [deprecated] ServiceOptions deprecated
             * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] ServiceOptions uninterpretedOption
             */

            /**
             * Constructs a new ServiceOptions.
             * @memberof google.protobuf
             * @classdesc Represents a ServiceOptions.
             * @implements IServiceOptions
             * @constructor
             * @param {google.protobuf.IServiceOptions=} [properties] Properties to set
             */
            function ServiceOptions(properties) {
                this.uninterpretedOption = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ServiceOptions deprecated.
             * @member {boolean} deprecated
             * @memberof google.protobuf.ServiceOptions
             * @instance
             */
            ServiceOptions.prototype.deprecated = false;

            /**
             * ServiceOptions uninterpretedOption.
             * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
             * @memberof google.protobuf.ServiceOptions
             * @instance
             */
            ServiceOptions.prototype.uninterpretedOption = $util.emptyArray;

            /**
             * Creates a new ServiceOptions instance using the specified properties.
             * @function create
             * @memberof google.protobuf.ServiceOptions
             * @static
             * @param {google.protobuf.IServiceOptions=} [properties] Properties to set
             * @returns {google.protobuf.ServiceOptions} ServiceOptions instance
             */
            ServiceOptions.create = function create(properties) {
                return new ServiceOptions(properties);
            };

            /**
             * Encodes the specified ServiceOptions message. Does not implicitly {@link google.protobuf.ServiceOptions.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.ServiceOptions
             * @static
             * @param {google.protobuf.IServiceOptions} message ServiceOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ServiceOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.deprecated != null && Object.hasOwnProperty.call(message, "deprecated"))
                    writer.uint32(/* id 33, wireType 0 =*/264).bool(message.deprecated);
                if (message.uninterpretedOption != null && message.uninterpretedOption.length)
                    for (var i = 0; i < message.uninterpretedOption.length; ++i)
                        $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ServiceOptions message, length delimited. Does not implicitly {@link google.protobuf.ServiceOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.ServiceOptions
             * @static
             * @param {google.protobuf.IServiceOptions} message ServiceOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ServiceOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ServiceOptions message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.ServiceOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.ServiceOptions} ServiceOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ServiceOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.ServiceOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 33:
                        message.deprecated = reader.bool();
                        break;
                    case 999:
                        if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                            message.uninterpretedOption = [];
                        message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ServiceOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.ServiceOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.ServiceOptions} ServiceOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ServiceOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ServiceOptions message.
             * @function verify
             * @memberof google.protobuf.ServiceOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ServiceOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    if (typeof message.deprecated !== "boolean")
                        return "deprecated: boolean expected";
                if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
                    if (!Array.isArray(message.uninterpretedOption))
                        return "uninterpretedOption: array expected";
                    for (var i = 0; i < message.uninterpretedOption.length; ++i) {
                        var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
                        if (error)
                            return "uninterpretedOption." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a ServiceOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.ServiceOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.ServiceOptions} ServiceOptions
             */
            ServiceOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.ServiceOptions)
                    return object;
                var message = new $root.google.protobuf.ServiceOptions();
                if (object.deprecated != null)
                    message.deprecated = Boolean(object.deprecated);
                if (object.uninterpretedOption) {
                    if (!Array.isArray(object.uninterpretedOption))
                        throw TypeError(".google.protobuf.ServiceOptions.uninterpretedOption: array expected");
                    message.uninterpretedOption = [];
                    for (var i = 0; i < object.uninterpretedOption.length; ++i) {
                        if (typeof object.uninterpretedOption[i] !== "object")
                            throw TypeError(".google.protobuf.ServiceOptions.uninterpretedOption: object expected");
                        message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpretedOption[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a ServiceOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.ServiceOptions
             * @static
             * @param {google.protobuf.ServiceOptions} message ServiceOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ServiceOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.uninterpretedOption = [];
                if (options.defaults)
                    object.deprecated = false;
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    object.deprecated = message.deprecated;
                if (message.uninterpretedOption && message.uninterpretedOption.length) {
                    object.uninterpretedOption = [];
                    for (var j = 0; j < message.uninterpretedOption.length; ++j)
                        object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpretedOption[j], options);
                }
                return object;
            };

            /**
             * Converts this ServiceOptions to JSON.
             * @function toJSON
             * @memberof google.protobuf.ServiceOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ServiceOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ServiceOptions;
        })();

        protobuf.MethodOptions = (function() {

            /**
             * Properties of a MethodOptions.
             * @memberof google.protobuf
             * @interface IMethodOptions
             * @property {boolean|null} [deprecated] MethodOptions deprecated
             * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] MethodOptions uninterpretedOption
             */

            /**
             * Constructs a new MethodOptions.
             * @memberof google.protobuf
             * @classdesc Represents a MethodOptions.
             * @implements IMethodOptions
             * @constructor
             * @param {google.protobuf.IMethodOptions=} [properties] Properties to set
             */
            function MethodOptions(properties) {
                this.uninterpretedOption = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MethodOptions deprecated.
             * @member {boolean} deprecated
             * @memberof google.protobuf.MethodOptions
             * @instance
             */
            MethodOptions.prototype.deprecated = false;

            /**
             * MethodOptions uninterpretedOption.
             * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
             * @memberof google.protobuf.MethodOptions
             * @instance
             */
            MethodOptions.prototype.uninterpretedOption = $util.emptyArray;

            /**
             * Creates a new MethodOptions instance using the specified properties.
             * @function create
             * @memberof google.protobuf.MethodOptions
             * @static
             * @param {google.protobuf.IMethodOptions=} [properties] Properties to set
             * @returns {google.protobuf.MethodOptions} MethodOptions instance
             */
            MethodOptions.create = function create(properties) {
                return new MethodOptions(properties);
            };

            /**
             * Encodes the specified MethodOptions message. Does not implicitly {@link google.protobuf.MethodOptions.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.MethodOptions
             * @static
             * @param {google.protobuf.IMethodOptions} message MethodOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MethodOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.deprecated != null && Object.hasOwnProperty.call(message, "deprecated"))
                    writer.uint32(/* id 33, wireType 0 =*/264).bool(message.deprecated);
                if (message.uninterpretedOption != null && message.uninterpretedOption.length)
                    for (var i = 0; i < message.uninterpretedOption.length; ++i)
                        $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified MethodOptions message, length delimited. Does not implicitly {@link google.protobuf.MethodOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.MethodOptions
             * @static
             * @param {google.protobuf.IMethodOptions} message MethodOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MethodOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MethodOptions message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.MethodOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.MethodOptions} MethodOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MethodOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.MethodOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 33:
                        message.deprecated = reader.bool();
                        break;
                    case 999:
                        if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                            message.uninterpretedOption = [];
                        message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MethodOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.MethodOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.MethodOptions} MethodOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MethodOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MethodOptions message.
             * @function verify
             * @memberof google.protobuf.MethodOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MethodOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    if (typeof message.deprecated !== "boolean")
                        return "deprecated: boolean expected";
                if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
                    if (!Array.isArray(message.uninterpretedOption))
                        return "uninterpretedOption: array expected";
                    for (var i = 0; i < message.uninterpretedOption.length; ++i) {
                        var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
                        if (error)
                            return "uninterpretedOption." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a MethodOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.MethodOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.MethodOptions} MethodOptions
             */
            MethodOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.MethodOptions)
                    return object;
                var message = new $root.google.protobuf.MethodOptions();
                if (object.deprecated != null)
                    message.deprecated = Boolean(object.deprecated);
                if (object.uninterpretedOption) {
                    if (!Array.isArray(object.uninterpretedOption))
                        throw TypeError(".google.protobuf.MethodOptions.uninterpretedOption: array expected");
                    message.uninterpretedOption = [];
                    for (var i = 0; i < object.uninterpretedOption.length; ++i) {
                        if (typeof object.uninterpretedOption[i] !== "object")
                            throw TypeError(".google.protobuf.MethodOptions.uninterpretedOption: object expected");
                        message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpretedOption[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a MethodOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.MethodOptions
             * @static
             * @param {google.protobuf.MethodOptions} message MethodOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MethodOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.uninterpretedOption = [];
                if (options.defaults)
                    object.deprecated = false;
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    object.deprecated = message.deprecated;
                if (message.uninterpretedOption && message.uninterpretedOption.length) {
                    object.uninterpretedOption = [];
                    for (var j = 0; j < message.uninterpretedOption.length; ++j)
                        object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpretedOption[j], options);
                }
                return object;
            };

            /**
             * Converts this MethodOptions to JSON.
             * @function toJSON
             * @memberof google.protobuf.MethodOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MethodOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return MethodOptions;
        })();

        protobuf.UninterpretedOption = (function() {

            /**
             * Properties of an UninterpretedOption.
             * @memberof google.protobuf
             * @interface IUninterpretedOption
             * @property {Array.<google.protobuf.UninterpretedOption.INamePart>|null} [name] UninterpretedOption name
             * @property {string|null} [identifierValue] UninterpretedOption identifierValue
             * @property {number|Long|null} [positiveIntValue] UninterpretedOption positiveIntValue
             * @property {number|Long|null} [negativeIntValue] UninterpretedOption negativeIntValue
             * @property {number|null} [doubleValue] UninterpretedOption doubleValue
             * @property {Uint8Array|null} [stringValue] UninterpretedOption stringValue
             * @property {string|null} [aggregateValue] UninterpretedOption aggregateValue
             */

            /**
             * Constructs a new UninterpretedOption.
             * @memberof google.protobuf
             * @classdesc Represents an UninterpretedOption.
             * @implements IUninterpretedOption
             * @constructor
             * @param {google.protobuf.IUninterpretedOption=} [properties] Properties to set
             */
            function UninterpretedOption(properties) {
                this.name = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * UninterpretedOption name.
             * @member {Array.<google.protobuf.UninterpretedOption.INamePart>} name
             * @memberof google.protobuf.UninterpretedOption
             * @instance
             */
            UninterpretedOption.prototype.name = $util.emptyArray;

            /**
             * UninterpretedOption identifierValue.
             * @member {string} identifierValue
             * @memberof google.protobuf.UninterpretedOption
             * @instance
             */
            UninterpretedOption.prototype.identifierValue = "";

            /**
             * UninterpretedOption positiveIntValue.
             * @member {number|Long} positiveIntValue
             * @memberof google.protobuf.UninterpretedOption
             * @instance
             */
            UninterpretedOption.prototype.positiveIntValue = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * UninterpretedOption negativeIntValue.
             * @member {number|Long} negativeIntValue
             * @memberof google.protobuf.UninterpretedOption
             * @instance
             */
            UninterpretedOption.prototype.negativeIntValue = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * UninterpretedOption doubleValue.
             * @member {number} doubleValue
             * @memberof google.protobuf.UninterpretedOption
             * @instance
             */
            UninterpretedOption.prototype.doubleValue = 0;

            /**
             * UninterpretedOption stringValue.
             * @member {Uint8Array} stringValue
             * @memberof google.protobuf.UninterpretedOption
             * @instance
             */
            UninterpretedOption.prototype.stringValue = $util.newBuffer([]);

            /**
             * UninterpretedOption aggregateValue.
             * @member {string} aggregateValue
             * @memberof google.protobuf.UninterpretedOption
             * @instance
             */
            UninterpretedOption.prototype.aggregateValue = "";

            /**
             * Creates a new UninterpretedOption instance using the specified properties.
             * @function create
             * @memberof google.protobuf.UninterpretedOption
             * @static
             * @param {google.protobuf.IUninterpretedOption=} [properties] Properties to set
             * @returns {google.protobuf.UninterpretedOption} UninterpretedOption instance
             */
            UninterpretedOption.create = function create(properties) {
                return new UninterpretedOption(properties);
            };

            /**
             * Encodes the specified UninterpretedOption message. Does not implicitly {@link google.protobuf.UninterpretedOption.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.UninterpretedOption
             * @static
             * @param {google.protobuf.IUninterpretedOption} message UninterpretedOption message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UninterpretedOption.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && message.name.length)
                    for (var i = 0; i < message.name.length; ++i)
                        $root.google.protobuf.UninterpretedOption.NamePart.encode(message.name[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.identifierValue != null && Object.hasOwnProperty.call(message, "identifierValue"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.identifierValue);
                if (message.positiveIntValue != null && Object.hasOwnProperty.call(message, "positiveIntValue"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.positiveIntValue);
                if (message.negativeIntValue != null && Object.hasOwnProperty.call(message, "negativeIntValue"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int64(message.negativeIntValue);
                if (message.doubleValue != null && Object.hasOwnProperty.call(message, "doubleValue"))
                    writer.uint32(/* id 6, wireType 1 =*/49).double(message.doubleValue);
                if (message.stringValue != null && Object.hasOwnProperty.call(message, "stringValue"))
                    writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.stringValue);
                if (message.aggregateValue != null && Object.hasOwnProperty.call(message, "aggregateValue"))
                    writer.uint32(/* id 8, wireType 2 =*/66).string(message.aggregateValue);
                return writer;
            };

            /**
             * Encodes the specified UninterpretedOption message, length delimited. Does not implicitly {@link google.protobuf.UninterpretedOption.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.UninterpretedOption
             * @static
             * @param {google.protobuf.IUninterpretedOption} message UninterpretedOption message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UninterpretedOption.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an UninterpretedOption message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.UninterpretedOption
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.UninterpretedOption} UninterpretedOption
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UninterpretedOption.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.UninterpretedOption();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 2:
                        if (!(message.name && message.name.length))
                            message.name = [];
                        message.name.push($root.google.protobuf.UninterpretedOption.NamePart.decode(reader, reader.uint32()));
                        break;
                    case 3:
                        message.identifierValue = reader.string();
                        break;
                    case 4:
                        message.positiveIntValue = reader.uint64();
                        break;
                    case 5:
                        message.negativeIntValue = reader.int64();
                        break;
                    case 6:
                        message.doubleValue = reader.double();
                        break;
                    case 7:
                        message.stringValue = reader.bytes();
                        break;
                    case 8:
                        message.aggregateValue = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an UninterpretedOption message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.UninterpretedOption
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.UninterpretedOption} UninterpretedOption
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UninterpretedOption.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an UninterpretedOption message.
             * @function verify
             * @memberof google.protobuf.UninterpretedOption
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            UninterpretedOption.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name")) {
                    if (!Array.isArray(message.name))
                        return "name: array expected";
                    for (var i = 0; i < message.name.length; ++i) {
                        var error = $root.google.protobuf.UninterpretedOption.NamePart.verify(message.name[i]);
                        if (error)
                            return "name." + error;
                    }
                }
                if (message.identifierValue != null && message.hasOwnProperty("identifierValue"))
                    if (!$util.isString(message.identifierValue))
                        return "identifierValue: string expected";
                if (message.positiveIntValue != null && message.hasOwnProperty("positiveIntValue"))
                    if (!$util.isInteger(message.positiveIntValue) && !(message.positiveIntValue && $util.isInteger(message.positiveIntValue.low) && $util.isInteger(message.positiveIntValue.high)))
                        return "positiveIntValue: integer|Long expected";
                if (message.negativeIntValue != null && message.hasOwnProperty("negativeIntValue"))
                    if (!$util.isInteger(message.negativeIntValue) && !(message.negativeIntValue && $util.isInteger(message.negativeIntValue.low) && $util.isInteger(message.negativeIntValue.high)))
                        return "negativeIntValue: integer|Long expected";
                if (message.doubleValue != null && message.hasOwnProperty("doubleValue"))
                    if (typeof message.doubleValue !== "number")
                        return "doubleValue: number expected";
                if (message.stringValue != null && message.hasOwnProperty("stringValue"))
                    if (!(message.stringValue && typeof message.stringValue.length === "number" || $util.isString(message.stringValue)))
                        return "stringValue: buffer expected";
                if (message.aggregateValue != null && message.hasOwnProperty("aggregateValue"))
                    if (!$util.isString(message.aggregateValue))
                        return "aggregateValue: string expected";
                return null;
            };

            /**
             * Creates an UninterpretedOption message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.UninterpretedOption
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.UninterpretedOption} UninterpretedOption
             */
            UninterpretedOption.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.UninterpretedOption)
                    return object;
                var message = new $root.google.protobuf.UninterpretedOption();
                if (object.name) {
                    if (!Array.isArray(object.name))
                        throw TypeError(".google.protobuf.UninterpretedOption.name: array expected");
                    message.name = [];
                    for (var i = 0; i < object.name.length; ++i) {
                        if (typeof object.name[i] !== "object")
                            throw TypeError(".google.protobuf.UninterpretedOption.name: object expected");
                        message.name[i] = $root.google.protobuf.UninterpretedOption.NamePart.fromObject(object.name[i]);
                    }
                }
                if (object.identifierValue != null)
                    message.identifierValue = String(object.identifierValue);
                if (object.positiveIntValue != null)
                    if ($util.Long)
                        (message.positiveIntValue = $util.Long.fromValue(object.positiveIntValue)).unsigned = true;
                    else if (typeof object.positiveIntValue === "string")
                        message.positiveIntValue = parseInt(object.positiveIntValue, 10);
                    else if (typeof object.positiveIntValue === "number")
                        message.positiveIntValue = object.positiveIntValue;
                    else if (typeof object.positiveIntValue === "object")
                        message.positiveIntValue = new $util.LongBits(object.positiveIntValue.low >>> 0, object.positiveIntValue.high >>> 0).toNumber(true);
                if (object.negativeIntValue != null)
                    if ($util.Long)
                        (message.negativeIntValue = $util.Long.fromValue(object.negativeIntValue)).unsigned = false;
                    else if (typeof object.negativeIntValue === "string")
                        message.negativeIntValue = parseInt(object.negativeIntValue, 10);
                    else if (typeof object.negativeIntValue === "number")
                        message.negativeIntValue = object.negativeIntValue;
                    else if (typeof object.negativeIntValue === "object")
                        message.negativeIntValue = new $util.LongBits(object.negativeIntValue.low >>> 0, object.negativeIntValue.high >>> 0).toNumber();
                if (object.doubleValue != null)
                    message.doubleValue = Number(object.doubleValue);
                if (object.stringValue != null)
                    if (typeof object.stringValue === "string")
                        $util.base64.decode(object.stringValue, message.stringValue = $util.newBuffer($util.base64.length(object.stringValue)), 0);
                    else if (object.stringValue.length)
                        message.stringValue = object.stringValue;
                if (object.aggregateValue != null)
                    message.aggregateValue = String(object.aggregateValue);
                return message;
            };

            /**
             * Creates a plain object from an UninterpretedOption message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.UninterpretedOption
             * @static
             * @param {google.protobuf.UninterpretedOption} message UninterpretedOption
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            UninterpretedOption.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.name = [];
                if (options.defaults) {
                    object.identifierValue = "";
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.positiveIntValue = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.positiveIntValue = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.negativeIntValue = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.negativeIntValue = options.longs === String ? "0" : 0;
                    object.doubleValue = 0;
                    if (options.bytes === String)
                        object.stringValue = "";
                    else {
                        object.stringValue = [];
                        if (options.bytes !== Array)
                            object.stringValue = $util.newBuffer(object.stringValue);
                    }
                    object.aggregateValue = "";
                }
                if (message.name && message.name.length) {
                    object.name = [];
                    for (var j = 0; j < message.name.length; ++j)
                        object.name[j] = $root.google.protobuf.UninterpretedOption.NamePart.toObject(message.name[j], options);
                }
                if (message.identifierValue != null && message.hasOwnProperty("identifierValue"))
                    object.identifierValue = message.identifierValue;
                if (message.positiveIntValue != null && message.hasOwnProperty("positiveIntValue"))
                    if (typeof message.positiveIntValue === "number")
                        object.positiveIntValue = options.longs === String ? String(message.positiveIntValue) : message.positiveIntValue;
                    else
                        object.positiveIntValue = options.longs === String ? $util.Long.prototype.toString.call(message.positiveIntValue) : options.longs === Number ? new $util.LongBits(message.positiveIntValue.low >>> 0, message.positiveIntValue.high >>> 0).toNumber(true) : message.positiveIntValue;
                if (message.negativeIntValue != null && message.hasOwnProperty("negativeIntValue"))
                    if (typeof message.negativeIntValue === "number")
                        object.negativeIntValue = options.longs === String ? String(message.negativeIntValue) : message.negativeIntValue;
                    else
                        object.negativeIntValue = options.longs === String ? $util.Long.prototype.toString.call(message.negativeIntValue) : options.longs === Number ? new $util.LongBits(message.negativeIntValue.low >>> 0, message.negativeIntValue.high >>> 0).toNumber() : message.negativeIntValue;
                if (message.doubleValue != null && message.hasOwnProperty("doubleValue"))
                    object.doubleValue = options.json && !isFinite(message.doubleValue) ? String(message.doubleValue) : message.doubleValue;
                if (message.stringValue != null && message.hasOwnProperty("stringValue"))
                    object.stringValue = options.bytes === String ? $util.base64.encode(message.stringValue, 0, message.stringValue.length) : options.bytes === Array ? Array.prototype.slice.call(message.stringValue) : message.stringValue;
                if (message.aggregateValue != null && message.hasOwnProperty("aggregateValue"))
                    object.aggregateValue = message.aggregateValue;
                return object;
            };

            /**
             * Converts this UninterpretedOption to JSON.
             * @function toJSON
             * @memberof google.protobuf.UninterpretedOption
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            UninterpretedOption.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            UninterpretedOption.NamePart = (function() {

                /**
                 * Properties of a NamePart.
                 * @memberof google.protobuf.UninterpretedOption
                 * @interface INamePart
                 * @property {string} namePart NamePart namePart
                 * @property {boolean} isExtension NamePart isExtension
                 */

                /**
                 * Constructs a new NamePart.
                 * @memberof google.protobuf.UninterpretedOption
                 * @classdesc Represents a NamePart.
                 * @implements INamePart
                 * @constructor
                 * @param {google.protobuf.UninterpretedOption.INamePart=} [properties] Properties to set
                 */
                function NamePart(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * NamePart namePart.
                 * @member {string} namePart
                 * @memberof google.protobuf.UninterpretedOption.NamePart
                 * @instance
                 */
                NamePart.prototype.namePart = "";

                /**
                 * NamePart isExtension.
                 * @member {boolean} isExtension
                 * @memberof google.protobuf.UninterpretedOption.NamePart
                 * @instance
                 */
                NamePart.prototype.isExtension = false;

                /**
                 * Creates a new NamePart instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.UninterpretedOption.NamePart
                 * @static
                 * @param {google.protobuf.UninterpretedOption.INamePart=} [properties] Properties to set
                 * @returns {google.protobuf.UninterpretedOption.NamePart} NamePart instance
                 */
                NamePart.create = function create(properties) {
                    return new NamePart(properties);
                };

                /**
                 * Encodes the specified NamePart message. Does not implicitly {@link google.protobuf.UninterpretedOption.NamePart.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.UninterpretedOption.NamePart
                 * @static
                 * @param {google.protobuf.UninterpretedOption.INamePart} message NamePart message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NamePart.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.namePart);
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.isExtension);
                    return writer;
                };

                /**
                 * Encodes the specified NamePart message, length delimited. Does not implicitly {@link google.protobuf.UninterpretedOption.NamePart.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.UninterpretedOption.NamePart
                 * @static
                 * @param {google.protobuf.UninterpretedOption.INamePart} message NamePart message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NamePart.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a NamePart message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.UninterpretedOption.NamePart
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.UninterpretedOption.NamePart} NamePart
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NamePart.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.UninterpretedOption.NamePart();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.namePart = reader.string();
                            break;
                        case 2:
                            message.isExtension = reader.bool();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    if (!message.hasOwnProperty("namePart"))
                        throw $util.ProtocolError("missing required 'namePart'", { instance: message });
                    if (!message.hasOwnProperty("isExtension"))
                        throw $util.ProtocolError("missing required 'isExtension'", { instance: message });
                    return message;
                };

                /**
                 * Decodes a NamePart message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.UninterpretedOption.NamePart
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.UninterpretedOption.NamePart} NamePart
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NamePart.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a NamePart message.
                 * @function verify
                 * @memberof google.protobuf.UninterpretedOption.NamePart
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                NamePart.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (!$util.isString(message.namePart))
                        return "namePart: string expected";
                    if (typeof message.isExtension !== "boolean")
                        return "isExtension: boolean expected";
                    return null;
                };

                /**
                 * Creates a NamePart message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.UninterpretedOption.NamePart
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.UninterpretedOption.NamePart} NamePart
                 */
                NamePart.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.UninterpretedOption.NamePart)
                        return object;
                    var message = new $root.google.protobuf.UninterpretedOption.NamePart();
                    if (object.namePart != null)
                        message.namePart = String(object.namePart);
                    if (object.isExtension != null)
                        message.isExtension = Boolean(object.isExtension);
                    return message;
                };

                /**
                 * Creates a plain object from a NamePart message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.UninterpretedOption.NamePart
                 * @static
                 * @param {google.protobuf.UninterpretedOption.NamePart} message NamePart
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                NamePart.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.namePart = "";
                        object.isExtension = false;
                    }
                    if (message.namePart != null && message.hasOwnProperty("namePart"))
                        object.namePart = message.namePart;
                    if (message.isExtension != null && message.hasOwnProperty("isExtension"))
                        object.isExtension = message.isExtension;
                    return object;
                };

                /**
                 * Converts this NamePart to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.UninterpretedOption.NamePart
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                NamePart.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return NamePart;
            })();

            return UninterpretedOption;
        })();

        protobuf.SourceCodeInfo = (function() {

            /**
             * Properties of a SourceCodeInfo.
             * @memberof google.protobuf
             * @interface ISourceCodeInfo
             * @property {Array.<google.protobuf.SourceCodeInfo.ILocation>|null} [location] SourceCodeInfo location
             */

            /**
             * Constructs a new SourceCodeInfo.
             * @memberof google.protobuf
             * @classdesc Represents a SourceCodeInfo.
             * @implements ISourceCodeInfo
             * @constructor
             * @param {google.protobuf.ISourceCodeInfo=} [properties] Properties to set
             */
            function SourceCodeInfo(properties) {
                this.location = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SourceCodeInfo location.
             * @member {Array.<google.protobuf.SourceCodeInfo.ILocation>} location
             * @memberof google.protobuf.SourceCodeInfo
             * @instance
             */
            SourceCodeInfo.prototype.location = $util.emptyArray;

            /**
             * Creates a new SourceCodeInfo instance using the specified properties.
             * @function create
             * @memberof google.protobuf.SourceCodeInfo
             * @static
             * @param {google.protobuf.ISourceCodeInfo=} [properties] Properties to set
             * @returns {google.protobuf.SourceCodeInfo} SourceCodeInfo instance
             */
            SourceCodeInfo.create = function create(properties) {
                return new SourceCodeInfo(properties);
            };

            /**
             * Encodes the specified SourceCodeInfo message. Does not implicitly {@link google.protobuf.SourceCodeInfo.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.SourceCodeInfo
             * @static
             * @param {google.protobuf.ISourceCodeInfo} message SourceCodeInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SourceCodeInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.location != null && message.location.length)
                    for (var i = 0; i < message.location.length; ++i)
                        $root.google.protobuf.SourceCodeInfo.Location.encode(message.location[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified SourceCodeInfo message, length delimited. Does not implicitly {@link google.protobuf.SourceCodeInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.SourceCodeInfo
             * @static
             * @param {google.protobuf.ISourceCodeInfo} message SourceCodeInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SourceCodeInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SourceCodeInfo message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.SourceCodeInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.SourceCodeInfo} SourceCodeInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SourceCodeInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.SourceCodeInfo();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.location && message.location.length))
                            message.location = [];
                        message.location.push($root.google.protobuf.SourceCodeInfo.Location.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SourceCodeInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.SourceCodeInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.SourceCodeInfo} SourceCodeInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SourceCodeInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SourceCodeInfo message.
             * @function verify
             * @memberof google.protobuf.SourceCodeInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SourceCodeInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.location != null && message.hasOwnProperty("location")) {
                    if (!Array.isArray(message.location))
                        return "location: array expected";
                    for (var i = 0; i < message.location.length; ++i) {
                        var error = $root.google.protobuf.SourceCodeInfo.Location.verify(message.location[i]);
                        if (error)
                            return "location." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a SourceCodeInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.SourceCodeInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.SourceCodeInfo} SourceCodeInfo
             */
            SourceCodeInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.SourceCodeInfo)
                    return object;
                var message = new $root.google.protobuf.SourceCodeInfo();
                if (object.location) {
                    if (!Array.isArray(object.location))
                        throw TypeError(".google.protobuf.SourceCodeInfo.location: array expected");
                    message.location = [];
                    for (var i = 0; i < object.location.length; ++i) {
                        if (typeof object.location[i] !== "object")
                            throw TypeError(".google.protobuf.SourceCodeInfo.location: object expected");
                        message.location[i] = $root.google.protobuf.SourceCodeInfo.Location.fromObject(object.location[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a SourceCodeInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.SourceCodeInfo
             * @static
             * @param {google.protobuf.SourceCodeInfo} message SourceCodeInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SourceCodeInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.location = [];
                if (message.location && message.location.length) {
                    object.location = [];
                    for (var j = 0; j < message.location.length; ++j)
                        object.location[j] = $root.google.protobuf.SourceCodeInfo.Location.toObject(message.location[j], options);
                }
                return object;
            };

            /**
             * Converts this SourceCodeInfo to JSON.
             * @function toJSON
             * @memberof google.protobuf.SourceCodeInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SourceCodeInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            SourceCodeInfo.Location = (function() {

                /**
                 * Properties of a Location.
                 * @memberof google.protobuf.SourceCodeInfo
                 * @interface ILocation
                 * @property {Array.<number>|null} [path] Location path
                 * @property {Array.<number>|null} [span] Location span
                 * @property {string|null} [leadingComments] Location leadingComments
                 * @property {string|null} [trailingComments] Location trailingComments
                 * @property {Array.<string>|null} [leadingDetachedComments] Location leadingDetachedComments
                 */

                /**
                 * Constructs a new Location.
                 * @memberof google.protobuf.SourceCodeInfo
                 * @classdesc Represents a Location.
                 * @implements ILocation
                 * @constructor
                 * @param {google.protobuf.SourceCodeInfo.ILocation=} [properties] Properties to set
                 */
                function Location(properties) {
                    this.path = [];
                    this.span = [];
                    this.leadingDetachedComments = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Location path.
                 * @member {Array.<number>} path
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @instance
                 */
                Location.prototype.path = $util.emptyArray;

                /**
                 * Location span.
                 * @member {Array.<number>} span
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @instance
                 */
                Location.prototype.span = $util.emptyArray;

                /**
                 * Location leadingComments.
                 * @member {string} leadingComments
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @instance
                 */
                Location.prototype.leadingComments = "";

                /**
                 * Location trailingComments.
                 * @member {string} trailingComments
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @instance
                 */
                Location.prototype.trailingComments = "";

                /**
                 * Location leadingDetachedComments.
                 * @member {Array.<string>} leadingDetachedComments
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @instance
                 */
                Location.prototype.leadingDetachedComments = $util.emptyArray;

                /**
                 * Creates a new Location instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @static
                 * @param {google.protobuf.SourceCodeInfo.ILocation=} [properties] Properties to set
                 * @returns {google.protobuf.SourceCodeInfo.Location} Location instance
                 */
                Location.create = function create(properties) {
                    return new Location(properties);
                };

                /**
                 * Encodes the specified Location message. Does not implicitly {@link google.protobuf.SourceCodeInfo.Location.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @static
                 * @param {google.protobuf.SourceCodeInfo.ILocation} message Location message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Location.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.path != null && message.path.length) {
                        writer.uint32(/* id 1, wireType 2 =*/10).fork();
                        for (var i = 0; i < message.path.length; ++i)
                            writer.int32(message.path[i]);
                        writer.ldelim();
                    }
                    if (message.span != null && message.span.length) {
                        writer.uint32(/* id 2, wireType 2 =*/18).fork();
                        for (var i = 0; i < message.span.length; ++i)
                            writer.int32(message.span[i]);
                        writer.ldelim();
                    }
                    if (message.leadingComments != null && Object.hasOwnProperty.call(message, "leadingComments"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.leadingComments);
                    if (message.trailingComments != null && Object.hasOwnProperty.call(message, "trailingComments"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.trailingComments);
                    if (message.leadingDetachedComments != null && message.leadingDetachedComments.length)
                        for (var i = 0; i < message.leadingDetachedComments.length; ++i)
                            writer.uint32(/* id 6, wireType 2 =*/50).string(message.leadingDetachedComments[i]);
                    return writer;
                };

                /**
                 * Encodes the specified Location message, length delimited. Does not implicitly {@link google.protobuf.SourceCodeInfo.Location.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @static
                 * @param {google.protobuf.SourceCodeInfo.ILocation} message Location message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Location.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Location message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.SourceCodeInfo.Location} Location
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Location.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.SourceCodeInfo.Location();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.path && message.path.length))
                                message.path = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.path.push(reader.int32());
                            } else
                                message.path.push(reader.int32());
                            break;
                        case 2:
                            if (!(message.span && message.span.length))
                                message.span = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.span.push(reader.int32());
                            } else
                                message.span.push(reader.int32());
                            break;
                        case 3:
                            message.leadingComments = reader.string();
                            break;
                        case 4:
                            message.trailingComments = reader.string();
                            break;
                        case 6:
                            if (!(message.leadingDetachedComments && message.leadingDetachedComments.length))
                                message.leadingDetachedComments = [];
                            message.leadingDetachedComments.push(reader.string());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Location message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.SourceCodeInfo.Location} Location
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Location.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Location message.
                 * @function verify
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Location.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.path != null && message.hasOwnProperty("path")) {
                        if (!Array.isArray(message.path))
                            return "path: array expected";
                        for (var i = 0; i < message.path.length; ++i)
                            if (!$util.isInteger(message.path[i]))
                                return "path: integer[] expected";
                    }
                    if (message.span != null && message.hasOwnProperty("span")) {
                        if (!Array.isArray(message.span))
                            return "span: array expected";
                        for (var i = 0; i < message.span.length; ++i)
                            if (!$util.isInteger(message.span[i]))
                                return "span: integer[] expected";
                    }
                    if (message.leadingComments != null && message.hasOwnProperty("leadingComments"))
                        if (!$util.isString(message.leadingComments))
                            return "leadingComments: string expected";
                    if (message.trailingComments != null && message.hasOwnProperty("trailingComments"))
                        if (!$util.isString(message.trailingComments))
                            return "trailingComments: string expected";
                    if (message.leadingDetachedComments != null && message.hasOwnProperty("leadingDetachedComments")) {
                        if (!Array.isArray(message.leadingDetachedComments))
                            return "leadingDetachedComments: array expected";
                        for (var i = 0; i < message.leadingDetachedComments.length; ++i)
                            if (!$util.isString(message.leadingDetachedComments[i]))
                                return "leadingDetachedComments: string[] expected";
                    }
                    return null;
                };

                /**
                 * Creates a Location message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.SourceCodeInfo.Location} Location
                 */
                Location.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.SourceCodeInfo.Location)
                        return object;
                    var message = new $root.google.protobuf.SourceCodeInfo.Location();
                    if (object.path) {
                        if (!Array.isArray(object.path))
                            throw TypeError(".google.protobuf.SourceCodeInfo.Location.path: array expected");
                        message.path = [];
                        for (var i = 0; i < object.path.length; ++i)
                            message.path[i] = object.path[i] | 0;
                    }
                    if (object.span) {
                        if (!Array.isArray(object.span))
                            throw TypeError(".google.protobuf.SourceCodeInfo.Location.span: array expected");
                        message.span = [];
                        for (var i = 0; i < object.span.length; ++i)
                            message.span[i] = object.span[i] | 0;
                    }
                    if (object.leadingComments != null)
                        message.leadingComments = String(object.leadingComments);
                    if (object.trailingComments != null)
                        message.trailingComments = String(object.trailingComments);
                    if (object.leadingDetachedComments) {
                        if (!Array.isArray(object.leadingDetachedComments))
                            throw TypeError(".google.protobuf.SourceCodeInfo.Location.leadingDetachedComments: array expected");
                        message.leadingDetachedComments = [];
                        for (var i = 0; i < object.leadingDetachedComments.length; ++i)
                            message.leadingDetachedComments[i] = String(object.leadingDetachedComments[i]);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Location message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @static
                 * @param {google.protobuf.SourceCodeInfo.Location} message Location
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Location.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults) {
                        object.path = [];
                        object.span = [];
                        object.leadingDetachedComments = [];
                    }
                    if (options.defaults) {
                        object.leadingComments = "";
                        object.trailingComments = "";
                    }
                    if (message.path && message.path.length) {
                        object.path = [];
                        for (var j = 0; j < message.path.length; ++j)
                            object.path[j] = message.path[j];
                    }
                    if (message.span && message.span.length) {
                        object.span = [];
                        for (var j = 0; j < message.span.length; ++j)
                            object.span[j] = message.span[j];
                    }
                    if (message.leadingComments != null && message.hasOwnProperty("leadingComments"))
                        object.leadingComments = message.leadingComments;
                    if (message.trailingComments != null && message.hasOwnProperty("trailingComments"))
                        object.trailingComments = message.trailingComments;
                    if (message.leadingDetachedComments && message.leadingDetachedComments.length) {
                        object.leadingDetachedComments = [];
                        for (var j = 0; j < message.leadingDetachedComments.length; ++j)
                            object.leadingDetachedComments[j] = message.leadingDetachedComments[j];
                    }
                    return object;
                };

                /**
                 * Converts this Location to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Location.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Location;
            })();

            return SourceCodeInfo;
        })();

        protobuf.GeneratedCodeInfo = (function() {

            /**
             * Properties of a GeneratedCodeInfo.
             * @memberof google.protobuf
             * @interface IGeneratedCodeInfo
             * @property {Array.<google.protobuf.GeneratedCodeInfo.IAnnotation>|null} [annotation] GeneratedCodeInfo annotation
             */

            /**
             * Constructs a new GeneratedCodeInfo.
             * @memberof google.protobuf
             * @classdesc Represents a GeneratedCodeInfo.
             * @implements IGeneratedCodeInfo
             * @constructor
             * @param {google.protobuf.IGeneratedCodeInfo=} [properties] Properties to set
             */
            function GeneratedCodeInfo(properties) {
                this.annotation = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GeneratedCodeInfo annotation.
             * @member {Array.<google.protobuf.GeneratedCodeInfo.IAnnotation>} annotation
             * @memberof google.protobuf.GeneratedCodeInfo
             * @instance
             */
            GeneratedCodeInfo.prototype.annotation = $util.emptyArray;

            /**
             * Creates a new GeneratedCodeInfo instance using the specified properties.
             * @function create
             * @memberof google.protobuf.GeneratedCodeInfo
             * @static
             * @param {google.protobuf.IGeneratedCodeInfo=} [properties] Properties to set
             * @returns {google.protobuf.GeneratedCodeInfo} GeneratedCodeInfo instance
             */
            GeneratedCodeInfo.create = function create(properties) {
                return new GeneratedCodeInfo(properties);
            };

            /**
             * Encodes the specified GeneratedCodeInfo message. Does not implicitly {@link google.protobuf.GeneratedCodeInfo.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.GeneratedCodeInfo
             * @static
             * @param {google.protobuf.IGeneratedCodeInfo} message GeneratedCodeInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GeneratedCodeInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.annotation != null && message.annotation.length)
                    for (var i = 0; i < message.annotation.length; ++i)
                        $root.google.protobuf.GeneratedCodeInfo.Annotation.encode(message.annotation[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified GeneratedCodeInfo message, length delimited. Does not implicitly {@link google.protobuf.GeneratedCodeInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.GeneratedCodeInfo
             * @static
             * @param {google.protobuf.IGeneratedCodeInfo} message GeneratedCodeInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GeneratedCodeInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GeneratedCodeInfo message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.GeneratedCodeInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.GeneratedCodeInfo} GeneratedCodeInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GeneratedCodeInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.GeneratedCodeInfo();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.annotation && message.annotation.length))
                            message.annotation = [];
                        message.annotation.push($root.google.protobuf.GeneratedCodeInfo.Annotation.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GeneratedCodeInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.GeneratedCodeInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.GeneratedCodeInfo} GeneratedCodeInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GeneratedCodeInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GeneratedCodeInfo message.
             * @function verify
             * @memberof google.protobuf.GeneratedCodeInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GeneratedCodeInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.annotation != null && message.hasOwnProperty("annotation")) {
                    if (!Array.isArray(message.annotation))
                        return "annotation: array expected";
                    for (var i = 0; i < message.annotation.length; ++i) {
                        var error = $root.google.protobuf.GeneratedCodeInfo.Annotation.verify(message.annotation[i]);
                        if (error)
                            return "annotation." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a GeneratedCodeInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.GeneratedCodeInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.GeneratedCodeInfo} GeneratedCodeInfo
             */
            GeneratedCodeInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.GeneratedCodeInfo)
                    return object;
                var message = new $root.google.protobuf.GeneratedCodeInfo();
                if (object.annotation) {
                    if (!Array.isArray(object.annotation))
                        throw TypeError(".google.protobuf.GeneratedCodeInfo.annotation: array expected");
                    message.annotation = [];
                    for (var i = 0; i < object.annotation.length; ++i) {
                        if (typeof object.annotation[i] !== "object")
                            throw TypeError(".google.protobuf.GeneratedCodeInfo.annotation: object expected");
                        message.annotation[i] = $root.google.protobuf.GeneratedCodeInfo.Annotation.fromObject(object.annotation[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a GeneratedCodeInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.GeneratedCodeInfo
             * @static
             * @param {google.protobuf.GeneratedCodeInfo} message GeneratedCodeInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GeneratedCodeInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.annotation = [];
                if (message.annotation && message.annotation.length) {
                    object.annotation = [];
                    for (var j = 0; j < message.annotation.length; ++j)
                        object.annotation[j] = $root.google.protobuf.GeneratedCodeInfo.Annotation.toObject(message.annotation[j], options);
                }
                return object;
            };

            /**
             * Converts this GeneratedCodeInfo to JSON.
             * @function toJSON
             * @memberof google.protobuf.GeneratedCodeInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GeneratedCodeInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            GeneratedCodeInfo.Annotation = (function() {

                /**
                 * Properties of an Annotation.
                 * @memberof google.protobuf.GeneratedCodeInfo
                 * @interface IAnnotation
                 * @property {Array.<number>|null} [path] Annotation path
                 * @property {string|null} [sourceFile] Annotation sourceFile
                 * @property {number|null} [begin] Annotation begin
                 * @property {number|null} [end] Annotation end
                 */

                /**
                 * Constructs a new Annotation.
                 * @memberof google.protobuf.GeneratedCodeInfo
                 * @classdesc Represents an Annotation.
                 * @implements IAnnotation
                 * @constructor
                 * @param {google.protobuf.GeneratedCodeInfo.IAnnotation=} [properties] Properties to set
                 */
                function Annotation(properties) {
                    this.path = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Annotation path.
                 * @member {Array.<number>} path
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @instance
                 */
                Annotation.prototype.path = $util.emptyArray;

                /**
                 * Annotation sourceFile.
                 * @member {string} sourceFile
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @instance
                 */
                Annotation.prototype.sourceFile = "";

                /**
                 * Annotation begin.
                 * @member {number} begin
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @instance
                 */
                Annotation.prototype.begin = 0;

                /**
                 * Annotation end.
                 * @member {number} end
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @instance
                 */
                Annotation.prototype.end = 0;

                /**
                 * Creates a new Annotation instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @static
                 * @param {google.protobuf.GeneratedCodeInfo.IAnnotation=} [properties] Properties to set
                 * @returns {google.protobuf.GeneratedCodeInfo.Annotation} Annotation instance
                 */
                Annotation.create = function create(properties) {
                    return new Annotation(properties);
                };

                /**
                 * Encodes the specified Annotation message. Does not implicitly {@link google.protobuf.GeneratedCodeInfo.Annotation.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @static
                 * @param {google.protobuf.GeneratedCodeInfo.IAnnotation} message Annotation message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Annotation.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.path != null && message.path.length) {
                        writer.uint32(/* id 1, wireType 2 =*/10).fork();
                        for (var i = 0; i < message.path.length; ++i)
                            writer.int32(message.path[i]);
                        writer.ldelim();
                    }
                    if (message.sourceFile != null && Object.hasOwnProperty.call(message, "sourceFile"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.sourceFile);
                    if (message.begin != null && Object.hasOwnProperty.call(message, "begin"))
                        writer.uint32(/* id 3, wireType 0 =*/24).int32(message.begin);
                    if (message.end != null && Object.hasOwnProperty.call(message, "end"))
                        writer.uint32(/* id 4, wireType 0 =*/32).int32(message.end);
                    return writer;
                };

                /**
                 * Encodes the specified Annotation message, length delimited. Does not implicitly {@link google.protobuf.GeneratedCodeInfo.Annotation.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @static
                 * @param {google.protobuf.GeneratedCodeInfo.IAnnotation} message Annotation message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Annotation.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an Annotation message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.GeneratedCodeInfo.Annotation} Annotation
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Annotation.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.GeneratedCodeInfo.Annotation();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.path && message.path.length))
                                message.path = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.path.push(reader.int32());
                            } else
                                message.path.push(reader.int32());
                            break;
                        case 2:
                            message.sourceFile = reader.string();
                            break;
                        case 3:
                            message.begin = reader.int32();
                            break;
                        case 4:
                            message.end = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an Annotation message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.GeneratedCodeInfo.Annotation} Annotation
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Annotation.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an Annotation message.
                 * @function verify
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Annotation.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.path != null && message.hasOwnProperty("path")) {
                        if (!Array.isArray(message.path))
                            return "path: array expected";
                        for (var i = 0; i < message.path.length; ++i)
                            if (!$util.isInteger(message.path[i]))
                                return "path: integer[] expected";
                    }
                    if (message.sourceFile != null && message.hasOwnProperty("sourceFile"))
                        if (!$util.isString(message.sourceFile))
                            return "sourceFile: string expected";
                    if (message.begin != null && message.hasOwnProperty("begin"))
                        if (!$util.isInteger(message.begin))
                            return "begin: integer expected";
                    if (message.end != null && message.hasOwnProperty("end"))
                        if (!$util.isInteger(message.end))
                            return "end: integer expected";
                    return null;
                };

                /**
                 * Creates an Annotation message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.GeneratedCodeInfo.Annotation} Annotation
                 */
                Annotation.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.GeneratedCodeInfo.Annotation)
                        return object;
                    var message = new $root.google.protobuf.GeneratedCodeInfo.Annotation();
                    if (object.path) {
                        if (!Array.isArray(object.path))
                            throw TypeError(".google.protobuf.GeneratedCodeInfo.Annotation.path: array expected");
                        message.path = [];
                        for (var i = 0; i < object.path.length; ++i)
                            message.path[i] = object.path[i] | 0;
                    }
                    if (object.sourceFile != null)
                        message.sourceFile = String(object.sourceFile);
                    if (object.begin != null)
                        message.begin = object.begin | 0;
                    if (object.end != null)
                        message.end = object.end | 0;
                    return message;
                };

                /**
                 * Creates a plain object from an Annotation message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @static
                 * @param {google.protobuf.GeneratedCodeInfo.Annotation} message Annotation
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Annotation.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.path = [];
                    if (options.defaults) {
                        object.sourceFile = "";
                        object.begin = 0;
                        object.end = 0;
                    }
                    if (message.path && message.path.length) {
                        object.path = [];
                        for (var j = 0; j < message.path.length; ++j)
                            object.path[j] = message.path[j];
                    }
                    if (message.sourceFile != null && message.hasOwnProperty("sourceFile"))
                        object.sourceFile = message.sourceFile;
                    if (message.begin != null && message.hasOwnProperty("begin"))
                        object.begin = message.begin;
                    if (message.end != null && message.hasOwnProperty("end"))
                        object.end = message.end;
                    return object;
                };

                /**
                 * Converts this Annotation to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Annotation.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Annotation;
            })();

            return GeneratedCodeInfo;
        })();

        protobuf.Any = (function() {

            /**
             * Properties of an Any.
             * @memberof google.protobuf
             * @interface IAny
             * @property {string|null} [type_url] Any type_url
             * @property {Uint8Array|null} [value] Any value
             */

            /**
             * Constructs a new Any.
             * @memberof google.protobuf
             * @classdesc Represents an Any.
             * @implements IAny
             * @constructor
             * @param {google.protobuf.IAny=} [properties] Properties to set
             */
            function Any(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Any type_url.
             * @member {string} type_url
             * @memberof google.protobuf.Any
             * @instance
             */
            Any.prototype.type_url = "";

            /**
             * Any value.
             * @member {Uint8Array} value
             * @memberof google.protobuf.Any
             * @instance
             */
            Any.prototype.value = $util.newBuffer([]);

            /**
             * Creates a new Any instance using the specified properties.
             * @function create
             * @memberof google.protobuf.Any
             * @static
             * @param {google.protobuf.IAny=} [properties] Properties to set
             * @returns {google.protobuf.Any} Any instance
             */
            Any.create = function create(properties) {
                return new Any(properties);
            };

            /**
             * Encodes the specified Any message. Does not implicitly {@link google.protobuf.Any.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.Any
             * @static
             * @param {google.protobuf.IAny} message Any message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Any.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.type_url != null && Object.hasOwnProperty.call(message, "type_url"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.type_url);
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.value);
                return writer;
            };

            /**
             * Encodes the specified Any message, length delimited. Does not implicitly {@link google.protobuf.Any.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.Any
             * @static
             * @param {google.protobuf.IAny} message Any message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Any.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an Any message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.Any
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.Any} Any
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Any.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.Any();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.type_url = reader.string();
                        break;
                    case 2:
                        message.value = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an Any message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.Any
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.Any} Any
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Any.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an Any message.
             * @function verify
             * @memberof google.protobuf.Any
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Any.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.type_url != null && message.hasOwnProperty("type_url"))
                    if (!$util.isString(message.type_url))
                        return "type_url: string expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                        return "value: buffer expected";
                return null;
            };

            /**
             * Creates an Any message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.Any
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.Any} Any
             */
            Any.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.Any)
                    return object;
                var message = new $root.google.protobuf.Any();
                if (object.type_url != null)
                    message.type_url = String(object.type_url);
                if (object.value != null)
                    if (typeof object.value === "string")
                        $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                    else if (object.value.length)
                        message.value = object.value;
                return message;
            };

            /**
             * Creates a plain object from an Any message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.Any
             * @static
             * @param {google.protobuf.Any} message Any
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Any.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.type_url = "";
                    if (options.bytes === String)
                        object.value = "";
                    else {
                        object.value = [];
                        if (options.bytes !== Array)
                            object.value = $util.newBuffer(object.value);
                    }
                }
                if (message.type_url != null && message.hasOwnProperty("type_url"))
                    object.type_url = message.type_url;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
                return object;
            };

            /**
             * Converts this Any to JSON.
             * @function toJSON
             * @memberof google.protobuf.Any
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Any.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Any;
        })();

        protobuf.Duration = (function() {

            /**
             * Properties of a Duration.
             * @memberof google.protobuf
             * @interface IDuration
             * @property {number|Long|null} [seconds] Duration seconds
             * @property {number|null} [nanos] Duration nanos
             */

            /**
             * Constructs a new Duration.
             * @memberof google.protobuf
             * @classdesc Represents a Duration.
             * @implements IDuration
             * @constructor
             * @param {google.protobuf.IDuration=} [properties] Properties to set
             */
            function Duration(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Duration seconds.
             * @member {number|Long} seconds
             * @memberof google.protobuf.Duration
             * @instance
             */
            Duration.prototype.seconds = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Duration nanos.
             * @member {number} nanos
             * @memberof google.protobuf.Duration
             * @instance
             */
            Duration.prototype.nanos = 0;

            /**
             * Creates a new Duration instance using the specified properties.
             * @function create
             * @memberof google.protobuf.Duration
             * @static
             * @param {google.protobuf.IDuration=} [properties] Properties to set
             * @returns {google.protobuf.Duration} Duration instance
             */
            Duration.create = function create(properties) {
                return new Duration(properties);
            };

            /**
             * Encodes the specified Duration message. Does not implicitly {@link google.protobuf.Duration.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.Duration
             * @static
             * @param {google.protobuf.IDuration} message Duration message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Duration.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.seconds != null && Object.hasOwnProperty.call(message, "seconds"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.seconds);
                if (message.nanos != null && Object.hasOwnProperty.call(message, "nanos"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.nanos);
                return writer;
            };

            /**
             * Encodes the specified Duration message, length delimited. Does not implicitly {@link google.protobuf.Duration.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.Duration
             * @static
             * @param {google.protobuf.IDuration} message Duration message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Duration.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Duration message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.Duration
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.Duration} Duration
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Duration.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.Duration();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.seconds = reader.int64();
                        break;
                    case 2:
                        message.nanos = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Duration message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.Duration
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.Duration} Duration
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Duration.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Duration message.
             * @function verify
             * @memberof google.protobuf.Duration
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Duration.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.seconds != null && message.hasOwnProperty("seconds"))
                    if (!$util.isInteger(message.seconds) && !(message.seconds && $util.isInteger(message.seconds.low) && $util.isInteger(message.seconds.high)))
                        return "seconds: integer|Long expected";
                if (message.nanos != null && message.hasOwnProperty("nanos"))
                    if (!$util.isInteger(message.nanos))
                        return "nanos: integer expected";
                return null;
            };

            /**
             * Creates a Duration message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.Duration
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.Duration} Duration
             */
            Duration.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.Duration)
                    return object;
                var message = new $root.google.protobuf.Duration();
                if (object.seconds != null)
                    if ($util.Long)
                        (message.seconds = $util.Long.fromValue(object.seconds)).unsigned = false;
                    else if (typeof object.seconds === "string")
                        message.seconds = parseInt(object.seconds, 10);
                    else if (typeof object.seconds === "number")
                        message.seconds = object.seconds;
                    else if (typeof object.seconds === "object")
                        message.seconds = new $util.LongBits(object.seconds.low >>> 0, object.seconds.high >>> 0).toNumber();
                if (object.nanos != null)
                    message.nanos = object.nanos | 0;
                return message;
            };

            /**
             * Creates a plain object from a Duration message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.Duration
             * @static
             * @param {google.protobuf.Duration} message Duration
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Duration.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.seconds = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.seconds = options.longs === String ? "0" : 0;
                    object.nanos = 0;
                }
                if (message.seconds != null && message.hasOwnProperty("seconds"))
                    if (typeof message.seconds === "number")
                        object.seconds = options.longs === String ? String(message.seconds) : message.seconds;
                    else
                        object.seconds = options.longs === String ? $util.Long.prototype.toString.call(message.seconds) : options.longs === Number ? new $util.LongBits(message.seconds.low >>> 0, message.seconds.high >>> 0).toNumber() : message.seconds;
                if (message.nanos != null && message.hasOwnProperty("nanos"))
                    object.nanos = message.nanos;
                return object;
            };

            /**
             * Converts this Duration to JSON.
             * @function toJSON
             * @memberof google.protobuf.Duration
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Duration.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Duration;
        })();

        protobuf.Struct = (function() {

            /**
             * Properties of a Struct.
             * @memberof google.protobuf
             * @interface IStruct
             * @property {Object.<string,google.protobuf.IValue>|null} [fields] Struct fields
             */

            /**
             * Constructs a new Struct.
             * @memberof google.protobuf
             * @classdesc Represents a Struct.
             * @implements IStruct
             * @constructor
             * @param {google.protobuf.IStruct=} [properties] Properties to set
             */
            function Struct(properties) {
                this.fields = {};
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Struct fields.
             * @member {Object.<string,google.protobuf.IValue>} fields
             * @memberof google.protobuf.Struct
             * @instance
             */
            Struct.prototype.fields = $util.emptyObject;

            /**
             * Creates a new Struct instance using the specified properties.
             * @function create
             * @memberof google.protobuf.Struct
             * @static
             * @param {google.protobuf.IStruct=} [properties] Properties to set
             * @returns {google.protobuf.Struct} Struct instance
             */
            Struct.create = function create(properties) {
                return new Struct(properties);
            };

            /**
             * Encodes the specified Struct message. Does not implicitly {@link google.protobuf.Struct.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.Struct
             * @static
             * @param {google.protobuf.IStruct} message Struct message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Struct.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.fields != null && Object.hasOwnProperty.call(message, "fields"))
                    for (var keys = Object.keys(message.fields), i = 0; i < keys.length; ++i) {
                        writer.uint32(/* id 1, wireType 2 =*/10).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                        $root.google.protobuf.Value.encode(message.fields[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                    }
                return writer;
            };

            /**
             * Encodes the specified Struct message, length delimited. Does not implicitly {@link google.protobuf.Struct.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.Struct
             * @static
             * @param {google.protobuf.IStruct} message Struct message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Struct.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Struct message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.Struct
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.Struct} Struct
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Struct.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.Struct(), key, value;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (message.fields === $util.emptyObject)
                            message.fields = {};
                        var end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = null;
                        while (reader.pos < end2) {
                            var tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = $root.google.protobuf.Value.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.fields[key] = value;
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Struct message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.Struct
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.Struct} Struct
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Struct.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Struct message.
             * @function verify
             * @memberof google.protobuf.Struct
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Struct.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.fields != null && message.hasOwnProperty("fields")) {
                    if (!$util.isObject(message.fields))
                        return "fields: object expected";
                    var key = Object.keys(message.fields);
                    for (var i = 0; i < key.length; ++i) {
                        var error = $root.google.protobuf.Value.verify(message.fields[key[i]]);
                        if (error)
                            return "fields." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a Struct message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.Struct
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.Struct} Struct
             */
            Struct.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.Struct)
                    return object;
                var message = new $root.google.protobuf.Struct();
                if (object.fields) {
                    if (typeof object.fields !== "object")
                        throw TypeError(".google.protobuf.Struct.fields: object expected");
                    message.fields = {};
                    for (var keys = Object.keys(object.fields), i = 0; i < keys.length; ++i) {
                        if (typeof object.fields[keys[i]] !== "object")
                            throw TypeError(".google.protobuf.Struct.fields: object expected");
                        message.fields[keys[i]] = $root.google.protobuf.Value.fromObject(object.fields[keys[i]]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a Struct message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.Struct
             * @static
             * @param {google.protobuf.Struct} message Struct
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Struct.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.objects || options.defaults)
                    object.fields = {};
                var keys2;
                if (message.fields && (keys2 = Object.keys(message.fields)).length) {
                    object.fields = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.fields[keys2[j]] = $root.google.protobuf.Value.toObject(message.fields[keys2[j]], options);
                }
                return object;
            };

            /**
             * Converts this Struct to JSON.
             * @function toJSON
             * @memberof google.protobuf.Struct
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Struct.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Struct;
        })();

        protobuf.Value = (function() {

            /**
             * Properties of a Value.
             * @memberof google.protobuf
             * @interface IValue
             * @property {google.protobuf.NullValue|null} [nullValue] Value nullValue
             * @property {number|null} [numberValue] Value numberValue
             * @property {string|null} [stringValue] Value stringValue
             * @property {boolean|null} [boolValue] Value boolValue
             * @property {google.protobuf.IStruct|null} [structValue] Value structValue
             * @property {google.protobuf.IListValue|null} [listValue] Value listValue
             */

            /**
             * Constructs a new Value.
             * @memberof google.protobuf
             * @classdesc Represents a Value.
             * @implements IValue
             * @constructor
             * @param {google.protobuf.IValue=} [properties] Properties to set
             */
            function Value(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Value nullValue.
             * @member {google.protobuf.NullValue|null|undefined} nullValue
             * @memberof google.protobuf.Value
             * @instance
             */
            Value.prototype.nullValue = null;

            /**
             * Value numberValue.
             * @member {number|null|undefined} numberValue
             * @memberof google.protobuf.Value
             * @instance
             */
            Value.prototype.numberValue = null;

            /**
             * Value stringValue.
             * @member {string|null|undefined} stringValue
             * @memberof google.protobuf.Value
             * @instance
             */
            Value.prototype.stringValue = null;

            /**
             * Value boolValue.
             * @member {boolean|null|undefined} boolValue
             * @memberof google.protobuf.Value
             * @instance
             */
            Value.prototype.boolValue = null;

            /**
             * Value structValue.
             * @member {google.protobuf.IStruct|null|undefined} structValue
             * @memberof google.protobuf.Value
             * @instance
             */
            Value.prototype.structValue = null;

            /**
             * Value listValue.
             * @member {google.protobuf.IListValue|null|undefined} listValue
             * @memberof google.protobuf.Value
             * @instance
             */
            Value.prototype.listValue = null;

            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;

            /**
             * Value kind.
             * @member {"nullValue"|"numberValue"|"stringValue"|"boolValue"|"structValue"|"listValue"|undefined} kind
             * @memberof google.protobuf.Value
             * @instance
             */
            Object.defineProperty(Value.prototype, "kind", {
                get: $util.oneOfGetter($oneOfFields = ["nullValue", "numberValue", "stringValue", "boolValue", "structValue", "listValue"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new Value instance using the specified properties.
             * @function create
             * @memberof google.protobuf.Value
             * @static
             * @param {google.protobuf.IValue=} [properties] Properties to set
             * @returns {google.protobuf.Value} Value instance
             */
            Value.create = function create(properties) {
                return new Value(properties);
            };

            /**
             * Encodes the specified Value message. Does not implicitly {@link google.protobuf.Value.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.Value
             * @static
             * @param {google.protobuf.IValue} message Value message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Value.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.nullValue != null && Object.hasOwnProperty.call(message, "nullValue"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.nullValue);
                if (message.numberValue != null && Object.hasOwnProperty.call(message, "numberValue"))
                    writer.uint32(/* id 2, wireType 1 =*/17).double(message.numberValue);
                if (message.stringValue != null && Object.hasOwnProperty.call(message, "stringValue"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.stringValue);
                if (message.boolValue != null && Object.hasOwnProperty.call(message, "boolValue"))
                    writer.uint32(/* id 4, wireType 0 =*/32).bool(message.boolValue);
                if (message.structValue != null && Object.hasOwnProperty.call(message, "structValue"))
                    $root.google.protobuf.Struct.encode(message.structValue, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.listValue != null && Object.hasOwnProperty.call(message, "listValue"))
                    $root.google.protobuf.ListValue.encode(message.listValue, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Value message, length delimited. Does not implicitly {@link google.protobuf.Value.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.Value
             * @static
             * @param {google.protobuf.IValue} message Value message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Value.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Value message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.Value
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.Value} Value
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Value.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.Value();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.nullValue = reader.int32();
                        break;
                    case 2:
                        message.numberValue = reader.double();
                        break;
                    case 3:
                        message.stringValue = reader.string();
                        break;
                    case 4:
                        message.boolValue = reader.bool();
                        break;
                    case 5:
                        message.structValue = $root.google.protobuf.Struct.decode(reader, reader.uint32());
                        break;
                    case 6:
                        message.listValue = $root.google.protobuf.ListValue.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Value message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.Value
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.Value} Value
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Value.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Value message.
             * @function verify
             * @memberof google.protobuf.Value
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Value.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.nullValue != null && message.hasOwnProperty("nullValue")) {
                    properties.kind = 1;
                    switch (message.nullValue) {
                    default:
                        return "nullValue: enum value expected";
                    case 0:
                        break;
                    }
                }
                if (message.numberValue != null && message.hasOwnProperty("numberValue")) {
                    if (properties.kind === 1)
                        return "kind: multiple values";
                    properties.kind = 1;
                    if (typeof message.numberValue !== "number")
                        return "numberValue: number expected";
                }
                if (message.stringValue != null && message.hasOwnProperty("stringValue")) {
                    if (properties.kind === 1)
                        return "kind: multiple values";
                    properties.kind = 1;
                    if (!$util.isString(message.stringValue))
                        return "stringValue: string expected";
                }
                if (message.boolValue != null && message.hasOwnProperty("boolValue")) {
                    if (properties.kind === 1)
                        return "kind: multiple values";
                    properties.kind = 1;
                    if (typeof message.boolValue !== "boolean")
                        return "boolValue: boolean expected";
                }
                if (message.structValue != null && message.hasOwnProperty("structValue")) {
                    if (properties.kind === 1)
                        return "kind: multiple values";
                    properties.kind = 1;
                    {
                        var error = $root.google.protobuf.Struct.verify(message.structValue);
                        if (error)
                            return "structValue." + error;
                    }
                }
                if (message.listValue != null && message.hasOwnProperty("listValue")) {
                    if (properties.kind === 1)
                        return "kind: multiple values";
                    properties.kind = 1;
                    {
                        var error = $root.google.protobuf.ListValue.verify(message.listValue);
                        if (error)
                            return "listValue." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a Value message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.Value
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.Value} Value
             */
            Value.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.Value)
                    return object;
                var message = new $root.google.protobuf.Value();
                switch (object.nullValue) {
                case "NULL_VALUE":
                case 0:
                    message.nullValue = 0;
                    break;
                }
                if (object.numberValue != null)
                    message.numberValue = Number(object.numberValue);
                if (object.stringValue != null)
                    message.stringValue = String(object.stringValue);
                if (object.boolValue != null)
                    message.boolValue = Boolean(object.boolValue);
                if (object.structValue != null) {
                    if (typeof object.structValue !== "object")
                        throw TypeError(".google.protobuf.Value.structValue: object expected");
                    message.structValue = $root.google.protobuf.Struct.fromObject(object.structValue);
                }
                if (object.listValue != null) {
                    if (typeof object.listValue !== "object")
                        throw TypeError(".google.protobuf.Value.listValue: object expected");
                    message.listValue = $root.google.protobuf.ListValue.fromObject(object.listValue);
                }
                return message;
            };

            /**
             * Creates a plain object from a Value message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.Value
             * @static
             * @param {google.protobuf.Value} message Value
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Value.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (message.nullValue != null && message.hasOwnProperty("nullValue")) {
                    object.nullValue = options.enums === String ? $root.google.protobuf.NullValue[message.nullValue] : message.nullValue;
                    if (options.oneofs)
                        object.kind = "nullValue";
                }
                if (message.numberValue != null && message.hasOwnProperty("numberValue")) {
                    object.numberValue = options.json && !isFinite(message.numberValue) ? String(message.numberValue) : message.numberValue;
                    if (options.oneofs)
                        object.kind = "numberValue";
                }
                if (message.stringValue != null && message.hasOwnProperty("stringValue")) {
                    object.stringValue = message.stringValue;
                    if (options.oneofs)
                        object.kind = "stringValue";
                }
                if (message.boolValue != null && message.hasOwnProperty("boolValue")) {
                    object.boolValue = message.boolValue;
                    if (options.oneofs)
                        object.kind = "boolValue";
                }
                if (message.structValue != null && message.hasOwnProperty("structValue")) {
                    object.structValue = $root.google.protobuf.Struct.toObject(message.structValue, options);
                    if (options.oneofs)
                        object.kind = "structValue";
                }
                if (message.listValue != null && message.hasOwnProperty("listValue")) {
                    object.listValue = $root.google.protobuf.ListValue.toObject(message.listValue, options);
                    if (options.oneofs)
                        object.kind = "listValue";
                }
                return object;
            };

            /**
             * Converts this Value to JSON.
             * @function toJSON
             * @memberof google.protobuf.Value
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Value.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Value;
        })();

        /**
         * NullValue enum.
         * @name google.protobuf.NullValue
         * @enum {number}
         * @property {number} NULL_VALUE=0 NULL_VALUE value
         */
        protobuf.NullValue = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "NULL_VALUE"] = 0;
            return values;
        })();

        protobuf.ListValue = (function() {

            /**
             * Properties of a ListValue.
             * @memberof google.protobuf
             * @interface IListValue
             * @property {Array.<google.protobuf.IValue>|null} [values] ListValue values
             */

            /**
             * Constructs a new ListValue.
             * @memberof google.protobuf
             * @classdesc Represents a ListValue.
             * @implements IListValue
             * @constructor
             * @param {google.protobuf.IListValue=} [properties] Properties to set
             */
            function ListValue(properties) {
                this.values = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ListValue values.
             * @member {Array.<google.protobuf.IValue>} values
             * @memberof google.protobuf.ListValue
             * @instance
             */
            ListValue.prototype.values = $util.emptyArray;

            /**
             * Creates a new ListValue instance using the specified properties.
             * @function create
             * @memberof google.protobuf.ListValue
             * @static
             * @param {google.protobuf.IListValue=} [properties] Properties to set
             * @returns {google.protobuf.ListValue} ListValue instance
             */
            ListValue.create = function create(properties) {
                return new ListValue(properties);
            };

            /**
             * Encodes the specified ListValue message. Does not implicitly {@link google.protobuf.ListValue.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.ListValue
             * @static
             * @param {google.protobuf.IListValue} message ListValue message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ListValue.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.values != null && message.values.length)
                    for (var i = 0; i < message.values.length; ++i)
                        $root.google.protobuf.Value.encode(message.values[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ListValue message, length delimited. Does not implicitly {@link google.protobuf.ListValue.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.ListValue
             * @static
             * @param {google.protobuf.IListValue} message ListValue message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ListValue.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ListValue message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.ListValue
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.ListValue} ListValue
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ListValue.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.ListValue();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.values && message.values.length))
                            message.values = [];
                        message.values.push($root.google.protobuf.Value.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ListValue message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.ListValue
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.ListValue} ListValue
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ListValue.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ListValue message.
             * @function verify
             * @memberof google.protobuf.ListValue
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ListValue.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.values != null && message.hasOwnProperty("values")) {
                    if (!Array.isArray(message.values))
                        return "values: array expected";
                    for (var i = 0; i < message.values.length; ++i) {
                        var error = $root.google.protobuf.Value.verify(message.values[i]);
                        if (error)
                            return "values." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a ListValue message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.ListValue
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.ListValue} ListValue
             */
            ListValue.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.ListValue)
                    return object;
                var message = new $root.google.protobuf.ListValue();
                if (object.values) {
                    if (!Array.isArray(object.values))
                        throw TypeError(".google.protobuf.ListValue.values: array expected");
                    message.values = [];
                    for (var i = 0; i < object.values.length; ++i) {
                        if (typeof object.values[i] !== "object")
                            throw TypeError(".google.protobuf.ListValue.values: object expected");
                        message.values[i] = $root.google.protobuf.Value.fromObject(object.values[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a ListValue message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.ListValue
             * @static
             * @param {google.protobuf.ListValue} message ListValue
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ListValue.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.values = [];
                if (message.values && message.values.length) {
                    object.values = [];
                    for (var j = 0; j < message.values.length; ++j)
                        object.values[j] = $root.google.protobuf.Value.toObject(message.values[j], options);
                }
                return object;
            };

            /**
             * Converts this ListValue to JSON.
             * @function toJSON
             * @memberof google.protobuf.ListValue
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ListValue.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ListValue;
        })();

        protobuf.Empty = (function() {

            /**
             * Properties of an Empty.
             * @memberof google.protobuf
             * @interface IEmpty
             */

            /**
             * Constructs a new Empty.
             * @memberof google.protobuf
             * @classdesc Represents an Empty.
             * @implements IEmpty
             * @constructor
             * @param {google.protobuf.IEmpty=} [properties] Properties to set
             */
            function Empty(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new Empty instance using the specified properties.
             * @function create
             * @memberof google.protobuf.Empty
             * @static
             * @param {google.protobuf.IEmpty=} [properties] Properties to set
             * @returns {google.protobuf.Empty} Empty instance
             */
            Empty.create = function create(properties) {
                return new Empty(properties);
            };

            /**
             * Encodes the specified Empty message. Does not implicitly {@link google.protobuf.Empty.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.Empty
             * @static
             * @param {google.protobuf.IEmpty} message Empty message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Empty.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified Empty message, length delimited. Does not implicitly {@link google.protobuf.Empty.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.Empty
             * @static
             * @param {google.protobuf.IEmpty} message Empty message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Empty.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an Empty message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.Empty
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.Empty} Empty
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Empty.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.Empty();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an Empty message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.Empty
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.Empty} Empty
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Empty.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an Empty message.
             * @function verify
             * @memberof google.protobuf.Empty
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Empty.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates an Empty message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.Empty
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.Empty} Empty
             */
            Empty.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.Empty)
                    return object;
                return new $root.google.protobuf.Empty();
            };

            /**
             * Creates a plain object from an Empty message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.Empty
             * @static
             * @param {google.protobuf.Empty} message Empty
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Empty.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this Empty to JSON.
             * @function toJSON
             * @memberof google.protobuf.Empty
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Empty.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Empty;
        })();

        protobuf.Timestamp = (function() {

            /**
             * Properties of a Timestamp.
             * @memberof google.protobuf
             * @interface ITimestamp
             * @property {number|Long|null} [seconds] Timestamp seconds
             * @property {number|null} [nanos] Timestamp nanos
             */

            /**
             * Constructs a new Timestamp.
             * @memberof google.protobuf
             * @classdesc Represents a Timestamp.
             * @implements ITimestamp
             * @constructor
             * @param {google.protobuf.ITimestamp=} [properties] Properties to set
             */
            function Timestamp(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Timestamp seconds.
             * @member {number|Long} seconds
             * @memberof google.protobuf.Timestamp
             * @instance
             */
            Timestamp.prototype.seconds = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Timestamp nanos.
             * @member {number} nanos
             * @memberof google.protobuf.Timestamp
             * @instance
             */
            Timestamp.prototype.nanos = 0;

            /**
             * Creates a new Timestamp instance using the specified properties.
             * @function create
             * @memberof google.protobuf.Timestamp
             * @static
             * @param {google.protobuf.ITimestamp=} [properties] Properties to set
             * @returns {google.protobuf.Timestamp} Timestamp instance
             */
            Timestamp.create = function create(properties) {
                return new Timestamp(properties);
            };

            /**
             * Encodes the specified Timestamp message. Does not implicitly {@link google.protobuf.Timestamp.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.Timestamp
             * @static
             * @param {google.protobuf.ITimestamp} message Timestamp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Timestamp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.seconds != null && Object.hasOwnProperty.call(message, "seconds"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.seconds);
                if (message.nanos != null && Object.hasOwnProperty.call(message, "nanos"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.nanos);
                return writer;
            };

            /**
             * Encodes the specified Timestamp message, length delimited. Does not implicitly {@link google.protobuf.Timestamp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.Timestamp
             * @static
             * @param {google.protobuf.ITimestamp} message Timestamp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Timestamp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Timestamp message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.Timestamp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.Timestamp} Timestamp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Timestamp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.Timestamp();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.seconds = reader.int64();
                        break;
                    case 2:
                        message.nanos = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Timestamp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.Timestamp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.Timestamp} Timestamp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Timestamp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Timestamp message.
             * @function verify
             * @memberof google.protobuf.Timestamp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Timestamp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.seconds != null && message.hasOwnProperty("seconds"))
                    if (!$util.isInteger(message.seconds) && !(message.seconds && $util.isInteger(message.seconds.low) && $util.isInteger(message.seconds.high)))
                        return "seconds: integer|Long expected";
                if (message.nanos != null && message.hasOwnProperty("nanos"))
                    if (!$util.isInteger(message.nanos))
                        return "nanos: integer expected";
                return null;
            };

            /**
             * Creates a Timestamp message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.Timestamp
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.Timestamp} Timestamp
             */
            Timestamp.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.Timestamp)
                    return object;
                var message = new $root.google.protobuf.Timestamp();
                if (object.seconds != null)
                    if ($util.Long)
                        (message.seconds = $util.Long.fromValue(object.seconds)).unsigned = false;
                    else if (typeof object.seconds === "string")
                        message.seconds = parseInt(object.seconds, 10);
                    else if (typeof object.seconds === "number")
                        message.seconds = object.seconds;
                    else if (typeof object.seconds === "object")
                        message.seconds = new $util.LongBits(object.seconds.low >>> 0, object.seconds.high >>> 0).toNumber();
                if (object.nanos != null)
                    message.nanos = object.nanos | 0;
                return message;
            };

            /**
             * Creates a plain object from a Timestamp message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.Timestamp
             * @static
             * @param {google.protobuf.Timestamp} message Timestamp
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Timestamp.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.seconds = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.seconds = options.longs === String ? "0" : 0;
                    object.nanos = 0;
                }
                if (message.seconds != null && message.hasOwnProperty("seconds"))
                    if (typeof message.seconds === "number")
                        object.seconds = options.longs === String ? String(message.seconds) : message.seconds;
                    else
                        object.seconds = options.longs === String ? $util.Long.prototype.toString.call(message.seconds) : options.longs === Number ? new $util.LongBits(message.seconds.low >>> 0, message.seconds.high >>> 0).toNumber() : message.seconds;
                if (message.nanos != null && message.hasOwnProperty("nanos"))
                    object.nanos = message.nanos;
                return object;
            };

            /**
             * Converts this Timestamp to JSON.
             * @function toJSON
             * @memberof google.protobuf.Timestamp
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Timestamp.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Timestamp;
        })();

        return protobuf;
    })();

    return google;
})();

module.exports = $root;
